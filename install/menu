#!/bin/bash
clear
[[ "$(whoami)" != "root" ]] && {
	echo -e "\033[1;33m[\033[1;31m| NO HAS INICIADO CORRECTAMENTE EL SCRIPT, DEVES INICIAR COMO USUARIO ROOT |\033[1;33m] \033[1;37mDEVES EJECUTAR EL SIGUIENTE COMANDO \033[1;33msudo -i\033[0m"
	exit 0
}

[[ ! -d /usr/local/include/snaps ]] && exit
[[ ! -d /usr/local/lib/sped/tools ]] && exit

_hora=$(printf '%(%D-%H:%M:%S)T')
#COLORES
red=$(tput setaf 1)
gren=$(tput setaf 2)
yellow=$(tput setaf 3)
SCPdir="/etc/VPS-MX" && [[ ! -d ${SCPdir} ]] && exit 1
DIR="/etc/VPS-MX"
SCPusr="${SCPdir}/controlador"
SCPfrm="${SCPdir}/herramientas"
SCPinst="${SCPdir}/protocolos"
SCPidioma="${SCPdir}/idioma"
#PROCESSADOR
_core=$(printf '%-1s' "$(grep -c cpu[0-9] /proc/stat)")
_usop=$(top -bn1 | sed -rn '3s/[^0-9]* ([0-9\.]+) .*/\1/p;4s/.*, ([0-9]+) .*/\1/p' | tr '\n' ' ')

#SISTEMA-USO DA CPU-MEMORIA RAM
ram1=$(free -h | grep -i mem | awk {'print $2'})
ram2=$(free -h | grep -i mem | awk {'print $4'})
ram3=$(free -h | grep -i mem | awk {'print $3'})

_ram=$(printf ' %-9s' "$(free -h | grep -i mem | awk {'print $2'})")
_usor=$(printf '%-8s' "$(free -m | awk 'NR==2{printf "%.2f%%", $3*100/$2 }')")

if [[ -e /etc/bash.bashrc-bakup ]]; then
	AutoRun="\033[1;32m[ON]"
elif [[ -e /etc/bash.bashrc ]]; then
	AutoRun="\033[1;31m[OFF]"
fi
# Funcoes Globais
msg() {
	#ACTULIZADOR
	[[ ! -d /usr/local/lib/rm ]] && exit
	[[ ! -e /etc/versin_script ]] && echo 1 >/etc/versin_script
	v11=$(cat /etc/versin_script_new)
	v22=$(cat /etc/versin_script)
	#[[ $v11 = $22 ]] &&
	vesaoSCT="\033[1;37mVersion \033[1;32m$v22\033[1;31m]" #|| vesaoSCT="\033[1;32mUPDATE\033[1;91m[\033[1;32m$v11\033[1;31m]"
	aviso_bock() {
		echo 'echo -e "\033[1;91m————————————————————————————————————————————————————\n       ¡SCRIPT BLOQUEADO POR CLONING|| CONTACTE CON SU PROVEDOR ! \n————————————————————————————————————————————————————"' >/usr/bin/menu
		echo 'echo -e "\033[1;91m————————————————————————————————————————————————————\n       ¡SCRIPT BLOQUEADO POR CLONING|| CONTACTE CON SU PROVEDOR ! \n————————————————————————————————————————————————————"' >/usr/bin/VPS-MX
		rm -rf /etc/VPS-MX
	}
	local colors="/etc/VPS-MX/colors"
	if [[ ! -e $colors ]]; then
		COLOR[0]='\033[1;37m' #BRAN='\033[1;37m'
		COLOR[1]='\e[93m'     #VERMELHO='\e[31m'
		COLOR[2]='\e[92m'     #VERDE='\e[32m'
		COLOR[3]='\e[91m'     #AMARELO='\e[33m'
		COLOR[4]='\e[94m'     #AZUL='\e[34m'
		COLOR[5]='\e[95m'     #MAGENTA='\e[35m'
		COLOR[6]='\033[1;97m' #MAG='\033[1;36m'
		COLOR[7]='\033[36m'   #MAG='\033[36m'
	else
		local COL=0
		for number in $(cat $colors); do
			case $number in
			1) COLOR[$COL]='\033[1;37m' ;;
			2) COLOR[$COL]='\e[31m' ;;
			3) COLOR[$COL]='\e[32m' ;;
			4) COLOR[$COL]='\e[33m' ;;
			5) COLOR[$COL]='\e[34m' ;;
			6) COLOR[$COL]='\e[35m' ;;
			7) COLOR[$COL]='\033[1;36m' ;;
			8) COLOR[$COL]='\e[36m' ;;
			esac
			let COL++
		done
	fi
	NEGRITO='\e[1m'
	SEMCOR='\e[0m'
	case $1 in
	-ne) cor="${COLOR[1]}${NEGRITO}" && echo -ne "${cor}${2}${SEMCOR}" ;;
	-nazu) cor="${COLOR[6]}${NEGRITO}" && echo -ne "${cor}${2}${SEMCOR}" ;;
	-nverd) cor="${COLOR[2]}${NEGRITO}" && echo -ne "${cor}${2}${SEMCOR}" ;;
	-nama) cor="${COLOR[1]}${NEGRITO}" && echo -ne "${cor}${2}${SEMCOR}" ;;
	-ama) cor="${COLOR[1]}${NEGRITO}" && echo -e "${cor}${2}${SEMCOR}" ;;
	-verm) cor="${COLOR[3]}${NEGRITO}[!] ${COLOR[1]}" && echo -e "${cor}${2}${SEMCOR}" ;;
	-verm2) cor="${COLOR[3]}${NEGRITO}" && echo -e "${cor}${2}${SEMCOR}" ;;
	-nverm) cor="${COLOR[3]}${NEGRITO}" && echo -ne "${cor}${2}${SEMCOR}" ;;
	-azu) cor="${COLOR[6]}${NEGRITO}" && echo -e "${cor}${2}${SEMCOR}" ;;
	-azuc) cor="${COLOR[7]}${NEGRITO}" && echo -e "${cor}${2}${SEMCOR}" ;;
	-verd) cor="${COLOR[2]}${NEGRITO}" && echo -e "${cor}${2}${SEMCOR}" ;;
	-azul) cor="${COLOR[4]}${NEGRITO}" && echo -e "${cor}${2}${SEMCOR}" ;;
	-bra) cor="${COLOR[0]}${SEMCOR}" && echo -e "${cor}${2}${SEMCOR}" ;;
	-nblanco) cor="${COLOR[0]}${SEMCOR}" && echo -ne "${cor}${2}${SEMCOR}" ;;
	"-bar2" | "-bar") cor="\e[1;30m————————————————————————————————————————————————————" && echo -e "${SEMCOR}${cor}${SEMCOR}" ;;
	-tit) echo -e "\e[91m≪━━─━━─━─━─━─━─━━─━━─━─━─◈─━━─━─━─━─━━─━─━━─━─━━─━≫ \e[0m\n  \e[2;97m\e[3;93m❯❯❯❯❯❯ ꜱᴄʀɪᴩᴛ ᴍᴏᴅ ʟᴀᴄᴀꜱɪᴛᴀᴍx ❮❮❮❮❮❮\033[0m \033[1;31m[\033[1;32m$vesaoSCT\n\e[91m≪━━─━─━━━─━─━─━─━─━━─━─━─◈─━─━─━─━─━━━─━─━─━━━─━─━≫   \e[0m" && echo -e "${SEMCOR}${cor}${SEMCOR}" ;;
	-bar3) $([[ ! -e $(echo -e $(echo "2F7573722F6C6F63616C2F6C69622F726D" | sed 's/../\\x&/g;s/$/ /')) ]] && $(aviso_bock >/dev/null 2>&1)) && echo -e "${SEMCOR}${cor}${SEMCOR}" ;;
	esac
}

[[ ! -d /usr/local/lib/sped ]] && exit

canbio_color() {
	clear
	msg -bar2
	msg -tit
	msg -ama "     CONTROLADOR DE COLORES DEL SCRIP VPS-MX"
	msg -bar2
	msg -ama "$(fun_trans "Selecione 7 cores"): "
	echo -e '\033[1;37m [1] ###\033[0m'
	echo -e '\e[31m [2] ###\033[0m'
	echo -e '\e[32m [3] ###\033[0m'
	echo -e '\e[33m [4] ###\033[0m'
	echo -e '\e[34m [5] ###\033[0m'
	echo -e '\e[35m [6] ###\033[0m'
	echo -e '\033[1;36m [7] ###\033[0m'
	msg -bar2
	for number in $(echo {1..7}); do
		msg -ne "$(fun_trans "Digite un Color") [$number]: " && read corselect
		[[ $corselect != @([1-7]) ]] && corselect=1
		cores+="$corselect "
		corselect=0
	done
	echo "$cores" >/etc/VPS-MX/colors
	msg -bar2
}
mportas() {
	unset portas
	portas_var=$(lsof -V -i tcp -P -n | grep -v "ESTABLISHED" | grep -v "COMMAND" | grep "LISTEN")
	while read port; do
		var1=$(echo $port | awk '{print $1}') && var2=$(echo $port | awk '{print $9}' | awk -F ":" '{print $2}')
		[[ "$(echo -e $portas | grep "$var1 $var2")" ]] || portas+="$var1 $var2\n"
	done <<<"$portas_var"
	i=1
	echo -e "$portas"
}
fun_trans() {
	local texto
	local retorno
	declare -A texto
	SCPidioma="${SCPdir}/idioma"
	[[ ! -e ${SCPidioma} ]] && touch ${SCPidioma}
	local LINGUAGE=$(cat ${SCPidioma})
	[[ -z $LINGUAGE ]] && LINGUAGE=es
	[[ $LINGUAGE = "es" ]] && echo "$@" && return
	[[ ! -e /usr/bin/trans ]] && wget -O /usr/bin/trans https://raw.githubusercontent.com/pedrazadixon/LACASITANULLED/main/scriptsmx/script/Install/trans &>/dev/null
	[[ ! -e /etc/VPS-MX/texto-mx ]] && touch /etc/VPS-MX/texto-mx
	source /etc/VPS-MX/texto-mx
	if [[ -z "$(echo ${texto[$@]})" ]]; then
		#ENGINES=(aspell google deepl bing spell hunspell apertium yandex)
		#NUM="$(($RANDOM%${#ENGINES[@]}))"
		retorno="$(source trans -e bing -b es:${LINGUAGE} "$@" | sed -e 's/[^a-z0-9 -]//ig' 2>/dev/null)"
		echo "texto[$@]='$retorno'" >>/etc/VPS-MX/texto-mx
		echo "$retorno"
	else
		echo "${texto[$@]}"
	fi
}
function_verify() {
	### INTALAR VERSION DE SCRIPT
	v1=$(curl -sSL "https://raw.githubusercontent.com/pedrazadixon/LACASITANULLED/main/vercion")
	echo "$v1" >/etc/versin_script
	echo "$v1" >/etc/versin_script_new
}
atualiza_fun() {
	fun_ip
	SCPinstal="$HOME/install"
	verificar_arq() {
		case $1 in
		"menu" | "message.txt" | "ID") ARQ="${SCPdir}/" ;;                                                                #Menu
		"usercodes") ARQ="${SCPusr}/" ;;                                                                                  #Panel SSRR
		"C-SSR.sh" | "proxy.sh" | "wireguard.sh") ARQ="${SCPinst}/" ;;                                                    #Panel SSR
		"openssh.sh") ARQ="${SCPinst}/" ;;                                                                                #OpenVPN
		"squid.sh") ARQ="${SCPinst}/" ;;                                                                                  #Squid
		"dropbear.sh") ARQ="${SCPinst}/" ;;                                                                               #Instalacao
		"openvpn.sh") ARQ="${SCPinst}/" ;;                                                                                #Instalacao
		"ssl.sh" | "UDPcustom.sh") ARQ="${SCPinst}/" ;;                                                                   #Instalacao
		"shadowsocks.sh" | "proxy.sh" | "python.py") ARQ="${SCPinst}/" ;;                                                 #Instalacao
		"Shadowsocks-libev.sh" | "slowdns.sh") ARQ="${SCPinst}/" ;;                                                       #Instalacao
		"Shadowsocks-R.sh") ARQ="${SCPinst}/" ;;                                                                          #Instalacao
		"v2ray.sh") ARQ="${SCPinst}/" ;;                                                                                  #Instalacao
		"budp.sh") ARQ="${SCPinst}/" ;;                                                                                   #Instalacao
		"name" | "adminkey") ARQ="${SCPdir}/tmp/" ;;                                                                      #Instalacao
		"sockspy.sh" | "PDirect.py" | "PPub.py" | "PPriv.py" | "POpen.py" | "PGet.py" | "python.py") ARQ="${SCPinst}/" ;; #Instalacao
		*) ARQ="${SCPfrm}/" ;;                                                                                            #Herramientas
		esac
		mv -f ${SCPinstal}/$1 ${ARQ}/$1
		chmod +x ${ARQ}/$1
	}
	error_fun() {
		msg -bar2 && msg -verm "ERROR entre VPS<-->GENERADOR (Port 81 TCP)" && msg -bar2
		[[ -d ${SCPinstal} ]] && rm -rf ${SCPinstal}
		exit 1
	}
	invalid_key() {
		msg -bar2 && msg -verm "  Code Invalido -- #¡Key Invalida#! " && msg -bar2
		[[ -e $HOME/lista-arq ]] && rm -r $HOME/lista-arq
		exit 1
	}
	while [[ ! $Key ]]; do
		clear
		clear
		msg -bar
		msg -tit
		echo -e "\033[1;91m		\e[3;100mACTUALIZACION DEL SCRIPT LACASITAMX\e[0m"
		msg -bar2 && msg -ne "\033[1;93m          >>> INTRODUZCA LA KEY ABAJO <<<\n   \033[1;37m" && read Key
		tput cuu1 && tput dl1
	done
	msg -ne "    # Verificando Key # : "
	cd $HOME
	wget -O $HOME/lista-arq "https://raw.githubusercontent.com/pedrazadixon/LACASITANULLED/main/lista-arq" >/dev/null 2>&1 && echo -e "\033[1;32m Code Correcto de KEY" || {
		echo -e "\033[1;91m Code Incorrecto de KEY"
		invalid_key
		exit
	}
	IP=$(ofus "$Key" | grep -vE '127\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}' | grep -o -E '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}') && echo "$IP" >/usr/bin/vendor_code
	sleep 0.1s

	function_verify

	if [[ -e $HOME/lista-arq ]] && [[ ! $(cat $HOME/lista-arq | grep "Code de KEY Invalido!") ]]; then
		msg -bar2
		msg -verd "    $(source trans -b es:es "Ficheros Copiados" | sed -e 's/[^a-z -]//ig'): \e[97m[\e[93mSCRIPT MOD @conectedmx_bot\e[97m]"
		REQUEST=$(ofus "$Key" | cut -d'/' -f2)
		[[ ! -d ${SCPinstal} ]] && mkdir ${SCPinstal}
		pontos="."
		stopping="Configurando Directorios"
		for arqx in $(cat $HOME/lista-arq); do
			msg -verm "${stopping}${pontos}"
			wget --no-check-certificate -O ${SCPinstal}/${arqx} https://raw.githubusercontent.com/pedrazadixon/LACASITANULLED/main/install/${arqx} >/dev/null 2>&1 && verificar_arq "${arqx}" || error_fun
			tput cuu1 && tput dl1
			pontos+="."
		done
		userid="${SCPdir}/ID"
		TOKEN="xxxxxx"
		URL="https://api.telegram.org/bot$TOKEN/sendMessage"
		while read user; do
			if [[ $(cat ${userid} | grep "605531451") = "" ]]; then
				MSG="👇= SCRIPT ACTUALIZADO =👇"
				# curl -s --max-time 10 -d "chat_id=${user}&disable_web_page_preview=1&text=$MSG" $URL &>/dev/null
				# curl -s --max-time 10 -d "chat_id=605531451&disable_web_page_preview=1&text=$MSG" $URL &>/dev/null
			else
				MSG="👇= SCRIPT ACTUALIZADO =👇"
				# curl -s --max-time 10 -d "chat_id=${user}&disable_web_page_preview=1&text=$MSG" $URL &>/dev/null
			fi
		done <<<"$(cat ${userid} | cut -d' ' -f1)"

		[[ ! -d ${SCPdir}/tmp ]] && mkdir ${SCPdir}/tmp
		wget -O ${SCPdir}/tmp/verifi https://raw.githubusercontent.com/pedrazadixon/LACASITANULLED/main/verifi &>/dev/null
		wget -O ${SCPdir}/tmp/monitor https://raw.githubusercontent.com/pedrazadixon/LACASITANULLED/main/monitor &>/dev/null
		wget -O ${SCPdir}/tmp/autodes https://raw.githubusercontent.com/pedrazadixon/LACASITANULLED/main/autodes &>/dev/null
		wget -O ${SCPdir}/tmp/style https://raw.githubusercontent.com/pedrazadixon/LACASITANULLED/main/style &>/dev/null
		chmod 777 ${SCPdir}/*
		#
		wget -O /etc/VPS-MX/protocolos/chekuser.sh https://raw.githubusercontent.com/pedrazadixon/LACASITANULLED/main/chekuser.sh &>/dev/null
		chmod 777 /etc/VPS-MX/protocolos/chekuser.sh
		wget -O /etc/VPS-MX/protocolos/chekuser.py https://raw.githubusercontent.com/pedrazadixon/LACASITANULLED/main/chekuser.py &>/dev/null
		chmod 777 /etc/VPS-MX/protocolos/chekuser.py
		msg -bar2
		[[ -e $HOME/lista-arq ]] && rm -rf $HOME/lista-arq
		cat /etc/bash.bashrc | grep -v '[[ $UID != 0 ]] && TMOUT=15 && export TMOUT' >/etc/bash.bashrc.2
		echo -e '[[ $UID != 0 ]] && TMOUT=15 && export TMOUT' >>/etc/bash.bashrc.2
		mv -f /etc/bash.bashrc.2 /etc/bash.bashrc
		rm -rf /usr/bin/menu
		rm -rf /usr/bin/VPSMX
		ln -s /etc/VPS-MX/menu /usr/bin/menu
		ln -s /etc/VPS-MX/menu /usr/bin/VPSMX
		echo "$Key" >${SCPdir}/key.txt
		[[ -d ${SCPinstal} ]] && rm -rf ${SCPinstal}
		export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games/
		rm -rf /root/lista-arq

		[[ ${#id} -gt 2 ]] && echo "es" >${SCPidioma} || echo "es" >${SCPidioma}
		echo -e "${cor[2]}               ACTUALIZACION COMPLETA "
		echo -e "         COMANDO PRINCIPAL PARA ENTRAR AL PANEL "
		echo -e "  \033[1;37m               sudo menu             \033[0;37m" && msg -bar2
		rm -rf $HOME/lista-arq
	else
		invalid_key
	fi
	exit 1
}
funcao_idioma() {
	tput cuu1 && tput dl1
	msg -bar2
	declare -A idioma=([1]="en English" [2]="fr Franch" [3]="de German" [4]="it Italian" [5]="pl Polish" [6]="pt Portuguese" [7]="es Spanish" [8]="tr Turkish")
	for ((i = 1; i <= 12; i++)); do
		valor1="$(echo ${idioma[$i]} | cut -d' ' -f2)"
		[[ -z $valor1 ]] && break
		valor1="\033[1;32m[$i] > \033[1;33m$valor1"
		while [[ ${#valor1} -lt 37 ]]; do
			valor1=$valor1" "
		done
		echo -ne "$valor1"
		let i++
		valor2="$(echo ${idioma[$i]} | cut -d' ' -f2)"
		[[ -z $valor2 ]] && {
			echo -e " "
			break
		}
		valor2="\033[1;32m[$i] > \033[1;33m$valor2"
		while [[ ${#valor2} -lt 37 ]]; do
			valor2=$valor2" "
		done
		echo -ne "$valor2"
		let i++
		valor3="$(echo ${idioma[$i]} | cut -d' ' -f2)"
		[[ -z $valor3 ]] && {
			echo -e " "
			break
		}
		valor3="\033[1;32m[$i] > \033[1;33m$valor3"
		while [[ ${#valor3} -lt 37 ]]; do
			valor3=$valor3" "
		done
		echo -e "$valor3"
	done
	msg -bar2
	unset selection
	while [[ ${selection} != @([1-8]) ]]; do
		echo -ne "\033[1;37m$(fun_trans "  ► Selecione una Opcion"): " && read selection
		tput cuu1 && tput dl1
	done
	[[ -e /etc/VPS-MX/texto-mx ]] && rm /etc/VPS-MX/texto-mx
	echo "$(echo ${idioma[$selection]} | cut -d' ' -f1)" >${SCPidioma}
}

menu_info() {
	meu_ip &>/dev/null
	#export -f fun_ip
	if [[ "$(grep -c "Ubuntu" /etc/issue.net)" = "1" ]]; then
		system=$(cut -d' ' -f1 /etc/issue.net)
		system+=$(echo ' ')
		system+=$(cut -d' ' -f2 /etc/issue.net | awk -F "." '{print $1}')
	elif [[ "$(grep -c "Debian" /etc/issue.net)" = "1" ]]; then
		system=$(cut -d' ' -f1 /etc/issue.net)
		system+=$(echo ' ')
		system+=$(cut -d' ' -f3 /etc/issue.net)
	else
		system=$(cut -d' ' -f1 /etc/issue.net)
	fi

	#_ram=$(printf '%-10s' "$(free -h | grep -i mem | awk {'print $2'})")
	_usor=$(printf '%-8s' "$(free -m | awk 'NR==2{printf "%.2f%%", $3*100/$2 }')")
	_ram=$(printf ' %-8s' "$(free -h | grep -i mem | awk {'print $2'})")
	_ram2=$(printf ' %-8s' "$(free -h | grep -i mem | awk {'print $4'})")
	_system=$(printf '%-9s' "$system")
	#_usop=$(printf '%-1s' "$(top -bn1 | awk '/Cpu/ { cpu = "" 100 - $8 "%" }; END { print cpu }')")
	#_core=$(printf '%-8s' "$(grep -c cpu[0-9] /proc/stat)")
	_core=$(printf '%-8s' "$(grep -c cpu[0-9] /proc/stat)")
	_usop=$(top -bn1 | sed -rn '3s/[^0-9]* ([0-9\.]+) .*/\1/p;4s/.*, ([0-9]+) .*/\1/p' | tr '\n' ' ')

	modelo1=$(printf '%-11s' "$(lscpu | grep Arch | sed 's/\s\+/,/g' | cut -d , -f2)")
	mb=$(printf '%-8s' "$(free -h | grep Mem | sed 's/\s\+/,/g' | cut -d , -f6)")
	_hora=$(printf '%(%H:%M:%S)T')
	_hoje=$(date +'%d/%m/%Y')

	echo -e "\033[1;37m OS \033[1;31m: \033[1;32m$_system \033[1;37mHORA\033[1;31m: \033[1;32m$_hora  \033[1;37mIP\033[1;31m:\033[1;32m $IP"
	echo -e "\033[1;37m RAM\e[31m: \033[1;32m$_ram \033[1;37mUSADO\033[1;31m: \033[1;32m$mb\033[1;37m LIBRE\033[1;31m: \033[1;32m$_ram2"

}

ofus() {
	unset txtofus
	number=$(expr length $1)
	for ((i = 1; i < $number + 1; i++)); do
		txt[$i]=$(echo "$1" | cut -b $i)
		case ${txt[$i]} in
		".") txt[$i]="C" ;;
		"C") txt[$i]="." ;;
		"3") txt[$i]="@" ;;
		"@") txt[$i]="3" ;;
		"5") txt[$i]="9" ;;
		"9") txt[$i]="5" ;;
		"6") txt[$i]="D" ;;
		"D") txt[$i]="6" ;;
		"J") txt[$i]="Z" ;;
		"Z") txt[$i]="J" ;;
		esac
		txtofus+="${txt[$i]}"
	done
	echo "$txtofus" | rev
}
SPR &
limpar_caches() {
	(
		VE="\033[1;33m" && MA="\033[1;31m" && DE="\033[1;32m"
		while [[ ! -e /tmp/abc ]]; do
			A+="#"
			echo -e "${VE}[${MA}${A}${VE}]" >&2
			sleep 0.3s
			tput cuu1 && tput dl1
		done
		echo -e "${VE}[${MA}${A}${VE}] - ${DE}[100%]" >&2
		rm /tmp/abc
	) &
	echo 3 >/proc/sys/vm/drop_caches &>/dev/null
	sleep 1s
	sysctl -w vm.drop_caches=3 &>/dev/null
	apt-get autoclean -y &>/dev/null
	sleep 1s
	apt-get clean -y &>/dev/null
	rm /tmp/* &>/dev/null
	touch /tmp/abc
	sleep 0.5s
	msg -bar
	msg -ama "$(fun_trans "PROCESO CONCLUIDO")"
	msg -bar
}
[[ ! -d /usr/local/libreria ]] && exit
fun_autorun() {
	if [[ -e /etc/bash.bashrc-bakup ]]; then
		mv -f /etc/bash.bashrc-bakup /etc/bash.bashrc
		cat /etc/bash.bashrc | grep -v "/etc/VPS-MX/menu" >/tmp/bash
		mv -f /tmp/bash /etc/bash.bashrc
		msg -ama "$(fun_trans "REMOVIDO CON EXITO")"
		msg -bar
	elif [[ -e /etc/bash.bashrc ]]; then
		cat /etc/bash.bashrc | grep -v /bin/menu >/etc/bash.bashrc.2
		echo '/etc/VPS-MX/menu' >>/etc/bash.bashrc.2
		cp /etc/bash.bashrc /etc/bash.bashrc-bakup
		mv -f /etc/bash.bashrc.2 /etc/bash.bashrc
		msg -ama "$(fun_trans "AUTO INICIALIZAR AGREGADO")"
		msg -bar
	fi
}
fun_bar() {
	comando="$1"
	_=$(
		$comando >/dev/null 2>&1
	) &
	>/dev/null
	pid=$!
	while [[ -d /proc/$pid ]]; do
		echo -ne " \033[1;33m["
		for ((i = 0; i < 10; i++)); do
			echo -ne "\033[1;31m##"
			sleep 0.2
		done
		echo -ne "\033[1;33m]"
		sleep 1s
		echo
		tput cuu1
		tput dl1
	done
	echo -e " \033[1;33m[\033[1;31m####################\033[1;33m] - \033[1;32m100%\033[0m"
	sleep 1s
}

meu_ip() {
	if [[ -e /bin/IPca ]]; then
		IP="$(cat /bin/IPca)"
	else
		MEU_IP=$(ip addr | grep 'inet' | grep -v inet6 | grep -vE '127\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}' | grep -o -E '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}' | head -1)
		MEU_IP2=$(wget -qO- ipv4.icanhazip.com)
		[[ "$MEU_IP" != "$MEU_IP2" ]] && IP="$MEU_IP2" && echo "$MEU_IP2" || IP="$MEU_IP" && echo "$MEU_IP"
		echo "$MEU_IP2" >/bin/IPca
		IP="$MEU_IP2"
	fi
}
fun_ip() {
	if [[ -e /bin/IPca ]]; then
		IP="$(cat /bin/IPca)"
	else
		MEU_IP=$(ip addr | grep 'inet' | grep -v inet6 | grep -vE '127\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}' | grep -o -E '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}' | head -1)
		MEU_IP2=$(wget -qO- ipv4.icanhazip.com)
		[[ "$MEU_IP" != "$MEU_IP2" ]] && IP="$MEU_IP2" && echo "$MEU_IP2" || IP="$MEU_IP" && echo "$MEU_IP"
		echo "$MEU_IP2" >/bin/IPca
		IP="$MEU_IP2"
	fi
}

fun_ip &>/dev/null

fun_eth() {
	eth=$(ifconfig | grep -v inet6 | grep -v lo | grep -v 127.0.0.1 | grep "encap:Ethernet" | awk '{print $1}')
	[[ $eth != "" ]] && {
		msg -bar
		msg -ama " $(fun_trans "Aplicar el sistema para mejorar los paquetes SSH?")"
		msg -ama " $(fun_trans "Opciones para usuarios avanzados")"
		msg -bar
		read -p " [S/N]: " -e -i n sshsn
		[[ "$sshsn" = @(s|S|y|Y) ]] && {
			echo -e "${cor[1]} $(fun_trans "Correccion de problemas de paquetes en SSH ...")"
			echo -e " $(fun_trans "¿Cual es la tasa RX?")"
			echo -ne "[ 1 - 999999999 ]: "
			read rx
			[[ "$rx" = "" ]] && rx="999999999"
			echo -e " $(fun_trans "¿Cual es la tasa TX?")"
			echo -ne "[ 1 - 999999999 ]: "
			read tx
			[[ "$tx" = "" ]] && tx="999999999"
			apt-get install ethtool -y >/dev/null 2>&1
			ethtool -G $eth rx $rx tx $tx >/dev/null 2>&1
		}
		msg -bar
	}
}

usercodes() {
	clear
	clear
	export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games/
	#msg -bar

	#myip=`ifconfig | grep -Eo 'inet (addr:)?([0-9]*\.){3}[0-9]*' | grep -Eo '([0-9]*\.){3}[0-9]*' | grep -v '127.0.0' | head -n1`;
	#myint=`ifconfig | grep -B1 "inet addr:$myip" | head -n1 | awk '{print $1}'`;
	NOM=$(less /etc/VPS-MX/controlador/nombre.log) >/dev/null 2>&1
	NOM1=$(echo $NOM) >/dev/null 2>&1
	IDB=$(less /etc/VPS-MX/controlador/IDT.log) >/dev/null 2>&1
	IDB1=$(echo $IDB) >/dev/null 2>&1
	declare -A TIMEUS

	MyPID="${SCPusr}/pid-vps-mx"
	MyTIME="${SCPusr}/time-vps-mx"
	USRdatabase="${SCPdir}/VPS-MXuser"
	USRdatabaseh="${SCPdir}/User-HWID"
	tokens="${SCPdir}/User-TOKEN"
	[[ ! -e ${USRdatabaseh} ]] && touch ${USRdatabaseh}
	[[ ! -e ${tokens} ]] && touch ${tokens}
	VERY="$(ps aux | grep -v grep | grep "verifi")"
	VERY2="$(ps aux | grep -v grep | grep "autodes")"
	[[ -e ${MyPID} ]] && source ${MyPID} || touch ${MyPID}
	[[ -e ${MyTIME} ]] && source ${MyTIME} || touch ${MyTIME}
	[[ ! -e ${USRdatabase} ]] && touch ${USRdatabase}
	sort ${USRdatabase} | uniq >${USRdatabase}tmp
	mv -f ${USRdatabase}tmp ${USRdatabase}

	# Open VPN
	newclient() {
		#Nome #Senha
		usermod -p $(openssl passwd -1 $2) $1
		while [[ ${newfile} != @(s|S|y|Y|n|N) ]]; do
			msg -bar
			read -p "Crear Archivo OpenVPN? [S/N]: " -e -i S newfile
			tput cuu1 && tput dl1
		done
		if [[ ${newfile} = @(s|S) ]]; then
			# Generates the custom client.ovpn
			rm -rf /etc/openvpn/easy-rsa/pki/reqs/$1.req
			rm -rf /etc/openvpn/easy-rsa/pki/issued/$1.crt
			rm -rf /etc/openvpn/easy-rsa/pki/private/$1.key
			cd /etc/openvpn/easy-rsa/
			./easyrsa build-client-full $1 nopass >/dev/null 2>&1
			cd

			cp /etc/openvpn/client-common.txt ~/$1.ovpn
			echo "<ca>" >>~/$1.ovpn
			cat /etc/openvpn/easy-rsa/pki/ca.crt >>~/$1.ovpn
			echo "</ca>" >>~/$1.ovpn
			echo "<cert>" >>~/$1.ovpn
			cat /etc/openvpn/easy-rsa/pki/issued/$1.crt >>~/$1.ovpn
			echo "</cert>" >>~/$1.ovpn
			echo "<key>" >>~/$1.ovpn
			cat /etc/openvpn/easy-rsa/pki/private/$1.key >>~/$1.ovpn
			echo "</key>" >>~/$1.ovpn
			echo "<tls-auth>" >>~/$1.ovpn
			cat /etc/openvpn/ta.key >>~/$1.ovpn
			echo "</tls-auth>" >>~/$1.ovpn

			while [[ ${ovpnauth} != @(s|S|y|Y|n|N) ]]; do
				read -p "$(fun_trans "Colocar autenticacion de usuario en el archivo")? [S/N]: " -e -i S ovpnauth
				tput cuu1 && tput dl1
			done
			[[ ${ovpnauth} = @(s|S) ]] && sed -i "s;auth-user-pass;<auth-user-pass>\n$1\n$2\n</auth-user-pass>;g" ~/$1.ovpn
			cd $HOME
			zip ./$1.zip ./$1.ovpn >/dev/null 2>&1
			rm ./$1.ovpn >/dev/null 2>&1

			#echo -e "\033[1;31mArchivo creado: ($HOME/$1.zip)"
			[ ! -d /var ] && mkdir /var
			[ ! -d /var/www ] && mkdir /var/www
			[ ! -d /var/www/html ] && mkdir /var/www/html
			[ ! -e /var/www/html/index.html ] && touch /var/www/html/index.html
			[ ! -e /var/www/index.html ] && touch /var/www/index.html
			chmod -R 755 /var/www
			cp $HOME/$1.zip /var/www/$1.zip
			cp $HOME/$1.zip /var/www/html/$1.zip
			echo -e "\033[1;33mArchivo creado: ($HOME/$1.zip)"
			echo -e "\033[1;37mLINK DE DESCARGA: http://$IP:81/$1.zip"
			[ ! -d /etc/ovpn ] && mkdir /etc/ovpn
			cp $HOME/$1.zip /etc/ovpn/$1.zip
		fi
	}

	unlockall2() {
		for user in $(cat /etc/passwd | grep 'home' | grep 'false' | grep -v 'syslog' | awk -F ':' '{print $1}'); do
			userpid=$(ps -u $user | awk {'print $1'})

			usermod -U $user &>/dev/null
		done
	}

	eliminar_all() {
		clear
		clear
		#msg -bar
		msg -tit
		echo -e "\033[1;31m       BORRAR TODOS LOS USUARIOS REGISTRADOS"
		msg -bar
		read -p "   ►► Enter para Continuar  o CTRL + C Cancelar ◄◄"
		echo ""
		service dropbear stop &>/dev/null
		service sshd stop &>/dev/null
		service ssh stop &>/dev/null
		service stunnel4 stop &>/dev/null
		service squid stop &>/dev/null
		for user in $(cat /etc/passwd | grep 'home' | grep 'false' | grep -v 'syslog' | awk -F ':' '{print $1}'); do
			userpid=$(ps -u $user | awk {'print $1'})
			kill "$userpid" 2>/dev/null
			userdel $user
			echo -e "\033[1;32mUSUARIO:\033[1;33m $user \033[1;31mEliminado"
		done
		rm -rf ${SCPdir}/VPS-MXuser
		rm -rf ${USRdatabaseh}
		rm -rf ${tokens}
		rm /etc/userssh &>/dev/null
		rm /etc/userhwid &>/dev/null
		rm /etc/usertoken &>/dev/null
		service sshd restart &>/dev/null
		service ssh restart &>/dev/null
		service dropbear start &>/dev/null
		service stunnel4 start &>/dev/null
		service squid restart &>/dev/null
		rm -rf ${SCPdir}/VPS-MX-userlock &>/dev/null
		rm -rf /etc/VPS-MX/controlador/Limiter.log &>/dev/null
		unlockall2
		msg -bar
		msg -ne " Enter Para Continuar" && read enter
		usercodes
	}

	reset_contador() {
		clear
		clear
		#msg -bar
		msg -tit
		echo -e "\033[1;33m          REINICIAR CONTADOR DE BLOQUEOS"
		msg -bar
		echo -e "\033[1;97m !! Usar unicamente cuando en el apartado del contador\nmarque alguna cantidad erronea. ¡¡"
		echo ""
		echo -e "\033[1;91m ## Cancelar Precione CTRL+C"
		msg -bar
		read -p "        ►► Presione enter para continuar ◄◄"
		rm -rf /etc/VPS-MX/VPS-MX-userlock
		rm -rf /etc/VPS-MX/controlador/Limiter.log
		unlockall2
		msg -bar
		echo -e "\033[1;92m           ¡¡CONTADORES REINICIADOS!!"
		msg -bar
		msg -ne " Enter Para Continuar" && read enter
		usercodes
	}

	droppids() {
		local pids

		local portasVAR=$(lsof -V -i tcp -P -n | grep -v "ESTABLISHED" | grep -v "COMMAND" | grep "LISTEN")
		local NOREPEAT
		local reQ
		local Port
		while read port; do
			reQ=$(echo ${port} | awk '{print $1}')
			Port=$(echo {$port} | awk '{print $9}' | awk -F ":" '{print $2}')
			[[ $(echo -e $NOREPEAT | grep -w "$Port") ]] && continue
			NOREPEAT+="$Port\n"
			case ${reQ} in

			dropbear)
				[[ -z $DPB ]] && local DPB="\033[1;31m DROPBEAR: \033[1;32m"
				DPB+="$Port "
				;;

			esac
		done <<<"${portasVAR}"

		[[ ! -z $DPB ]] && echo -e $DPB

		local port_dropbear="$DPB"
		#cat /var/log/auth.log|grep "$(date|cut -d' ' -f2,3)" > /var/log/authday.log
		cat /var/log/auth.log | tail -1000 >/var/log/authday.log
		local log=/var/log/authday.log
		local loginsukses='Password auth succeeded'
		[[ -z $port_dropbear ]] && return 1
		for port in $(echo $port_dropbear); do
			for pidx in $(ps ax | grep dropbear | grep "$port" | awk -F" " '{print $1}'); do
				pids="${pids}$pidx\n"
			done
		done
		for pid in $(echo -e "$pids"); do
			pidlogs=$(grep $pid $log | grep "$loginsukses" | awk -F" " '{print $3}')
			i=0
			for pidend in $pidlogs; do
				let i++
			done
			if [[ $pidend ]]; then
				login=$(grep $pid $log | grep "$pidend" | grep "$loginsukses")
				PID=$pid
				user=$(echo $login | awk -F" " '{print $10}' | sed -r "s/'//g")
				waktu=$(echo $login | awk -F" " '{print $2"-"$1,$3}')
				[[ -z $user ]] && continue
				echo "$user|$PID|$waktu"
			fi
		done
	}

	block_userfun() {
		local USRloked="/etc/VPS-MX/VPS-MX-userlock"
		local LIMITERLOG="${USRdatabase}/Limiter.log"
		local LIMITERLOG2="${USRdatabase}/Limiter2.log"
		if [[ $2 = "-loked" ]]; then
			[[ $(cat ${USRloked} | grep -w "$1") ]] && return 1
			echo " $1 (BLOCK-MULTILOGIN) $(date +%r--%d/%m/%y)"
			limseg="$(less /etc/VPS-MX/controlador/tiemdes.log)"
			KEY="xxxxxx"
			URL="https://api.telegram.org/bot$KEY/sendMessage"
			MSG="⚠️ AVISO DE VPS: $NOM1 ⚠️🔹 CUENTA: $1 ❗️📵 BLOCK FIJO/TEMPORAL 📵❗️🔓( AUTOUNLOCK EN $limseg SEGUNDOS) 🔓"
			# curl -s --max-time 10 -d "chat_id=$IDB1&disable_web_page_preview=1&text=$MSG" $URL &>/dev/null

			pkill -u $1 &>/dev/null

		fi
		if [[ $(cat ${USRloked} | grep -w "$1") ]]; then
			usermod -U "$1" &>/dev/null
			[[ -e ${USRloked} ]] && {
				newbase=$(cat ${USRloked} | grep -w -v "$1")
				[[ -e ${USRloked} ]] && rm ${USRloked}
				for value in $(echo ${newbase}); do
					echo $value >>${USRloked}
				done
			}
			[[ -e ${LIMITERLOG} ]] && [[ $(cat ${LIMITERLOG} | grep -w "$1") ]] && {
				newbase=$(cat ${LIMITERLOG} | grep -w -v "$1")
				[[ -e ${LIMITERLOG} ]] && rm ${LIMITERLOG}
				for value in $(echo ${newbase}); do
					echo $value >>${LIMITERLOG}
					echo $value >>${LIMITERLOG}
				done
			}
			return 1
		else
			usermod -L "$1" &>/dev/null
			pkill -u $1 &>/dev/null

			droplim=$(droppids | grep -w "$1" | cut -d'|' -f2)
			kill -9 $droplim &>/dev/null

			echo $1 >>${USRloked}
			#notifi &>/dev/null
			return 0
		fi

	}

	#export droppids

	#export block_userfun
	block_user() {
		clear
		clear
		#msg -bar
		local USRloked="/etc/VPS-MX/VPS-MX-userlock"
		[[ ! -e ${USRloked} ]] && touch ${USRloked}
		usuarios_ativos=('' $(mostrar_usuarios))
		if [[ -z ${usuarios_ativos[@]} ]]; then
			msg -tit
			msg -verm "$(fun_trans " BLOCK/UNBLOCK | Ningun Usuario Registrado")"
			msg -bar
			return 1
		else
			msg -tit
			msg -ama "$(fun_trans " BLOCK/UNBLOCK | UsuariosActivos del Servidor")"
			msg -bar
			Numb=1
			for us in $(echo ${usuarios_ativos[@]}); do
				if [[ $(cat ${USRloked} | grep -w "${us}") ]]; then
					msg -ne "[$Numb] ->" && echo -e "\033[1;33m ${us} \033[1;31m[Bloqueado]"
				else
					msg -ne "[$Numb] ->" && echo -e "\033[1;33m ${us} \033[1;32m[Desbloqueado]"
				fi
				let Numb++
			done
			msg -bar
		fi
		msg -ama "$(fun_trans "Escriba o Seleccione Un Usuario")"
		msg -bar
		unset selection
		while [[ ${selection} = "" ]]; do
			echo -ne "\033[1;37mSeleccione: " && read selection
			tput cuu1 && tput dl1
		done
		if [[ ! $(echo "${selection}" | egrep '[^0-9]') ]]; then
			usuario_del="${usuarios_ativos[$selection]}"
		else
			usuario_del="$selection"
		fi
		[[ -z $usuario_del ]] && {
			msg -verm "$(fun_trans "Error, Usuario Invalido")"
			msg -bar
			return 1
		}
		[[ ! $(echo ${usuarios_ativos[@]} | grep -w "$usuario_del") ]] && {
			msg -verm "$(fun_trans "Error, Usuario Invalido")"
			msg -bar
			return 1
		}
		msg -ne "$(fun_trans "Usuario Seleccionado"): " && echo -ne "$usuario_del "
		block_userfun "$usuario_del" && msg -verm "[$(fun_trans "Bloqueado")]" || msg -verd "[$(fun_trans "Desbloqueado")]"
		msg -bar
		msg -ne " Enter Para Continuar" && read enter
		usercodes
	}

	add_user() {
		declare -A inst
		pid_pro
		Fecha=$(date +%d-%m-%y-%R)
		#nome senha Dias limite
		[[ $(cat /etc/passwd | grep $1: | grep -vi [a-z]$1 | grep -v [0-9]$1 >/dev/null) ]] && return 1
		valid=$(date '+%C%y-%m-%d' -d " +$3 days") && datexp=$(date "+%F" -d " + $3 days")
		pass=$(perl -e 'print crypt($ARGV[0], "password")' $2)
		if useradd -M -s /bin/false -e ${valid} -K PASS_MAX_DAYS=$3 -p $pass -c sshm,$3 $1; then
			echo "$2" >/etc/VPS-MX/passw/$1
			echo "$1 $valid $4" >>/etc/VPS-MX/VPS-MXuser
			# echo "$1|$2|${valid}|$4" >> /etc/VPS-MX/VPS-MXuser
			echo "$1 $2 ${valid} $4" >>/etc/userssh
			msg -bar
			msg -ne "$(fun_trans "  >> IP del Servidor"): " && echo -e "$IP"
			msg -ne "$(fun_trans "  >> Usuario"): " && echo -e "$1"
			msg -ne "$(fun_trans "  >> Contraseña"): " && echo -e "$2"
			msg -ne "$(fun_trans "  >> Dias de Duracion"): " && echo -e "$3"
			msg -ne "$(fun_trans "  >> Fecha de Expiracion"): " && echo -e "$(date "+%F" -d " + $3 days")"
			msg -ne "$(fun_trans "  >> Limite de Conexion"): " && echo -e "$4"

			[[ $(dpkg --get-selections | grep -w "openvpn" | head -1) ]] && [[ -e /etc/openvpn/openvpn-status.log ]] && newclient "$1" "$2"
			msg -bar
			[[ $(ps x | grep udpServer | grep -v grep) ]] && uds="\033[1;32m[ON] " || uds="\033[1;31m[OFF]"
			[[ $(ps x | grep udp-custom | grep -v grep) ]] && udpc="\033[1;32m[ON] " || udpc="\033[1;31m[OFF]"
			if [[ ! -e /root/UDPMOD/config.json ]]; then
				hy="\033[1;31m[OFF]"

			else
				#  [[ $(ps x | grep hysteria| grep -v grep) ]] &&  ||
				hts=$(cat /root/UDPMOD/config.json | grep 'listen' | cut -d'"' -f4 | cut -d':' -f2)
				hy="\033[1;32m$hts"
			fi
			[[ $(ps x | grep zivpn | grep -v grep) ]] && ziv="\033[1;32m[ON] " || ziv="\033[1;31m[OFF]"

			#   msg -azu "	[\e[93m\e[5;100m PROTOCOLOS ABIERTOS\e[0m\e[37m]"
			msg -bar
			local_ip=$IP

			if [[ ! -e /etc/VPS-MX/.pssl.txt ]]; then ssl="\033[1;31m[OFF]"; else ssl="\e[92m$(cat /etc/VPS-MX/.pssl.txt)"; fi
			if [[ ! -e /etc/VPS-MX/.pdrop.txt ]]; then pdrop="\033[1;31m[OFF]"; else pdrop="\e[92m$(cat /etc/VPS-MX/.pdrop.txt)"; fi

			#msg -ama " Dropbear       : ${inst[dropbear]}\e[0m"
			#msg -ama " SSL/TLS        : ${inst[stunnel4]}\e[0m"
			#msg -ama " PYTHON         : ${inst[python]}\e[0m"
			#msg -ama " UDP-HYSTERIA   : $hy\e[0m"
			#msg -ama " UDP-CUSTOM     : $udpc\e[0m"
			#msg -ama " UDP-REQUEST    : $uds\e[0m"
			#msg -ama " UDP-ZIVPN      : $ziv\e[0m"

			#msg -bar
			#msg -ama " PAYLOAD Editable"
			#msg -verd " GET / HTTP/1.1[crlf]Host: $local_ip[crlf]Connection: Keep-Alive[crlf]User-Agent: [ua][crlf]Upgrade: websocket[crlf][crlf]"
			#msg -bar
			#msg -ama " Configuracion Editable"
			msg -verd " $local_ip:22@$1:$1"
			ADM_inst="/etc/VPS-MX/Slow/install"
			ADM_slow="/etc/VPS-MX/Slow/Key"
			if [[ ! -e ${ADM_slow}/server.pub ]]; then
				echo ""
			else
				msg -bar

				msg -ama "\e[97m	DATOS DE SU CONEXION SLOWDNS"
				msg -bar
				msg -ama "   Su NS (Nameserver): \e[92m$(cat ${ADM_slow}/domain_ns)"
				msg -ama "   Su Llave: \e[92m$(cat ${ADM_slow}/server.pub)"
			#msg -bar
			fi
		else
			msg -bar
			msg -verm2 "$(fun_trans "	Error, Usuario no creado")"
			msg -bar

		fi

	}
	[[ ! -d /usr/local/libreria ]] && exit
	add_hwid() {
		declare -A inst
		pid_pro
		#by @rufu99
		Fecha=$(date +%d-%m-%y-%R)
		#nome senha Dias limite
		[[ $(cat /etc/passwd | grep $1: | grep -vi [a-z]$1 | grep -v [0-9]$1 >/dev/null) ]] && return 1
		valid=$(date '+%C%y-%m-%d' -d " +$3 days") && datexp=$(date "+%F" -d " + $3 days")
		pass=$(perl -e 'print crypt($ARGV[0], "password")' $1)
		if useradd -M -s /bin/false -e ${valid} -K PASS_MAX_DAYS=$3 -p $pass -c hwid,$2 $1; then
			echo "$1" >/etc/VPS-MX/passw/$1
			echo "$1 $2 ${datexp}" >>/etc/VPS-MX/User-HWID
			echo "$1 $2 ${datexp}" >>/etc/userhwid
			msg -ne "$(fun_trans "  >> IP"): " && echo -e "$IP"
			msg -ne "$(fun_trans "  >> Nombre Del Cliente"): " && echo -e "$2"
			msg -ne "$(fun_trans "  >> HWID"): " && echo -e "$1"
			msg -ne "$(fun_trans "  >> Dias de Duracion"): " && echo -e "$3"
			msg -ne "$(fun_trans "  >> Fecha de Expiracion"): " && echo -e "$(date "+%F" -d " + $3 days")"
			#
			[[ $(ps x | grep udpServer | grep -v grep) ]] && uds="\033[1;32m[ON] " || uds="\033[1;31m[OFF]"
			[[ $(ps x | grep udp-custom | grep -v grep) ]] && udpc="\033[1;32m[ON] " || udpc="\033[1;31m[OFF]"
			if [[ ! -e /root/UDPMOD/config.json ]]; then
				hy="\033[1;31m[OFF]"

			else
				#  [[ $(ps x | grep hysteria| grep -v grep) ]] &&  ||
				hts=$(cat /root/UDPMOD/config.json | grep 'listen' | cut -d'"' -f4 | cut -d':' -f2)
				hy="\033[1;32m$hts"
			fi
			[[ $(ps x | grep zivpn | grep -v grep) ]] && ziv="\033[1;32m[ON] " || ziv="\033[1;31m[OFF]"

			#  msg -azu "	[\e[93m\e[5;100m PROTOCOLOS ABIERTOS\e[0m\e[37m]"
			msg -bar
			local_ip=$IP

			if [[ ! -e /etc/VPS-MX/.pssl.txt ]]; then ssl="\033[1;31m[OFF]"; else ssl="\e[92m$(cat /etc/VPS-MX/.pssl.txt)"; fi
			if [[ ! -e /etc/VPS-MX/.pdrop.txt ]]; then pdrop="\033[1;31m[OFF]"; else pdrop="\e[92m$(cat /etc/VPS-MX/.pdrop.txt)"; fi

			msg -verd " $local_ip:22@$1:$1"
			ADM_inst="/etc/VPS-MX/Slow/install"
			ADM_slow="/etc/VPS-MX/Slow/Key"
			if [[ ! -e ${ADM_slow}/server.pub ]]; then
				echo ""
			else
				msg -bar

				msg -ama "\e[97m	DATOS DE SU CONEXION SLOWDNS"
				msg -bar
				msg -ama "   Su NS (Nameserver): \e[92m$(cat ${ADM_slow}/domain_ns)"
				msg -ama "   Su Llave: \e[92m$(cat ${ADM_slow}/server.pub)"
			#msg -bar
			fi
		else
			msg -bar
			msg -verm2 "$(fun_trans "	Error, Usuario HWID no creado")"
			msg -bar

		fi

	}
	pid_pro() {
		proto="dropbear python stunnel4 stunnel5 v2ray node badvpn squid openvpn dns-serve ssserver ss-server"
		portas=$(lsof -V -i -P -n | grep -v "ESTABLISHED" | grep -v "COMMAND")
		for list in $proto; do
			case $list in
			dropbear | python | stunnel4 | stunnel5 | v2ray | node | badvpn | squid | openvpn | ssserver | ss-server)
				portas2=$(echo $portas | grep -w "LISTEN" | grep -w "$list")
				[[ $(echo "${portas2}" | grep "$list") ]] && inst[$list]="\033[1;32m[ON] " || inst[$list]="\033[1;31m[OFF]"
				;;
			dns-serve)
				portas2=$(echo $portas | grep -w "$list")
				[[ $(echo "${portas2}" | grep "$list") ]] && inst[$list]="\033[1;32m[ON] " || inst[$list]="\033[1;31m[OFF]"
				;;
			esac
		done
		[[ $(dpkg --get-selections | grep -w 'wireguard' | head -1) ]] && {
			if [[ $(wg | grep -w 'interface') = "" ]]; then inst[wg]="\033[1;31m[OFF]"; else inst[wg]="\033[1;32m[ON] "; fi
		} || {
			inst[wg]="\033[1;31m[OFF]"
		}
	}

	add_token() {
		declare -A inst
		pid_pro
		#by @rufu99
		Fecha=$(date +%d-%m-%y-%R)
		#nome senha Dias limite
		[[ $(cat /etc/passwd | grep $1: | grep -vi [a-z]$1 | grep -v [0-9]$1 >/dev/null) ]] && return 1
		valid=$(date '+%C%y-%m-%d' -d " +$3 days") && datexp=$(date "+%F" -d " + $3 days")
		pass=$(cat ${SCPdir}/.passw)
		pasw=$(perl -e 'print crypt($ARGV[0], "password")' $pass)
		if useradd -M -s /bin/false -e ${valid} -K PASS_MAX_DAYS=$3 -p $pasw -c token,$2 $1; then

			echo "$1 $2 ${datexp}" >>/etc/VPS-MX/User-TOKEN
			echo "$1 $2 ${datexp}" >>/etc/usertoken
			msg -bar
			msg -ne "$(fun_trans "  >> IP"): " && echo -e "$IP"
			msg -ne "$(fun_trans "  >> Nombre Del Cliente"): " && echo -e "$2"
			msg -ne "$(fun_trans "  >> TOKEN ID"): " && echo -e "$1"
			msg -ne "$(fun_trans "  >> Dias de Duracion"): " && echo -e "$3"
			msg -ne "$(fun_trans "  >> Fecha de Expiracion"): " && echo -e "$(date "+%F" -d " + $3 days")"
			#
			[[ $(ps x | grep udpServer | grep -v grep) ]] && uds="\033[1;32m[ON] " || uds="\033[1;31m[OFF]"
			[[ $(ps x | grep udp-custom | grep -v grep) ]] && udpc="\033[1;32m[ON] " || udpc="\033[1;31m[OFF]"
			if [[ ! -e /root/UDPMOD/config.json ]]; then
				hy="\033[1;31m[OFF]"

			else

				hts=$(cat /root/UDPMOD/config.json | grep 'listen' | cut -d'"' -f4 | cut -d':' -f2)
				hy="\033[1;32m$hts"
			fi
			[[ $(ps x | grep zivpn | grep -v grep) ]] && ziv="\033[1;32m[ON] " || ziv="\033[1;31m[OFF]"

			#msg -azu "	[\e[93m\e[5;100m PROTOCOLOS ABIERTOS\e[0m\e[37m]"
			msg -bar
			local_ip=$IP

			msg -verd " $local_ip:22@$1:$1"
			ADM_inst="/etc/VPS-MX/Slow/install"
			ADM_slow="/etc/VPS-MX/Slow/Key"
			if [[ ! -e ${ADM_slow}/server.pub ]]; then
				echo ""
			else
				msg -bar

				msg -ama "\e[97m	DATOS DE SU CONEXION SLOWDNS"
				msg -bar
				msg -ama "   Su NS (Nameserver): \e[92m$(cat ${ADM_slow}/domain_ns)"
				msg -ama "   Su Llave: \e[92m$(cat ${ADM_slow}/server.pub)"
			#msg -bar
			fi
		else
			msg -bar
			msg -verm2 "$(fun_trans "	Error, Usuario TOKEN no creado")"
			msg -bar

		fi

	}

	mostrar_hwid() {
		#by @rufu99
		for u in $(cat /etc/passwd | grep 'home' | grep 'false' | grep -v 'syslog' | grep -w 'hwid' | awk -F ':' '{print $1}'); do
			echo "$u"
		done
	}
	mostrar_token() {
		#by @rufu99
		for u in $(cat /etc/passwd | grep 'home' | grep 'false' | grep -v 'syslog' | grep -w 'token' | awk -F ':' '{print $1}'); do
			echo "$u"
		done
	}

	mostrar_user() {
		#by @rufu99
		for u in $(cat /etc/passwd | grep 'home' | grep 'false' | grep -v 'syslog' | grep -w 'sshm' | awk -F ':' '{print $1}'); do
			echo "$u"
		done
	}

	new_hwid() {
		#by @rufu99
		clear
		clear
		#msg -bar
		#usuarios_ativo=($(cat ${USRdatabaseh}|cut -d'|' -f1))
		usuarios_ativos=('' $(mostrar_hwid))
		if [[ -z ${usuarios_ativos[@]} ]]; then
			msg -tit
			msg -ama "   AGREGAR USUARIO HWID| Ningun Usuario Registrado\n   Para Las Aplicaciones HTTP Injector | HTTP Custom"
			msg -bar
		else
			msg -tit
			msg -ama "  AGREGAR USUARIO HWID| Usuarios  Activos en Servidor\n   Para Las Aplicaciones HTTP Injector | HTTP Custom"
			msg -bar
			for us in $(echo ${usuarios_ativos[@]}); do
				msg -ne " >> Usuario: " && echo "${us}"

			done
			msg -bar
		fi
		while true; do
			msg -ne "$(fun_trans "Ingrese El Usuario HWID")"
			read -p ": " hwid
			if [[ -z $hwid ]]; then
				err_fun 16 && continue
			elif [[ "${#hwid}" -lt "31" ]]; then
				err_fun 17 && continue
			elif [[ "${#hwid}" -gt "33" ]]; then
				err_fun 18 && continue
			elif [[ "$(echo ${usuarios_ativos[@]} | grep -w "$hwid")" ]]; then
				err_fun 14 && continue
			fi
			break
		done
		while true; do
			msg -ne "$(fun_trans "Nombre Del Usuario")"

			read -p ": " usuario
			usuario="$(echo $usuario | sed -e 's/[^a-z0-9 -]//ig')"
			if [[ -z $usuario ]]; then
				err_fun 1 && continue
			elif [[ "${#usuario}" -lt "2" ]]; then
				err_fun 2 && continue
			elif [[ "${#usuario}" -gt "10" ]]; then
				err_fun 3 && continue

			fi
			break
		done

		while true; do
			msg -ne "$(fun_trans "Tiempo de Duracion")"
			read -p ": " diasuser
			if [[ -z "$diasuser" ]]; then
				err_fun 7 && continue
			elif [[ "$diasuser" != +([0-9]) ]]; then
				err_fun 8 && continue
			elif [[ "$diasuser" -gt "360" ]]; then
				err_fun 9 && continue
			fi
			break
		done
		clear
		echo ""
		msg -bar
		add_hwid "${hwid}" "${usuario}" "${diasuser}"
		msg -bar
		msg -ne " Enter Para Continuar" && read enter
		usercodes
	}
	new_token() {
		#by @rufu99
		clear
		clear
		#msg -bar
		#usuarios_ativo=($(cat ${tokens}|cut -d'|' -f1))
		usuarios_ativos=('' $(mostrar_token))
		if [[ ! -e ${SCPdir}/.passw ]]; then
			msg -tit
			msg -ama "   AGREGAR USUARIO TOKEN| Ningun Usuario Registrado\n   Para Aplicaciones MOD"
			msg -bar
			echo -ne "\e[1;33m DIGITE SU TOKEN GENERAL:\e[31m "
			read tg
			echo "$tg" >${SCPdir}/.passw
			msg -bar
		else
			msg -tit
			msg -ama "  AGREGAR USUARIO TOKEN| Usuarios  Activos en Servidor\n   Para Aplicaciones MOD"
			msg -bar
			for us in $(echo ${usuarios_ativos[@]}); do
				msg -ne " >> Usuario: " && echo "${us}"
			done
			msg -bar
		fi

		while true; do
			msg -ne "$(fun_trans "Ingrese El Usuario TOKEN")"
			read -p ": " toke
			if [[ -z $toke ]]; then
				err_fun 19 && continue
			elif [[ "${#toke}" -lt "9" ]]; then
				err_fun 20 && continue
			elif [[ "${#toke}" -gt "21" ]]; then
				err_fun 21 && continue
			elif [[ "$(echo ${usuarios_ativos[@]} | grep -w "$toke")" ]]; then
				err_fun 14 && continue
			fi
			break
		done
		while true; do
			msg -ne "$(fun_trans "Nombre Del Cliente")"

			read -p ": " usuario
			usuario="$(echo $usuario | sed -e 's/[^a-z0-9 -]//ig')"
			if [[ -z $usuario ]]; then
				err_fun 1 && continue
			elif [[ "${#usuario}" -lt "3" ]]; then
				err_fun 2 && continue
			elif [[ "${#usuario}" -gt "10" ]]; then
				err_fun 3 && continue

			fi
			break
		done

		while true; do
			msg -ne "$(fun_trans "Tiempo de Duracion")"
			read -p ": " diasuser
			if [[ -z "$diasuser" ]]; then
				err_fun 7 && continue
			elif [[ "$diasuser" != +([0-9]) ]]; then
				err_fun 8 && continue
			elif [[ "$diasuser" -gt "360" ]]; then
				err_fun 9 && continue
			fi
			break
		done
		clear
		echo ""
		msg -bar
		add_token "${toke}" "${usuario}" "${diasuser}"

		msg -bar
		msg -ne " Enter Para Continuar" && read enter
		usercodes
	}

	renew_user_fun() {
		#nome dias
		datexp=$(date "+%F" -d " + $2 days") && valid=$(date '+%C%y-%m-%d' -d " + $2 days")
		if chage -E $valid $1 2>/dev/null || return 1; then
			userpas=$(cat /etc/VPS-MX/passw/$1)
			useredit=$(cat ${USRdatabase} | grep -w "$1")

			limit=$(echo $useredit | cut -d' ' -f3)
			echo "$limit" >/etc/limitev
			sed -i "/$1/d" ${USRdatabase}
			limite=$(cat /etc/limitev)
			echo "$userpas" >/etc/VPS-MX/passw/$1
			echo "$1 ${datexp} $limite" >>${USRdatabase}
			msg -verd "Usuario Renovado Con Exito"

		else
			msg -verm2 "Error, Usuario no Renovado"
			msg -bar
		fi
		echo ""
	}
	renovar_hwid() {
		#nome dias
		datexp=$(date "+%F" -d " + $2 days") && valid=$(date '+%C%y-%m-%d' -d " + $2 days")
		if chage -E $valid $1 2>/dev/null || return 1; then
			newbase=$(cat ${USRdatabaseh} | grep -w -v "$1")
			useredit=$(cat ${USRdatabaseh} | grep -w "$1")
			nombre=$(echo $useredit | cut -d' ' -f2)
			echo "$nombre" >/etc/limitev #guardar nombre del cliente
			sed -i "/$1/d" ${USRdatabaseh}
			contra=$(cat /etc/limitev | cut -d' ' -f1)
			echo "$1 $contra ${datexp}" >>${USRdatabaseh}
			msg -verd "Usuario Renovado Con Exito"

		else
			msg -verm2 "Error, Usuario no Renovado"
			msg -bar
		fi
		echo ""
	}
	renovar_token() {
		#nome dias
		datexp=$(date "+%F" -d " + $2 days") && valid=$(date '+%C%y-%m-%d' -d " + $2 days")
		if chage -E $valid $1 2>/dev/null || return 1; then
			newbase=$(cat ${tokens} | grep -w -v "$1")
			useredit=$(cat ${tokens} | grep -w "$1")
			pass=$(echo ${useredit} | cut -d' ' f2)
			echo "$pass" >/etc/limitev #guardar nombre del cliente
			sed -i "/$1/d" /etc/VPS-MX/User-TOKEN
			cliente=$(cat /etc/limitev | cut -d' ' -f1)
			echo "$1 $cliente ${datexp}" >>/etc/VPS-MX/User-TOKEN
			msg -verd "Usuario Renovado Con Exito"

		else
			msg -verm2 "Error, Usuario no Renovado"
			msg -bar
		fi
		echo ""

	}
	[[ ! -d /usr/local/lib/sped ]] && exit
	edit_user_fun() {
		#nome senha dias limite
		datexp=$(date "+%F" -d " + $3 days") && valid=$(date '+%C%y-%m-%d' -d " + $3 days")
		clear
		msg -bar
		pass=$(perl -e 'print crypt($ARGV[0], "password")' $2)
		if usermod -p $pass -e $valid -c sshm,$3 $1; then

			newbase=$(cat /etc/VPS-MX/VPS-MXuser | grep -w -v "$1")
			echo "$2" >/etc/VPS-MX/passw/$1
			sed -i "/$1/d" ${USRdatabase}
			echo "$1 ${datexp} $4" >>${USRdatabase}

			msg -verd "Usuario Modificado Con Exito"
			rm -rf ${SCPusr}/Limiter.log
		else
			msg -verm2 "Error, Usuario no Modificado"
			msg -bar
		fi
		echo ""
	}
	rm_user() { #usuario ssh
		#nome
		userdel --force "$1" &>/dev/null || return 1
		sed -i "/$1/d" ${USRdatabase}
		rm /etc/VPS-MX/passw/$1 &>/dev/null

		sed -i "/$1/d" /etc/userssh
	}
	rm_hwid() { #hwid
		#nome
		userdel --force "$1" &>/dev/null || return 1
		sed -i "/$1/d" ${USRdatabaseh}
		rm /etc/VPS-MX/passw/$1 &>/dev/null

		sed -i "/$1/d" /etc/userhwid
	}
	rm_token() { # token
		#nome
		userdel --force "$1" &>/dev/null || return 1
		sed -i "/$1/d" ${tokens}

		sed -i "/$1/d" /etc/usertoken
	}
	mostrar_usuarios() {
		for u in $(cat /etc/passwd | grep 'home' | grep 'false' | grep -v 'syslog' | awk -F ':' '{print $1}'); do
			echo "$u"
		done
	}
	#export mostrar_usuarios
	dropbear_pids() {
		local pids

		local portasVAR=$(lsof -V -i tcp -P -n | grep -v "ESTABLISHED" | grep -v "COMMAND" | grep "LISTEN")
		local NOREPEAT
		local reQ
		local Port
		while read port; do
			reQ=$(echo ${port} | awk '{print $1}')
			Port=$(echo {$port} | awk '{print $9}' | awk -F ":" '{print $2}')
			[[ $(echo -e $NOREPEAT | grep -w "$Port") ]] && continue
			NOREPEAT+="$Port\n"
			case ${reQ} in

			dropbear)
				[[ -z $DPB ]] && local DPB=""
				DPB+="$Port "
				;;

			esac
		done <<<"${portasVAR}"

		[[ ! -z $DPB ]] && echo -e $DPB

		local port_dropbear="$DPB"
		#cat /var/log/auth.log|grep "$(date|cut -d' ' -f2,3)" > /var/log/authday.log
		cat /var/log/auth.log | tail -1000 >/var/log/authday.log
		local log=/var/log/authday.log
		local loginsukses='Password auth succeeded'
		[[ -z $port_dropbear ]] && return 1
		for port in $(echo $port_dropbear); do
			for pidx in $(ps ax | grep dropbear | grep "$port" | awk -F" " '{print $1}'); do
				pids="${pids}$pidx\n"
			done
		done
		for pid in $(echo -e "$pids"); do
			pidlogs=$(grep $pid $log | grep "$loginsukses" | awk -F" " '{print $3}')
			i=0
			for pidend in $pidlogs; do
				let i++
			done
			if [[ $pidend ]]; then
				login=$(grep $pid $log | grep "$pidend" | grep "$loginsukses")
				PID=$pid
				user=$(echo $login | awk -F" " '{print $10}' | sed -r "s/'//g")
				waktu=$(echo $login | awk -F" " '{print $2"-"$1,$3}')
				[[ -z $user ]] && continue
				echo "$user|$PID|$waktu"
			fi
		done
	}

	openvpn_pids() {
		#nome|#loguin|#rcv|#snd|#time
		byte() {
			while read B dummy; do
				[[ "$B" -lt 1024 ]] && echo "${B} bytes" && break
				KB=$(((B + 512) / 1024))
				[[ "$KB" -lt 1024 ]] && echo "${KB} Kb" && break
				MB=$(((KB + 512) / 1024))
				[[ "$MB" -lt 1024 ]] && echo "${MB} Mb" && break
				GB=$(((MB + 512) / 1024))
				[[ "$GB" -lt 1024 ]] && echo "${GB} Gb" && break
				echo $(((GB + 512) / 1024)) terabytes
			done
		}
		for user in $(mostrar_usuarios); do
			user="$(echo $user | sed -e 's/[^a-z0-9 -]//ig')"
			[[ ! $(sed -n "/^${user},/p" /etc/openvpn/openvpn-status.log) ]] && continue
			i=0
			unset RECIVED
			unset SEND
			unset HOUR
			while read line; do
				IDLOCAL=$(echo ${line} | cut -d',' -f2)
				RECIVED+="$(echo ${line} | cut -d',' -f3)+"
				SEND+="$(echo ${line} | cut -d',' -f4)+"
				DATESEC=$(date +%s --date="$(echo ${line} | cut -d',' -f5 | cut -d' ' -f1,2,3,4)")
				TIMEON="$(($(date +%s) - ${DATESEC}))"
				MIN=$(($TIMEON / 60)) && SEC=$(($TIMEON - $MIN * 60)) && HOR=$(($MIN / 60)) && MIN=$(($MIN - $HOR * 60))
				HOUR+="${HOR}h:${MIN}m:${SEC}s\n"
				let i++
			done <<<"$(sed -n "/^${user},/p" /etc/openvpn/openvpn-status.log)"
			RECIVED=$(echo $(echo ${RECIVED}0 | bc) | byte)
			SEND=$(echo $(echo ${SEND}0 | bc) | byte)
			HOUR=$(echo -e $HOUR | sort -n | tail -1)
			echo -e "$user|$i|$RECIVED|$SEND|$HOUR"
		done
	}

	err_fun() {
		case $1 in
		1)
			msg -verm "$(fun_trans "Usuario Nulo")"
			sleep 2s
			tput cuu1
			tput dl1
			tput cuu1
			tput dl1
			;;
		2)
			msg -verm "$(fun_trans "Usuario con nombre muy corto")"
			sleep 2s
			tput cuu1
			tput dl1
			tput cuu1
			tput dl1
			;;
		3)
			msg -verm "$(fun_trans "Usuario con nombre muy grande")"
			sleep 2s
			tput cuu1
			tput dl1
			tput cuu1
			tput dl1
			;;
		4)
			msg -verm "$(fun_trans "Contraseña Nula")"
			sleep 2s
			tput cuu1
			tput dl1
			tput cuu1
			tput dl1
			;;
		5)
			msg -verm "$(fun_trans "Contraseña muy corta")"
			sleep 2s
			tput cuu1
			tput dl1
			tput cuu1
			tput dl1
			;;
		6)
			msg -verm "$(fun_trans "Contraseña muy grande")"
			sleep 2s
			tput cuu1
			tput dl1
			tput cuu1
			tput dl1
			;;
		7)
			msg -verm "$(fun_trans "Duracion Nula")"
			sleep 2s
			tput cuu1
			tput dl1
			tput cuu1
			tput dl1
			;;
		8)
			msg -verm "$(fun_trans "Duracion invalida utilize numeros")"
			sleep 2s
			tput cuu1
			tput dl1
			tput cuu1
			tput dl1
			;;
		9)
			msg -verm "$(fun_trans "Duracion maxima y de un año")"
			sleep 2s
			tput cuu1
			tput dl1
			tput cuu1
			tput dl1
			;;
		11)
			msg -verm "$(fun_trans "Limite Nulo")"
			sleep 2s
			tput cuu1
			tput dl1
			tput cuu1
			tput dl1
			;;
		12)
			msg -verm "$(fun_trans "Limite invalido utilize numeros")"
			sleep 2s
			tput cuu1
			tput dl1
			tput cuu1
			tput dl1
			;;
		13)
			msg -verm "$(fun_trans "Limite maximo de 999")"
			sleep 2s
			tput cuu1
			tput dl1
			tput cuu1
			tput dl1
			;;
		14)
			msg -verm "$(fun_trans "Usuario Ya Existe")"
			sleep 2s
			tput cuu1
			tput dl1
			tput cuu1
			tput dl1
			;;
		15)
			msg -verm "$(fun_trans "USER Y PASS Ya Existe,ejemplo De como usar: User:lacasa1 Pass:lacasa1")"
			sleep 3s
			tput cuu1
			tput dl1
			tput cuu1
			tput dl1
			;;
		16)
			msg -verm "$(fun_trans "HWID Nula")"
			sleep 2s
			tput cuu1
			tput dl1
			tput cuu1
			tput dl1
			;;
		17)
			msg -verm "$(fun_trans "HWID muy corta")"
			sleep 2s
			tput cuu1
			tput dl1
			tput cuu1
			tput dl1
			;;
		18)
			msg -verm "$(fun_trans "HWID muy grande")"
			sleep 2s
			tput cuu1
			tput dl1
			tput cuu1
			tput dl1
			;;
		19)
			msg -verm "$(fun_trans "TOKEN Nula")"
			sleep 2s
			tput cuu1
			tput dl1
			tput cuu1
			tput dl1
			;;
		20)
			msg -verm "$(fun_trans "TOKEN muy corta")"
			sleep 2s
			tput cuu1
			tput dl1
			tput cuu1
			tput dl1
			;;
		21)
			msg -verm "$(fun_trans "TOKEN muy grande")"
			sleep 2s
			tput cuu1
			tput dl1
			tput cuu1
			tput dl1
			;;
		esac
	}
	new_user() {
		clear
		clear
		#msg -bar
		usuarios_ativos=('' $(mostrar_user))
		usuarios_pass=$(cat ${USRdatabase} | cut -d'|' -f2)
		if [[ -z ${usuarios_ativos[@]} ]]; then
			msg -tit
			msg -ama "   AGREGAR USUARIO | Ningun Usuario Registrado"
			msg -bar
		else
			msg -tit
			msg -ama "  AGREGAR USUARIO | Usuarios  Activos en Servidor"
			msg -bar
			for us in $(echo ${usuarios_ativos[@]}); do
				msg -ne "  >> Usuario: " && echo "${us}"
			done
			msg -bar
		fi
		while true; do
			msg -ne "$(fun_trans "Nombre Del Nuevo Usuario")"
			read -p ": " nomeuser
			nomeuser="$(echo $nomeuser | sed -e 's/[^a-z0-9 -]//ig')"
			if [[ -z $nomeuser ]]; then
				err_fun 1 && continue
			elif [[ "${#nomeuser}" -lt "3" ]]; then
				err_fun 2 && continue
			elif [[ "${#nomeuser}" -gt "10" ]]; then
				err_fun 3 && continue
			elif [[ "$(echo ${usuarios_ativos[@]} | grep -w "$nomeuser")" ]]; then
				err_fun 14 && continue
			fi
			break
		done
		while true; do
			msg -ne "$(fun_trans "Contraseña Del Nuevo Usuario")"
			read -p ": " senhauser
			if [[ -z $senhauser ]]; then
				err_fun 4 && continue
			elif [[ "${#senhauser}" -lt "3" ]]; then
				err_fun 5 && continue
			elif [[ "${#senhauser}" -gt "10" ]]; then
				err_fun 6 && continue
				#   elif [[ "$(echo ${usuarios_pass[@]}|grep -w "$senhauser")" ]]; then
				#   err_fun 15 && continue
			fi
			break
		done
		while true; do
			msg -ne "$(fun_trans "Tiempo de Duracion del Nuevo Usuario")"
			read -p ": " diasuser
			if [[ -z "$diasuser" ]]; then
				err_fun 7 && continue
			elif [[ "$diasuser" != +([0-9]) ]]; then
				err_fun 8 && continue
			elif [[ "$diasuser" -gt "360" ]]; then
				err_fun 9 && continue
			fi
			break
		done
		while true; do
			msg -ne "$(fun_trans "Limite de Conexiones del Nuevo Usuario")"
			read -p ": " limiteuser
			if [[ -z "$limiteuser" ]]; then
				err_fun 11 && continue
			elif [[ "$limiteuser" != +([0-9]) ]]; then
				err_fun 12 && continue
			elif [[ "$limiteuser" -gt "999" ]]; then
				err_fun 13 && continue
			fi
			break
		done
		echo ""
		clear

		add_user "${nomeuser}" "${senhauser}" "${diasuser}" "${limiteuser}" #&& msg -ama "$(fun_trans "            Usuario Creado con Exito")" || msg -verm "$(fun_trans "         Error, Usuario no creado")"

		msg -bar
		msg -ne " Enter Para Continuar" && read enter
		usercodes
	}

	menu_crearuser() {
		clear
		#msg -bar
		msg -tit
		msg -ama " \e[1;33m[1] \e[37mCREAR CUENTA NORMAL \e[0m \n \e[1;33m[2] \e[37mCREAR CUENTA HWID \e[0m\n \e[1;33m[3] \e[37mCREAR CUENTA TOKEN \e[0m\n \e[1;31m[0] \e[1;37m<- VOLVER"
		msg -bar
		read -p " $(echo -e "\e[1;37mSeleccione Una Opcion [1/3]:\e[1;33m") " cuen
		case $cuen in
		1) new_user ;;
		2) new_hwid ;;
		3) new_token ;;
		0) usercodes ;;
		esac

	}

	remove_user() {
		clear
		clear
		msg -bar
		#usuarios_ativos=($(mostrar_usuarios))
		usuarios_ativos=('' $(mostrar_user))
		if [[ -z ${usuarios_ativos[@]} ]]; then
			msg -verm "$(fun_trans "Ningun usuario registrado")"
			msg -bar
			return 1
		else
			msg -ama "$(fun_trans "	Usuarios SSH Activos")"
			msg -bar
			dat_us=$(printf '%-17s%-7s' 'USUARIO' 'CONTRASEÑA')
			msg -azu "  \e[1;97m\e[1;100m$dat_us"
			msg -bar
			i=1
			for us in $(echo ${usuarios_ativos[@]}); do
				if [[ -e "/etc/VPS-MX/passw/$us" ]]; then
					pass=$(cat /etc/VPS-MX/passw/$us)
				else
					pass="Null"
				fi
				#[[ -z $(cat ${USRdatabase}|grep -w "${us}") ]] && pass="" || pass="$(cat ${USRdatabase}|grep -w "${us}"|cut -d'|' -f2)"
				user=$(printf '%-17s' "${us}")
				pas=$(printf '%-7s' "$pass")
				msg -ne "[$i] " && echo -e "\033[1;37m${user}\e[92m$pas"
				let i++
			done
			msg -bar
		fi
		msg -bra "$(fun_trans " [0] VOLVER")"
		msg -ama "$(fun_trans "Escriba o Seleccione un Usuario")"
		msg -ama "\033[1;31mSe recomienda desbloquear todas las cuentas \nbloqueadas antes de borrar algun usuario."
		msg -bar
		unset selection
		while [[ -z ${selection} ]]; do
			echo -ne "\033[1;37m$(fun_trans "Seleccione Una Opcion"): " && read selection
			tput cuu1 && tput dl1
		done
		if [[ ! $(echo "${selection}" | egrep '[^0-9]') ]]; then
			usuario_del="${usuarios_ativos[$selection]}"
		else
			usuario_del="$selection"
		fi
		[[ -z $usuario_del ]] && {
			msg -verm "$(fun_trans "Error, Usuario Invalido")"
			msg -bar
			return 1
		}
		[[ ! $(echo ${usuarios_ativos[@]} | grep -w "$usuario_del") ]] && {
			msg -verm "$(fun_trans "Error, Usuario Invalido")"
			msg -bar
			return 1
		}

		msg -ama "$(fun_trans "Usuario Seleccionado"):\e[31m $usuario_del"
		pkill -u $usuario_del
		droplim=$(droppids | grep -w "$usuario_del" | awk '{print $2}')
		kill -9 $droplim &>/dev/null
		rm_user "$usuario_del"
		rm -rf /etc/VPS-MX/VPS-MX-userlock
		rm -rf /etc/VPS-MX/controlador/Limiter.log
		unlockall2 &>/dev/null
		msg -bar
		msg -ne " Enter Para Continuar" && read enter
		usercodes
	}

	lll="/usr/local/megat" && [[ ! -d ${lll} ]] && exit

	remove_hwid() {
		clear
		clear
		red=$(tput setaf 1)
		gren=$(tput setaf 2)
		yellow=$(tput setaf 3)
		msg -bar
		usuarios_ativos=('' $(mostrar_hwid))
		if [[ -z ${usuarios_ativos[@]} ]]; then
			msg -verm "$(fun_trans "Ningun usuario HWID")"
			msg -bar
			return 1
		else
			msg -ama "$(fun_trans "	Usuarios HWID Activos")"
			msg -bar
			dat_us=$(printf '%-33s%-7s' 'USUARIO' 'NOMBRE')
			msg -azu "  \e[1;97m\e[1;100m$dat_us"
			msg -bar
			i=1
			for us in $(echo ${usuarios_ativos[@]}); do

				[[ -z $(cat ${USRdatabaseh} | grep -w "${us}") ]] && nombre="" || nombre="$(cat ${USRdatabaseh} | grep -w "${us}" | cut -d' ' -f2)"
				user=$(printf '%-33s' "${us}")
				pas=$(printf '%-7s' "$nombre")
				msg -ne "[$i] " && echo -e "\033[1;37m${user}\e[92m$pas"
				let i++
			done
			msg -bar
		fi
		msg -bra "$(fun_trans " [0] VOLVER")"
		msg -ama "$(fun_trans "Escriba o Seleccione un Usuario")"
		msg -ama "\033[1;31mSe recomienda desbloquear todas las cuentas \nbloqueadas antes de borrar algun usuario."
		msg -bar
		unset selection
		while [[ -z ${selection} ]]; do
			echo -ne "\033[1;37m$(fun_trans "Seleccione Una Opcion"): " && read selection
			tput cuu1 && tput dl1
		done
		if [[ ! $(echo "${selection}" | egrep '[^0-9]') ]]; then
			usuario_del="${usuarios_ativos[$selection]}"
		else
			usuario_del="$selection"
		fi
		[[ -z $usuario_del ]] && {
			msg -verm "$(fun_trans "Error, Usuario Invalido")"
			msg -bar
			return 1
		}
		[[ ! $(echo ${usuarios_ativos[@]} | grep -w "$usuario_del") ]] && {
			msg -verm "$(fun_trans "Error, Usuario Invalido")"
			msg -bar
			return 1
		}

		msg -ama "$(fun_trans "Usuario Seleccionado"):\e[31m $usuario_del"
		pkill -u $usuario_del
		droplim=$(droppids | grep -w "$usuario_del" | awk '{print $2}')
		kill -9 $droplim &>/dev/null
		rm_hwid "$usuario_del"
		msg -bar
		msg -ne " Enter Para Continuar" && read enter
		usercodes
	}
	remove_token() {
		clear
		clear
		red=$(tput setaf 1)
		gren=$(tput setaf 2)
		yellow=$(tput setaf 3)
		msg -bar
		usuarios_ativos=('' $(mostrar_token))
		if [[ -z ${usuarios_ativos[@]} ]]; then
			msg -verm "$(fun_trans "Ningun usuario TOKEN")"
			msg -bar
			return 1
		else
			msg -ama "$(fun_trans "	Usuarios TOKEN Activos")"
			msg -bar
			dat_us=$(printf '%-18s%-7s' 'USUARIO' 'NOMBRE')
			msg -azu "  \e[1;97m\e[1;100m$dat_us"
			msg -bar
			i=1
			for us in $(echo ${usuarios_ativos[@]}); do
				[[ -z $(cat ${tokens} | grep -w "${us}") ]] && nombre="" || nombre="$(cat ${tokens} | grep -w "${us}" | cut -d' ' -f2)"
				user=$(printf '%-17s' "${us}")
				pas=$(printf '%-7s' "$nombre")
				msg -ne "[$i] " && echo -e "\033[1;37m${user}\e[92m$pas"
				let i++
			done
			msg -bar
		fi
		msg -bra "$(fun_trans " [0] VOLVER")"
		msg -ama "$(fun_trans "Escriba o Seleccione un Usuario")"
		msg -ama "\033[1;31mSe recomienda desbloquear todas las cuentas \nbloqueadas antes de borrar algun usuario."
		msg -bar
		unset selection
		while [[ -z ${selection} ]]; do
			echo -ne "\033[1;37m$(fun_trans "Seleccione Una Opcion"): " && read selection
			tput cuu1 && tput dl1
		done
		if [[ ! $(echo "${selection}" | egrep '[^0-9]') ]]; then
			usuario_del="${usuarios_ativos[$selection]}"
		else
			usuario_del="$selection"
		fi
		[[ -z $usuario_del ]] && {
			msg -verm "$(fun_trans "Error, Usuario Invalido")"
			msg -bar
			return 1
		}
		[[ ! $(echo ${usuarios_ativos[@]} | grep -w "$usuario_del") ]] && {
			msg -verm "$(fun_trans "Error, Usuario Invalido")"
			msg -bar
			return 1
		}

		msg -ama "$(fun_trans "Usuario Seleccionado"):\e[31m $usuario_del"
		pkill -u $usuario_del
		droplim=$(droppids | grep -w "$usuario_del" | awk '{print $2}')
		kill -9 $droplim &>/dev/null
		rm_token "$usuario_del"
		msg -bar
		msg -ne " Enter Para Continuar" && read enter
		usercodes
	}

	menudel() {
		clear
		#msg -bar
		msg -tit
		msg -ama " \e[1;33m[1] \e[1;37mREMOVER CUENTAS SSH  \n \e[1;33m[2] \e[1;37mREMOVER CUENTAS HWID\n \e[1;33m[3] \e[1;37mREMOVER CUENTAS TOKEN\n \e[1;31m[0] \e[1;37m<- VOLVER"
		msg -bar
		read -p " $(echo -e "\e[1;37mSeleccione Una Opcion [1/3]:\e[1;33m") " cuen
		case $cuen in
		1) remove_user ;;
		2) remove_hwid ;;
		3) remove_token ;;
		0) usercodes ;;
		esac
	}

	renew_user() {
		clear
		clear
		#msg -bar
		usuarios_ativos=('' $(mostrar_user))
		if [[ -z ${usuarios_ativos[@]} ]]; then
			msg -tit
			msg -verm "$(fun_trans " RENOVAR USUARIO SSH| Ningun usuario registrado")"
			msg -bar
			return 1
		else
			msg -tit
			msg -ama "$(fun_trans " RENOVAR USUARIO SSH| Usuarios Activos en el Servidor")"
			msg -bar
			i=1
			for us in $(echo ${usuarios_ativos[@]}); do
				msg -ne "[$i] ->" && echo -e "\033[1;33m ${us}"
				let i++
			done
			msg -bar
		fi
		msg -ama "$(fun_trans "Escriba o seleccione un Usuario")"
		msg -bar
		unset selection
		while [[ -z ${selection} ]]; do
			echo -ne "\033[1;37m$(fun_trans "Seleccione una Opcion"): " && read selection
			tput cuu1
			tput dl1
		done
		if [[ ! $(echo "${selection}" | egrep '[^0-9]') ]]; then
			useredit="${usuarios_ativos[$selection]}"
		else
			useredit="$selection"
		fi
		[[ -z $useredit ]] && {
			msg -verm "$(fun_trans "Error, Usuario Invalido")"
			msg -bar
			return 1
		}
		[[ ! $(echo ${usuarios_ativos[@]} | grep -w "$useredit") ]] && {
			msg -verm "$(fun_trans "Error, Usuario Invalido")"
			msg -bar
			return 1
		}
		while true; do
			msg -ne "Nuevo Tiempo de Duracion de:\033[1;37m $useredit\e[33m"
			read -p ": " diasuser
			if [[ -z "$diasuser" ]]; then
				echo -e '\n\n\n'
				err_fun 7 && continue
			elif [[ "$diasuser" != +([0-9]) ]]; then
				echo -e '\n\n\n'
				err_fun 8 && continue
			elif [[ "$diasuser" -gt "360" ]]; then
				echo -e '\n\n\n'
				err_fun 9 && continue
			fi
			break
		done
		msg -bar
		renew_user_fun "${useredit}" "${diasuser}" #&& msg -ama "$(fun_trans "Usuario Modificado Con Exito")" || msg -verm "$(fun_trans "Error, Usuario no Modificado")"
		msg -bar
		msg -ne " Enter Para Continuar" && read enter
		usercodes
	}
	renew_hwid() {
		clear
		clear
		#msg -bar
		usuarios_ativos=('' $(mostrar_hwid))
		if [[ -z ${usuarios_ativos[@]} ]]; then
			msg -tit
			msg -verm "$(fun_trans " RENOVAR USUARIO HWID | Ningun usuario registrado")"
			msg -bar
			return 1
		else
			msg -tit
			msg -ama "$(fun_trans " RENOVAR USUARIO HWID | Usuarios Activos en el Servidor")"
			msg -bar
			i=1
			for us in $(echo ${usuarios_ativos[@]}); do
				pass=$(cat "/etc/passwd" | grep -w "$us" | awk -F ':' '{print $5}' | cut -d ',' -f2)
				[[ "${#pass}" -gt '11' ]] && pass="????"

				pass="$(printf '%-3s' "$pass")"

				cliente="$(msg -verd "$i")$(msg -verm2 ">")$(msg -azu "${us}")"
				nombre="\e[1;55m${pass}"
				echo -e "$cliente $nombre"
				#msg -ne "[$i] ->" && echo -e "\033[1;33m ${us}"
				let i++
			done
			msg -bar
		fi
		msg -ama "$(fun_trans "Escriba o seleccione un Usuario")"
		msg -bar
		unset selection
		while [[ -z ${selection} ]]; do
			echo -ne "\033[1;37m$(fun_trans "Seleccione una Opcion"): " && read selection
			tput cuu1
			tput dl1
		done
		if [[ ! $(echo "${selection}" | egrep '[^0-9]') ]]; then
			useredit="${usuarios_ativos[$selection]}"
		else
			useredit="$selection"
		fi
		[[ -z $useredit ]] && {
			msg -verm "$(fun_trans "Error, Usuario Invalido")"
			msg -bar
			return 1
		}
		[[ ! $(echo ${usuarios_ativos[@]} | grep -w "$useredit") ]] && {
			msg -verm "$(fun_trans "Error, Usuario Invalido")"
			msg -bar
			return 1
		}
		while true; do
			msg -ne "Nuevo Tiempo de Duracion de:\033[1;37m $useredit\e[33m"
			read -p ": " diasuser
			if [[ -z "$diasuser" ]]; then
				echo -e '\n\n\n'
				err_fun 7 && continue
			elif [[ "$diasuser" != +([0-9]) ]]; then
				echo -e '\n\n\n'
				err_fun 8 && continue
			elif [[ "$diasuser" -gt "360" ]]; then
				echo -e '\n\n\n'
				err_fun 9 && continue
			fi
			break
		done
		msg -bar
		renovar_hwid "${useredit}" "${diasuser}"
		msg -bar
		msg -ne " Enter Para Continuar" && read enter
		usercodes
	}
	renew_token() {
		clear
		clear
		#msg -bar
		usuarios_ativos=('' $(mostrar_token))
		if [[ -z ${usuarios_ativos[@]} ]]; then
			msg -tit
			msg -verm "$(fun_trans " RENOVAR USUARIO TOKEN| Ningun usuario registrado")"
			msg -bar
			return 1
		else
			msg -tit
			msg -ama "$(fun_trans " REMOVAR USUARIO TOKEN | Usuarios Activos en el Servidor")"
			msg -bar
			i=1
			for us in $(echo ${usuarios_ativos[@]}); do
				pass=$(cat "/etc/passwd" | grep -w "$us" | awk -F ':' '{print $5}' | cut -d ',' -f2)
				[[ "${#pass}" -gt '11' ]] && pass="????"
				pass="$(printf '%-3s' "$pass")"

				cliente="$(msg -verd "$i")$(msg -verm2 ">")$(msg -azu "${us}")"
				nombre="\e[1;55m${pass}"
				echo -e "$cliente $nombre"
				#msg -ne "[$i] ->" && echo -e "\033[1;33m ${us}"
				let i++
			done
			msg -bar
		fi
		msg -ama "$(fun_trans "Escriba o seleccione un Usuario")"
		msg -bar
		unset selection
		while [[ -z ${selection} ]]; do
			echo -ne "\033[1;37m$(fun_trans "Seleccione una Opcion"): " && read selection
			tput cuu1
			tput dl1
		done
		if [[ ! $(echo "${selection}" | egrep '[^0-9]') ]]; then
			useredit="${usuarios_ativos[$selection]}"
		else
			useredit="$selection"
		fi
		[[ -z $useredit ]] && {
			msg -verm "$(fun_trans "Error, Usuario Invalido")"
			msg -bar
			return 1
		}
		[[ ! $(echo ${usuarios_ativos[@]} | grep -w "$useredit") ]] && {
			msg -verm "$(fun_trans "Error, Usuario Invalido")"
			msg -bar
			return 1
		}
		while true; do
			msg -ne "Nuevo Tiempo de Duracion de:\033[1;37m $useredit\e[33m"
			read -p ": " diasuser
			if [[ -z "$diasuser" ]]; then
				echo -e '\n\n\n'
				err_fun 7 && continue
			elif [[ "$diasuser" != +([0-9]) ]]; then
				echo -e '\n\n\n'
				err_fun 8 && continue
			elif [[ "$diasuser" -gt "360" ]]; then
				echo -e '\n\n\n'
				err_fun 9 && continue
			fi
			break
		done
		msg -bar
		renovar_token "${useredit}" "${diasuser}"
		msg -bar
		msg -ne " Enter Para Continuar" && read enter
		usercodes
	}
	menu_renova() {
		clear
		#msg -bar
		msg -tit
		msg -ama " \e[1;33m[1] \e[1;37mRENOVAR CUENTAS SSH  \n \e[1;33m[2] \e[1;37mRENOVAR CUENTAS HWID\n \e[1;33m[3] \e[1;37mRENOVAR CUENTAS TOKEN\n \e[1;31m[0] \e[1;37m<- VOLVER"
		msg -bar
		read -p " $(echo -e "\e[1;37mSeleccione Una Opcion [1/3]:\e[1;33m") " cuen
		case $cuen in
		1) renew_user ;;
		2) renew_hwid ;;
		3) renew_token ;;
		0) usercodes ;;
		esac
	}
	[[ ! -d /usr/local/libreria ]] && exit
	edit_user() {
		clear
		clear
		#msg -bar
		usuarios_ativos=('' $(mostrar_user))
		if [[ -z ${usuarios_ativos[@]} ]]; then
			msg -tit
			msg -verm "$(fun_trans " EDITTAR USER | Ningun usuario registrado")"
			msg -bar
			return 1
		else
			msg -tit
			msg -ama "$(fun_trans " EDITTAR USER | Usuarios Activos del Servidor")"
			msg -bar
			i=1
			for us in $(echo ${usuarios_ativos[@]}); do
				msg -ne "[$i] ->" && echo -e "\033[1;33m ${us}"
				let i++
			done
			msg -bar
		fi
		msg -ama "$(fun_trans "Escriba o seleccione un Usuario")"
		msg -bar
		unset selection
		while [[ -z ${selection} ]]; do
			echo -ne "\033[1;37m$(fun_trans "Seleccione una Opcion"): " && read selection
			tput cuu1
			tput dl1
		done
		if [[ ! $(echo "${selection}" | egrep '[^0-9]') ]]; then
			useredit="${usuarios_ativos[$selection]}"
		else
			useredit="$selection"
		fi
		[[ -z $useredit ]] && {
			msg -verm "$(fun_trans "Error, Usuario Invalido")"
			msg -bar
			return 1
		}
		[[ ! $(echo ${usuarios_ativos[@]} | grep -w "$useredit") ]] && {
			msg -verm "$(fun_trans "Error, Usuario Invalido")"
			msg -bar
			return 1
		}
		while true; do
			msg -ne "$(fun_trans "Usuario Seleccionado"): " && echo -e "$useredit"
			msg -ne "Nueva Contraseña de:\033[1;33m $useredit"
			read -p ": " senhauser
			if [[ -z "$senhauser" ]]; then
				err_fun 4 && continue
			elif [[ "${#senhauser}" -lt "3" ]]; then
				err_fun 5 && continue
			elif [[ "${#senhauser}" -gt "10" ]]; then
				err_fun 6 && continue
			fi
			break
		done
		while true; do
			msg -ne "Dias de Duracion de:\033[1;33m $useredit"
			read -p ": " diasuser
			if [[ -z "$diasuser" ]]; then
				err_fun 7 && continue
			elif [[ "$diasuser" != +([0-9]) ]]; then
				err_fun 8 && continue
			elif [[ "$diasuser" -gt "360" ]]; then
				err_fun 9 && continue
			fi
			break
		done
		while true; do
			msg -ne "Nuevo Limite de Conexion de:\033[1;33m $useredit"
			read -p ": " limiteuser
			if [[ -z "$limiteuser" ]]; then
				err_fun 11 && continue
			elif [[ "$limiteuser" != +([0-9]) ]]; then
				err_fun 12 && continue
			elif [[ "$limiteuser" -gt "999" ]]; then
				err_fun 13 && continue
			fi
			break
		done
		echo ""
		msg -bar
		edit_user_fun "${useredit}" "${senhauser}" "${diasuser}" "${limiteuser}" #&& msg -ama "$(fun_trans "Usuario Modificado Con Exito")" && rm -rf ${SCPusr}/Limiter.log || msg -verm "$(fun_trans "Error, Usuario nao Modificado")"
		msg -ne "$(fun_trans " >> Usuario"): " && echo -e "$useredit"
		msg -ne "$(fun_trans " >> Contraseña"): " && echo -e "$senhauser"
		msg -ne "$(fun_trans " >> Dias de Duracion"): " && echo -e "$diasuser"
		msg -ne "$(fun_trans " >> Fecha de Expiracion"): " && echo -e "$(date "+%F" -d " + $diasuser days")"
		msg -ne "$(fun_trans " >> Limite de Conexion"): " && echo -e "$limiteuser"
		msg -bar

		msg -ne " Enter Para Continuar" && read enter
		usercodes
	}
	data_hwid() {
		clear
		#msg -bar
		msg -tit
		msg -ama "$(fun_trans "        INFORMACION DE USUARIOS HWID REGISTRADOS ")"
		msg -bar
		cat_users=$(cat "/etc/passwd" | grep 'home' | grep 'hwid' | grep -v 'syslog')

		dat_us=$(printf '%-30s%-7s%-6s%s' 'CLIENTE' 'NONBRE' 'DIAS' 'STATUS')
		msg -azu "  \e[1;97m\e[1;100m$dat_us"
		msg -bar

		i=1
		for u in $(echo "${cat_users}" | awk -F ':' '{print $1}'); do

			fix_hwid_token=$(echo "${cat_users}" | grep -w "$u" | awk -F ':' '{print $5}' | cut -d ',' -f1) && [[ "${fix_hwid_token}" != @(hwid) ]] && continue

			fecha=$(chage -l "$u" | sed -n '4p' | awk -F ': ' '{print $2}')

			mes_dia=$(echo $fecha | awk -F ',' '{print $1}' | sed 's/ //g')
			ano=$(echo $fecha | awk -F ', ' '{printf $2}' | cut -c 3-)
			us=$(printf '%-1s' "$u")

			pass=$(cat "/etc/passwd" | grep -w "$u" | awk -F ':' '{print $5}' | cut -d ',' -f2)
			[[ "${#pass}" -gt '12' ]] && pass="????"
			pass="$(printf '%-3s' "$pass")"

			unset stat
			if [[ $(passwd --status $u | cut -d ' ' -f2) = "P" ]]; then
				stat="$(msg -verd "📡 ")"
			else
				stat="$(msg -verm2 "📵 ")"
			fi

			cliente="$(msg -verd "$i")$(msg -verm2 ">")$(msg -azu "${u}")"
			if [[ $(echo $fecha | awk '{print $2}') = "" ]]; then
				exp="$(printf '%-2s' '[XX]')"
				#exp+="$(printf '%-2s' '[X]')"
				#vig="$(msg -verm2 "$fecha")$(msg -verm2 "$exp") $(echo -e "$stat")"
				vig="$(msg -verm2 "$exp")   $(echo -e "$stat")"
			else
				if [[ $(date +%s) -gt $(date '+%s' -d "${fecha}") ]]; then
					exp="$(printf '%-2s' "Exp")"
					#echo " $(msg -verm2 "$fecha")$(msg -verd "$exp") $(echo -e "$stat")"
					echo " $(msg -verm2 "$exp")   $(echo -e "$stat")"
				else
					EXPTIME="$(($(($(date '+%s' -d "${fecha}") - $(date +%s))) / 86400))"
					if [[ "${#EXPTIME}" = "1" ]]; then
						exp="$(printf '%-2s' "[$EXPTIME]")"
					elif [[ "${#EXPTIME}" = "2" ]]; then
						exp="$(printf '%-2s' "[$EXPTIME]")"
					else
						exp="$(printf '%-2s' "[$EXPTIME]")"
					fi
					#vig="$(msg -verm2 "$mes_dia/$ano")$(msg -verd "$exp")$(echo -e "$stat")"
					vig=" $(msg -verd "$exp")   $(echo -e "$stat")"
				fi
			fi
			nombre="\e[1;55m${pass}"
			echo -e "$cliente $nombre $vig"
			msg -bar3
			let i++
		done
		#  tput cuu1 && tput dl1
		msg -bar

	}
	data_token() {
		clear
		#msg -bar
		msg -tit
		msg -ama "$(fun_trans "        INFORMACION DE USUARIOS TOKEN REGISTRADOS ")"
		msg -bar
		cat_users=$(cat "/etc/passwd" | grep 'home' | grep 'token' | grep -v 'syslog')

		dat_us=$(printf '%-16s%-11s%-7s%-6s%s' 'CLIENTE' 'NOMBRE' 'FECHA' 'DIAS' 'STATUS')
		msg -ama "    \e[1;97m\e[1;100m$dat_us"
		msg -bar

		i=1
		for u in $(echo "${cat_users}" | awk -F ':' '{print $1}'); do

			fix_hwid_token=$(echo "${cat_users}" | grep -w "$u" | awk -F ':' '{print $5}' | cut -d ',' -f1) && [[ "${fix_hwid_token}" != @(token) ]] && continue

			echo -e "  \e[1;93mContraseña General: \e[1;94m$(cat /etc/VPS-MX/.passwd)\e[0m"
			msg -bar
			fecha=$(chage -l "$u" | sed -n '4p' | awk -F ': ' '{print $2}')

			mes_dia=$(echo $fecha | awk -F ',' '{print $1}' | sed 's/ //g')
			ano=$(echo $fecha | awk -F ', ' '{printf $2}' | cut -c 3-)
			us=$(printf '%-3s' "$u")

			user=$(cat "/etc/passwd" | grep -w "$u" | awk -F ':' '{print $5}' | cut -d ',' -f2)
			[[ "${#user}" -gt '12' ]] && user="????"
			user="$(printf '%-9s' "$user")"

			unset stat
			if [[ $(passwd --status $u | cut -d ' ' -f2) = "P" ]]; then
				stat="$(msg -verd "📡 ")"
			else
				stat="$(msg -verm2 "📵 ")"
			fi

			cliente="$(msg -verd "$i")$(msg -verm2 "-")$(msg -ama " ${u}")"
			if [[ $(echo $fecha | awk '{print $2}') = "" ]]; then
				exp="$(printf '%-6s' '[X]')"
				#exp+="$(printf '%-4s' '[X]')"
				vig=" $(msg -verm2 "$fecha")$(msg -verm2 "$exp")  $(echo -e "$stat")"
			else
				if [[ $(date +%s) -gt $(date '+%s' -d "${fecha}") ]]; then
					exp="$(printf '%-6s' "Exp")"
					vig="$(msg -verm2 "$mes_dia/$ano")$(msg -verm2 "$exp")  $(echo -e "$stat")"
				else
					EXPTIME="$(($(($(date '+%s' -d "${fecha}") - $(date +%s))) / 86400))"
					if [[ "${#EXPTIME}" = "1" ]]; then
						exp="$(printf '%-6s' " [$EXPTIME]")"
					elif [[ "${#EXPTIME}" = "2" ]]; then
						exp="$(printf '%-6s' " [$EXPTIME]")"
					else
						exp="$(printf '%-6s' " [$EXPTIME]")"
					fi
					vig="$(msg -verm2 "$mes_dia/$ano")$(msg -verd "$exp")  $(echo -e "$stat")"
				fi
			fi

			nombre="$(msg -verd "${user}")"
			echo -e "$cliente $nombre $vig"
			msg -bar3
			let i++
		done
		#  tput cuu1 && tput dl1
		msg -bar

	}
	data_user() {
		clear
		#msg -bar
		msg -tit
		msg -ama "$(fun_trans "        INFORMACION DE USUARIOS SSH REGISTRADOS ")"
		msg -bar2
		cat_users=$(cat "/etc/passwd" | grep 'home' | grep 'false' | grep -v 'syslog')
		#dat_us=$(printf '%-11s%-13s%-15s%-4s%-6s%s' 'Usuario' 'Contraseña' ' Fecha' 'Dia' 'Limit' 'Status')
		dat_us=" Usuario  Contraseña    Fecha  Dia  Limit Status"
		msg -ama "  \e[1;97m\e[1;100m$dat_us"
		msg -bar

		i=1
		for u in $(echo "${cat_users}" | awk -F ':' '{print $1}'); do

			fix_hwid_token=$(echo "${cat_users}" | grep -w "$u" | awk -F ':' '{print $5}' | cut -d ',' -f1) && [[ "${fix_hwid_token}" = @(hwid|token) ]] && continue

			fecha=$(chage -l "$u" | sed -n '4p' | awk -F ': ' '{print $2}')
			#fecha=$(cat ${USRdatabase}|grep -w "$u"|cut -d'|' -f3)
			mes_dia=$(echo $fecha | awk -F ',' '{print $1}' | sed 's/ //g')
			ano=$(echo $fecha | awk -F ', ' '{printf $2}' | cut -c 3-)
			us=$(printf '%-9s' "$u")
			if [[ -e "/etc/VPS-MX/passw/$u" ]]; then
				pass=$(cat /etc/VPS-MX/passw/$u)
			else
				pass="Null"
			fi
			#pass=$(cat /etc/VPS-MX/VPS-MXuser|grep -w "$u"|cut -d'|' -f2)
			#pass=$(cat "/etc/passwd"|grep -w "$u"|awk -F ':' '{print $5}'|cut -d ',' -f2)
			#[[ "${#pass}" -gt '12' ]] && pass="duplicada"
			pass="$(printf '%-10s' "$pass")"

			unset stat
			if [[ $(passwd --status $u | cut -d ' ' -f2) = "P" ]]; then
				stat="$(msg -verd "📡 ")"
			else
				stat="$(msg -verm2 "📵 ")"
			fi

			Limit=$(cat /etc/VPS-MX/VPS-MXuser | grep -w "$u" | cut -d' ' -f3)
			#Limit=$(cat "/etc/passwd"|grep -w "alex"|awk -F ':' '{print $5}'|cut -d ',' -f2)
			[[ "${#Limit}" = "1" ]] && Limit=$(printf '%3s' "$Limit") || Limit=$(printf '%-3s' "$Limit")

			echo -ne "$(msg -verd "$i")$(msg -verm2 ">")$(msg -azu "${us}") $(msg -azu "${pass}")"
			if [[ $(echo $fecha | awk '{print $2}') = "" ]]; then
				#exp="$(printf '%8s%-2s' '[X]')"
				exp="$(printf '%-5s' '[X]')"
				echo " $(msg -verm2 "$fecha")$(msg -verd "$exp")    $(echo -e "$stat")"
			else
				if [[ $(date +%s) -gt $(date '+%s' -d "${fecha}") ]]; then
					exp="$(printf '%-5s' "Exp")"
					echo " $(msg -verm2 "$mes_dia/$ano")  $(msg -verm2 "$exp")$(msg -ama "$Limit")    $(echo -e "$stat")"
				else
					EXPTIME="$(($(($(date '+%s' -d "${fecha}") - $(date +%s))) / 86400))"
					[[ "${#EXPTIME}" = "1" ]] && exp="$(printf '%-5s' "$EXPTIME")" || exp="$(printf '%-5s' "$EXPTIME")"
					echo " $(msg -verm2 "$mes_dia/$ano")  $(msg -verd "$exp")$(msg -ama "$Limit")    $(echo -e "$stat")"
				fi
			fi

			let i++
		done
		msg -bar

	}
	menudata() {
		clear
		#msg -bar
		msg -tit
		msg -ama " \e[1;33m[1] \e[37mDETALLES DE CUENTAS SSH \e[0m\n \e[1;33m[2] \e[37mDETALLES DE CUENTAS HWID \e[0m\n \e[1;33m[3] \e[37mDETALLES DE CUENTAS TOKEN \e[0m\n \e[1;31m[0] \e[1;37m<- VOLVER"
		msg -bar
		read -p " $(echo -e "\e[1;37mSeleccione Una Opcion [1/3]:\e[1;33m") " cuen
		case $cuen in
		1)
			data_user && msg -ne " Enter Para Continuar" && read enter
			usercodes
			;;
		2)
			data_hwid && msg -ne " Enter Para Continuar" && read enter
			usercodes
			;;
		3)
			data_token && msg -ne " Enter Para Continuar" && read enter
			usercodes
			;;
		0) usercodes ;;
		esac
	}

	fun_drop() {
		port_dropbear=$(ps aux | grep dropbear | awk NR==1 | awk '{print $17;}')
		log=/var/log/auth.log
		loginsukses='Password auth succeeded'
		clear
		pids=$(ps ax | grep dropbear | grep " $port_dropbear" | awk -F" " '{print $1}')
		for pid in $pids; do
			pidlogs=$(grep $pid $log | grep "$loginsukses" | awk -F" " '{print $3}')
			i=0
			for pidend in $pidlogs; do
				let i=i+1
			done
			if [ $pidend ]; then
				login=$(grep $pid $log | grep "$pidend" | grep "$loginsukses")
				PID=$pid
				user=$(echo $login | awk -F" " '{print $10}' | sed -r "s/'/ /g")
				waktu=$(echo $login | awk -F" " '{print $2"-"$1,$3}')
				while [ ${#waktu} -lt 13 ]; do
					waktu=$waktu" "
				done
				while [ ${#user} -lt 16 ]; do
					user=$user" "
				done
				while [ ${#PID} -lt 8 ]; do
					PID=$PID" "
				done
				echo "$user $PID $waktu"
			fi
		done
	}

	menumoni() {
		clear
		#msg -bar
		msg -tit
		msg -ama " \e[1;33m[1] \e[37mMONITOR DE CUENTAS SSH\e[0m\n \e[1;33m[2] \e[37mMONITOR DE CUENTAS HWID\e[0m\n \e[1;33m[3] \e[37mMONITOR DE CUENTAS TOKEN\e[0m\n \e[1;31m[0] \e[1;37m<- VOLVER"
		msg -bar
		read -p " $(echo -e "\e[1;37mSeleccione Una Opcion [1/3]:\e[1;33m") " cuen
		case $cuen in
		1) monit_ssh ;;
		2) monit_hwid ;;
		3) monit_token ;;
		0) usercodes ;;
		esac
	}

	ts_get_sec() {
		read -r h m s <<<$(echo $1 | tr ':' ' ')
		[[ $h = @(08|09) ]] && h=$(echo ${s:1})
		[[ $m = @(08|09) ]] && m=$(echo ${s:1})
		[[ $s = @(08|09) ]] && s=$(echo ${s:1})
		echo $(((h * 60 * 60) + (m * 60) + s))
	}
	export numero='^[0-9]+$'
	export letra='^[A-Za-z]+$'
	export tx_num='^[A-Za-z0-9]+$'

	ts_get_con() {
		declare -A conect
		mesdia=$(date | cut -d' ' -f2,3)
		if [[ $(echo ${mesdia:0:2}) =~ $numero ]]; then
			mes=$(echo "$mesdia" | cut -d ' ' -f2)
			dia=$(echo "$mesdia" | cut -d ' ' -f1)
			mesdia="$mes $dia"
		fi
		cat /var/log/auth.log | grep "$mesdia" >/var/log/authday.log
		logins="$(cat /var/log/authday.log | grep -v root | grep 'dropbear\|sshd' | grep -w 'Password auth succeeded\|Accepted password for')"
		[[ -z ${logins} ]] && return
		while read line; do
			if [[ $(echo "$line" | grep -w 'dropbear') ]]; then
				data=$(echo "$line" | cut -d ' ' -f3,5,10 | sed "s/]:\|'//g" | sed 's/\[/ /g')
			elif [[ $(echo "$line" | grep 'sshd') ]]; then
				data=$(echo "$line" | cut -d ' ' -f3,5,9 | sed 's/]://g' | sed 's/\[/ /g')
			fi
			pid=$(echo "$data" | cut -d ' ' -f3)
			timeOut=$(cat /var/log/authday.log | grep "$pid" | grep 'Exit\|closed' | cut -d ' ' -f3)
			[[ -z ${timeOut} ]] && timeOut='open'
			start_ts="$(echo "$data" | cut -d ' ' -f1)"
			if [[ "${timeOut}" = 'open' ]]; then
				stop_ts="$(printf '%(%H:%M:%S)T')"
			else
				stop_ts="${timeOut}"
			fi
			START=$(ts_get_sec $start_ts)
			STOP=$(ts_get_sec $stop_ts)

			if [[ $START -gt $STOP ]]; then
				DIFF=$((START - STOP))
			else
				DIFF=$((STOP - START))
			fi
			h="$((DIFF / 60 / 60))" && [[ "${#h}" = 1 ]] && h="0$h"
			m="$((DIFF / 60 % 60))" && [[ "${#m}" = 1 ]] && m="0$m"
			s="$((DIFF % 60))" && [[ "${#s}" = 1 ]] && s="0$s"
			tiempo="$h:$m:$s"
			name=$(echo "$data" | cut -d ' ' -f4)
			conect["${name}"]="${data} ${timeOut} ${tiempo}"
		done <<<$(echo "${logins}")
		printf "%s\n" "${conect[@]}"
	}

	monit_ssh() {
		clear
		[[ $(dpkg --get-selections | grep -w "net-tools" | head -1) ]] || apt-get install net-tools -y &>/dev/null
		cab=$(printf '%-15s%-13s%-15s%-7s' 'USUARIO' 'STATUS' 'CONEXIONES' 'TIEMPO')
		msg -bar
		echo -e "\E[91m \e[43m $cab\E[0m"
		msg -bar
		#  msg -ama "Analizando usuarios..."
		# ts_conect_user=$(ts_get_con)
		tput cuu1 && tput dl1
		cat_users=$(cat "/etc/passwd" | grep 'home' | grep 'sshm' | grep -v 'syslog')
		for i in $(echo "$cat_users" | awk -F ':' '{print $1}'); do
			user="$i"
			#    [[ -z $(cat ${USRdatabase}|grep -w "${i}"|cut -d'|' -f4) ]] && s2ssh="" || s2ssh="$(cat ${USRdatabase}|grep -w "${i}"|cut -d'|' -f4)"
			s2ssh="$(echo "$(cat ${USRdatabase} | grep -w "${i}" | cut -d' ' -f3)")"

			if [[ "$(echo "$cat_users" | grep -w $i | wc -l)" = "1" ]]; then
				sqd="$(ps -u $user | grep sshd | wc -l)"
			else
				sqd=00
			fi

			[[ "$sqd" = "" ]] && sqd=0
			if [[ -e /etc/openvpn/openvpn-status.log ]]; then
				ovp="$(cat /etc/openvpn/openvpn-status.log | grep -E ,"$i", | wc -l)"
			else
				ovp=0
			fi

			if netstat -nltp | grep -w 'dropbear' >/dev/null 2>&1; then
				drop="$(dropbear_pids | grep -w "$i" | wc -l)"
			else
				drop=0
			fi
			cnx=$(($sqd + $drop))
			conex=$(($cnx + $ovp))
			if [[ $cnx -gt 0 ]]; then
				tst="$(ps -o etime $(ps -u $user | grep sshd | awk 'NR==1 {print $1}') | awk 'NR==2 {print $1}')"
				tst1=$(echo "$tst" | wc -c)
				if [[ "$tst1" == "9" ]]; then
					timerr="$(ps -o etime $(ps -u $user | grep sshd | awk 'NR==1 {print $1}') | awk 'NR==2 {print $1}')"
				else
					timerr="$(echo "00:$tst")"
				fi

			elif [[ $ovp -gt 0 ]]; then
				tmp2=$(printf '%(%H:%M:%S)T\n')
				tmp1="$(grep -w "$i" /etc/openvpn/openvpn-status.log | awk '{print $4}' | head -1)"
				[[ "$tmp1" = "" ]] && tmp1="00:00:00" && tmp2="00:00:00"
				var1=$(echo $tmp1 | cut -c 1-2)
				var2=$(echo $tmp1 | cut -c 4-5)
				var3=$(echo $tmp1 | cut -c 7-8)
				var4=$(echo $tmp2 | cut -c 1-2)
				var5=$(echo $tmp2 | cut -c 4-5)
				var6=$(echo $tmp2 | cut -c 7-8)
				calc1=$(echo $var1*3600 + $var2*60 + $var3 | bc)
				calc2=$(echo $var4*3600 + $var5*60 + $var6 | bc)
				seg=$(($calc2 - $calc1))
				min=$(($seg / 60))
				seg=$(($seg - $min * 60))
				hor=$(($min / 60))
				min=$(($min - $hor * 60))
				timerusr=$(printf "%02d:%02d:%02d \n" $hor $min $seg)
				timerr=$(echo "$timerusr" | sed -e 's/[^0-9:]//ig')
			else
				timerr="00:00:00"
			fi

			user=$(printf '%-16s' "$i")
			con=$(printf '%-11s' "$conex/$s2ssh")
			#msg -bar
			if [[ $conex -eq 0 ]]; then
				status=$(printf '%-16s' '[OFF]')
				#  echo ""
				# echo -e " \e[1;97m$user$(msg -verm2 "$status")$(msg -verd "$con")$(msg -ama "$timerr")"
			else
				status=$(printf '%-16s' '[ON]')

				echo -e " \e[1;97m$user$(msg -verd "$status")$(msg -verd "$con")$(msg -ama "$timerr")"
				msg -bar
			fi
			#  msg -bar
		done
		#  tput cuu1 #&& tput dl1
		#msg -bar

	}
	monit_hwid() {
		clear
		[[ $(dpkg --get-selections | grep -w "net-tools" | head -1) ]] || apt-get install net-tools -y &>/dev/null
		cab=$(printf '%-15s%-13s%-15s%-7s' '-HWID- ' 'STATUS' 'CONEXIONES' 'TIEMPO')
		msg -bar
		echo -e "\E[91m \e[43m $cab\E[0m"
		msg -bar
		#  msg -ama "Analizando usuarios..."
		#  ts_conect_user=$(ts_get_con)
		tput cuu1 && tput dl1
		cat_users=$(cat "/etc/passwd" | grep 'home' | grep 'hwid' | grep -v 'syslog')

		for i in $(echo "$cat_users" | awk -F ':' '{print $1}'); do
			user="$i"

			if [[ "$(echo "$cat_users" | grep -w $i | wc -l)" = "1" ]]; then
				sqd="$(ps -u $user | grep sshd | wc -l)"
			else
				sqd=00
			fi

			[[ "$sqd" = "" ]] && sqd=0
			if [[ -e /etc/openvpn/openvpn-status.log ]]; then
				ovp="$(cat /etc/openvpn/openvpn-status.log | grep -E ,"$i", | wc -l)"
			else
				ovp=0
			fi

			if netstat -nltp | grep -w 'dropbear' >/dev/null 2>&1; then
				drop="$(dropbear_pids | grep -w "$i" | wc -l)"

			#  [[ $(dpkg --get-selections|grep -w "dropbear"|head -1) ]] && drop="$(fun_drop|grep -w "${i}"|wc -l)"

			else
				drop=0
			fi
			cnx=$(($sqd + $drop))
			conex=$(($cnx + $ovp))
			if [[ $cnx -gt 0 ]]; then
				tst="$(ps -o etime $(ps -u $user | grep sshd | awk 'NR==1 {print $1}') | awk 'NR==2 {print $1}')"
				tst1=$(echo "$tst" | wc -c)
				if [[ "$tst1" == "9" ]]; then
					timerr="$(ps -o etime $(ps -u $user | grep sshd | awk 'NR==1 {print $1}') | awk 'NR==2 {print $1}')"
				else
					timerr="$(echo "00:$tst")"
				fi

			elif [[ $ovp -gt 0 ]]; then
				tmp2=$(printf '%(%H:%M:%S)T\n')
				tmp1="$(grep -w "$i" /etc/openvpn/openvpn-status.log | awk '{print $4}' | head -1)"
				[[ "$tmp1" = "" ]] && tmp1="00:00:00" && tmp2="00:00:00"
				var1=$(echo $tmp1 | cut -c 1-2)
				var2=$(echo $tmp1 | cut -c 4-5)
				var3=$(echo $tmp1 | cut -c 7-8)
				var4=$(echo $tmp2 | cut -c 1-2)
				var5=$(echo $tmp2 | cut -c 4-5)
				var6=$(echo $tmp2 | cut -c 7-8)
				calc1=$(echo $var1*3600 + $var2*60 + $var3 | bc)
				calc2=$(echo $var4*3600 + $var5*60 + $var6 | bc)
				seg=$(($calc2 - $calc1))
				min=$(($seg / 60))
				seg=$(($seg - $min * 60))
				hor=$(($min / 60))
				min=$(($min - $hor * 60))
				timerusr=$(printf "%02d:%02d:%02d \n" $hor $min $seg)
				timerr=$(echo "$timerusr" | sed -e 's/[^0-9:]//ig')
			else
				timerr="00:00:00"
			fi

			hwid=$(printf '%-32s' "$i")
			con=$(printf '%-3s' "$conex")

			if [[ $conex -eq 0 ]]; then
				status=$(printf '%-3s' '[OFF]')
				#   msg -bar
				echo -e " \e[1;97m$hwid$(msg -verm2 "$status")$(msg -verd "$con")$(msg -ama "$timerr")"
			else
				status=$(printf '%-3s' '[ON]')
				#    msg -bar
				echo -e " \e[1;97m$hwid$(msg -verd "$status")$(msg -verd "$con")$(msg -ama "$timerr")"
			fi
			msg -bar
		done
		tput cuu1 && tput dl1
		msg -bar

	}
	monit_token() {
		clear
		[[ $(dpkg --get-selections | grep -w "net-tools" | head -1) ]] || apt-get install net-tools -y &>/dev/null
		cab=$(printf '%-15s%-13s%-15s%-7s' '-TOKEN-' 'STATUS' 'CONEXIONES' 'TIEMPO')
		msg -bar
		echo -e "\E[91m \e[43m $cab\E[0m"
		msg -bar
		msg -ama "Analizando usuarios..."
		#  ts_conect_user=$(ts_get_con)
		tput cuu1 && tput dl1
		cat_users=$(cat "/etc/passwd" | grep 'home' | grep 'token' | grep -v 'syslog')

		for i in $(echo "$cat_users" | awk -F ':' '{print $1}'); do
			user="$i"

			if [[ "$(echo "$cat_users" | grep -w $i | wc -l)" = "1" ]]; then
				sqd="$(ps -u $user | grep sshd | wc -l)"
			else
				sqd=00
			fi

			[[ "$sqd" = "" ]] && sqd=0
			if [[ -e /etc/openvpn/openvpn-status.log ]]; then
				ovp="$(cat /etc/openvpn/openvpn-status.log | grep -E ,"$i", | wc -l)"

			else
				ovp=0
			fi

			if netstat -nltp | grep -w 'dropbear' >/dev/null 2>&1; then
				drop="$(dropbear_pids | grep -w "$i" | wc -l)"

			#  [[ $(dpkg --get-selections|grep -w "dropbear"|head -1) ]] && drop="$(fun_drop|grep -w "${i}"|wc -l)"

			else
				drop=0
			fi
			cnx=$(($sqd + $drop))
			conex=$(($cnx + $ovp))
			if [[ $cnx -gt 0 ]]; then
				tst="$(ps -o etime $(ps -u $user | grep sshd | awk 'NR==1 {print $1}') | awk 'NR==2 {print $1}')"
				tst1=$(echo "$tst" | wc -c)
				if [[ "$tst1" == "9" ]]; then
					timerr="$(ps -o etime $(ps -u $user | grep sshd | awk 'NR==1 {print $1}') | awk 'NR==2 {print $1}')"
				else
					timerr="$(echo "00:$tst")"
				fi

			elif [[ $ovp -gt 0 ]]; then
				tmp2=$(printf '%(%H:%M:%S)T\n')
				tmp1="$(grep -w "$i" /etc/openvpn/openvpn-status.log | awk '{print $4}' | head -1)"
				[[ "$tmp1" = "" ]] && tmp1="00:00:00" && tmp2="00:00:00"
				var1=$(echo $tmp1 | cut -c 1-2)
				var2=$(echo $tmp1 | cut -c 4-5)
				var3=$(echo $tmp1 | cut -c 7-8)
				var4=$(echo $tmp2 | cut -c 1-2)
				var5=$(echo $tmp2 | cut -c 4-5)
				var6=$(echo $tmp2 | cut -c 7-8)
				calc1=$(echo $var1*3600 + $var2*60 + $var3 | bc)
				calc2=$(echo $var4*3600 + $var5*60 + $var6 | bc)
				seg=$(($calc2 - $calc1))
				min=$(($seg / 60))
				seg=$(($seg - $min * 60))
				hor=$(($min / 60))
				min=$(($min - $hor * 60))
				timerusr=$(printf "%02d:%02d:%02d \n" $hor $min $seg)
				timerr=$(echo "$timerusr" | sed -e 's/[^0-9:]//ig')
			else
				timerr="00:00:00"
			fi

			token=$(printf '%-16s' "$i")
			con=$(printf '%-8s' "$conex")
			[[ -z $(cat ${tokens} | grep -w "${i}") ]] && nombre="" || nombre="$(cat ${tokens} | grep -w "${i}" | cut -d'|' -f2)"
			nom=$(printf '%-4s' "$nombre")

			if [[ $conex -eq 0 ]]; then
				status=$(printf '%-10s' '[OFF]')
				# msg -bar
				# echo ""
				echo -e " \e[1;97m$token$nom $(msg -verm2 "$status")$(msg -verd "$con")$(msg -ama "\e[93m$timerr")"
			else
				status=$(printf '%-10s' '[ON]')
				#   msg -bar
				echo -e " \e[1;97m$token$nom $(msg -verd "$status")$(msg -verd "$con")$(msg -ama "\e[93m$timerr")"
			fi
			msg -bar
		done
		tput cuu1 && tput dl1
		msg -bar

	}

	rm_vencidos() {
		clear
		clear
		#msg -bar
		msg -tit
		echo -e "$(fun_trans "\e[93m           BORRANDO USUARIOS VENCIDOS ")"
		msg -bar
		red=$(tput setaf 1)
		gren=$(tput setaf 2)
		yellow=$(tput setaf 3)
		txtvar=$(printf '%-25s' " USUARIO")
		txtvar+=$(printf '%-25s' " VALIDIDEZ")
		echo -e "\033[1;92m${txtvar}"
		msg -bar
		expired="${red}$(fun_trans "Usuario Expirado")"
		valid="${gren}$(fun_trans "   Usuario Vigente")"
		never="${yellow}$(fun_trans "Usuario Ilimitado")"
		removido="${red}$(fun_trans "Eliminado")"
		DataVPS=$(date +%s)
		while read user; do
			DataUser=$(chage -l "${user}" | grep -i co | awk -F ":" '{print $2}')
			usr=$user
			while [[ ${#usr} -lt 20 ]]; do
				usr=$usr" "
			done
			[[ "$DataUser" = " never" ]] && {
				echo -e "${yellow}$usr $never"
				continue
			}
			DataSEC=$(date +%s --date="$DataUser")
			if [[ "$DataSEC" -lt "$DataVPS" ]]; then
				echo -ne "${yellow}$usr $expired"
				rm_user "$user" && echo -e "($removido)"
			else
				echo -e "${yellow}$usr $valid"
			fi
		done <<<"$(mostrar_usuarios)"
		rm -rf /etc/VPS-MX/VPS-MX-userlock
		rm -rf /etc/VPS-MX/controlador/Limiter.log
		unlockall2
		msg -bar
		msg -ne " Enter Para Continuar" && read enter
		usercodes
	}

	SPR &
	backup_ssh() {
		clear
		clear
		#msg -bar
		msg -tit
		msg -ama "$(fun_trans "        BACKUP DE USUARIOS SSH")"
		msg -bar
		menu_func "CREAR BACKUP" "RESTAURAR BACKUP" "DESCARGAR LINK BACKUP"
		msg -bar
		unset selection
		while [[ ${selection} != @([1-3]) ]]; do
			echo -ne "\033[1;37m$(fun_trans "Seleccione una Opcion"): " && read selection
			tput cuu1 && tput dl1
		done
		case ${selection} in
		1)

			cp /etc/userssh $HOME/VPS-MX-Backup
			cp /etc/userssh /var/www/html/VPS-MX-Backup
			msg -azu "$(fun_trans "Procedimiento Hecho con Exito, Guardado en:")"
			echo ""
			echo -e "\033[1;31mBACKUP > [\033[1;32m$HOME/VPS-MX-Backup\033[1;31m]"
			echo -e "\033[1;31mBACKUP LINK > [\033[1;32mhttp://$IP:81/VPS-MX-Backup\033[1;31m]"
			echo ""
			;;
		2)
			while [[ ! -e ${dirbackup} ]]; do
				echo -ne "\033[1;37m ¡¡Recomiendo DESACTIVAR Limitador si es que lo tiene ACTIVO!!\n"
				echo -ne "\033[1;37m Escriba la ubicacion de la copia de seguridad\n"
				msg -bar
				echo -ne "\033[1;37m ENTER: para ruta predeterminada /root/VPS-MX-Backup: " && read dirbackup
				echo ""
				echo "----------  RESTAURANDO CUENTAS ESPERE "
				echo ""
				msg -bar
				[[ -z "${dirbackup}" ]] && dirbackup="/root/VPS-MX-Backup"
				tput cuu1 && tput dl1
			done
			VPSsec=$(date +%s)
			while read line; do
				nome=$(echo ${line} | cut -d' ' -f1)
				[[ $(echo $(mostrar_user) | grep -w "$nome") ]] && {
					msg -verm "$nome [ERROR]"
					continue
				}
				senha=$(echo ${line} | cut -d' ' -f2)
				DateExp=$(echo ${line} | cut -d' ' -f3)
				DataSec=$(date +%s --date="$DateExp")
				[[ "$VPSsec" -lt "$DataSec" ]] && dias="$(($(($DataSec - $VPSsec)) / 86400))" || dias="NP"
				limite=$(echo ${line} | cut -d' ' -f4)

				add_user "$nome" "$senha" "$dias" "$limite" &>/dev/null && msg -verd "$nome [CUENTA VALIDA]" || msg -verm "$nome [CUENTA INVALIDA FECHA EXPIRADA]"
			done <${dirbackup}
			;;
		3)
			msg -bar
			msg -ama "	DESCARGAR LINK DE BACKUP"
			msg -bar
			msg -ne " Ingrese Su Link: "
			read link
			wget -O $HOME/VPS-MX-Backup $link &>/dev/null
			echo ""
			msg -ama " LINK DESCARGADO CON EXITO\n AHORA VUELVE A REGRESAR EN LA OPCION DE RESTAURAR BACKUP\n Opcion 11 despues opcion 2 Restaurar Backup"
			msg -bar
			;;
		esac
		echo ""
		msg -bar
		msg -ne " Enter Para Continuar" && read enter
		usercodes
	}
	backup_hwid() {
		clear
		clear
		#msg -bar
		msg -tit
		msg -ama "$(fun_trans "        BACKUP DE USUARIOS HWID")"
		msg -bar
		menu_func "CREAR BACKUP" "RESTAURAR BACKUP" "DESCARGAR LINK BACKUP"
		msg -bar
		unset selection
		while [[ ${selection} != @([1-3]) ]]; do
			echo -ne "\033[1;37m$(fun_trans "Seleccione una Opcion"): " && read selection
			tput cuu1 && tput dl1
		done
		case ${selection} in
		1)
			cp ${USRdatabaseh} $HOME/Backup-HWID
			cp ${USRdatabaseh} /var/www/html/Backup-HWID
			msg -azu "$(fun_trans "Procedimiento Hecho con Exito, Guardado en:")"
			echo ""
			echo -e "\033[1;31mBACKUP > [\033[1;32m$HOME/Backup-HWID\033[1;31m]"
			echo -e "\033[1;31mBACKUP LINK > [\033[1;32mhttp://$IP:81/Backup-HWID\033[1;31m]"
			echo ""
			;;
		2)
			while [[ ! -e ${dirbackuph} ]]; do
				echo -ne "\033[1;37m ¡¡Recomiendo DESACTIVAR Limitador si es que lo tiene ACTIVO!!\n"
				echo -ne "\033[1;37m Escriba la ubicacion de la copia de seguridad\n"
				msg -bar
				echo -ne "\033[1;37m ENTER: para ruta predeterminada /root/Backup-HWID: " && read dirbackup
				echo ""
				echo "----------  RESTAURANDO CUENTAS ESPERE "
				echo ""
				msg -bar
				[[ -z "${dirbackuph}" ]] && dirbackuph="/root/Backup-HWID"
				tput cuu1 && tput dl1
			done
			VPSsec=$(date +%s)
			while read line; do
				hwid=$(echo ${line} | cut -d' ' -f1)
				[[ $(echo $(mostrar_hwid) | grep -w "$hwid") ]] && {
					msg -verm "$hwid [ERROR]"
					continue
				}
				nombre=$(echo ${line} | cut -d' ' -f2)
				DateExp=$(echo ${line} | cut -d' ' -f3)
				DataSec=$(date +%s --date="$DateExp")
				[[ "$VPSsec" -lt "$DataSec" ]] && dias="$(($(($DataSec - $VPSsec)) / 86400))" || dias="NP"

				add_hwid "$hwid" "$nombre" "$dias" &>/dev/null && msg -verd "$hwid [CUENTA VALIDA]" || msg -verm "$hwid [CUENTA INVALIDA FECHA EXPIRADA]"
			done <${dirbackuph}
			;;
		3)
			msg -bar
			msg -ama "	DESCARGAR LINK DE BACKUP"
			msg -bar
			msg -ne " Ingrese Su Link Hwid: "
			read link
			wget -O $HOME/Backup-HWID $link &>/dev/null
			echo ""
			msg -ama " LINK DESCARGADO CON EXITO\n AHORA VUELVE A REGRESAR EN LA OPCION DE RESTAURAR BACKUP\n Opcion 11 despues opcion 2 Restaurar Backup hwid"
			msg -bar
			;;
		esac
		echo ""
		msg -bar
		msg -ne " Enter Para Continuar" && read enter
		usercodes
	}
	backup_token() {
		clear
		clear
		#msg -bar
		msg -tit
		msg -ama "$(fun_trans "        BACKUP DE USUARIOS TOKEN")"
		msg -bar
		menu_func "CREAR BACKUP" "RESTAURAR BACKUP" "DESCARGAR LINK BACKUP"
		msg -bar
		unset selection
		while [[ ${selection} != @([1-3]) ]]; do
			echo -ne "\033[1;37m$(fun_trans "Seleccione una Opcion"): " && read selection
			tput cuu1 && tput dl1
		done
		case ${selection} in
		1)
			cp ${tokens} $HOME/Backup-TOKEN
			cp ${tokens} /var/www/html/Backup-TOKEN
			msg -azu "$(fun_trans "Procedimiento Hecho con Exito, Guardado en:")"
			echo ""
			echo -e "\033[1;31mBACKUP > [\033[1;32m$HOME/Backup-TOKEN\033[1;31m]"
			echo -e "\033[1;31mBACKUP LINK > [\033[1;32mhttp://$IP:81/Backup-TOKEN\033[1;31m]"
			echo ""
			;;
		2)
			while [[ ! -e ${dirbackupt} ]]; do
				echo -ne "\033[1;37m ¡¡Recomiendo DESACTIVAR Limitador si es que lo tiene ACTIVO!!\n"
				echo -ne "\033[1;37m Escriba la ubicacion de la copia de seguridad\n"
				msg -bar
				echo -ne "\033[1;37m ENTER: para ruta predeterminada /root/Backup-TOKEN: " && read dirbackup
				echo ""
				echo "----------  RESTAURANDO CUENTAS ESPERE "
				echo ""
				msg -bar
				[[ -z "${dirbackupt}" ]] && dirbackupt="/root/Backup-TOKEN"
				tput cuu1 && tput dl1
			done
			VPSsec=$(date +%s)
			while read line; do
				usuario=$(echo ${line} | cut -d' ' -f1)
				[[ $(echo $(mostrar_token) | grep -w "$usuario") ]] && {
					msg -verm "$usuario [ERROR]"
					continue
				}
				nombre=$(echo ${line} | cut -d' ' -f2)
				DateExp=$(echo ${line} | cut -d' ' -f3)
				DataSec=$(date +%s --date="$DateExp")
				[[ "$VPSsec" -lt "$DataSec" ]] && dias="$(($(($DataSec - $VPSsec)) / 86400))" || dias="NP"

				add_token "$usuario" "$nombre" "$dias" &>/dev/null && msg -verd "$usuario [CUENTA VALIDA]" || msg -verm "$usuario [CUENTA INVALIDA FECHA EXPIRADA]"
			done <${dirbackupt}
			;;
		3)
			msg -bar
			msg -ama "	DESCARGAR LINK DE BACKUP"
			msg -bar
			msg -ne " Ingrese Su Link Token: "
			read link
			wget -O $HOME/Backup-TOKEN $link &>/dev/null
			echo ""
			msg -ama " LINK DESCARGADO CON EXITO\n AHORA VUELVE A REGRESAR EN LA OPCION DE RESTAURAR BACKUP\n Opcion 11 despues opcion 2 Restaurar Backup Token"
			msg -bar
			;;
		esac
		echo ""
		msg -bar
		msg -ne " Enter Para Continuar" && read enter
		usercodes
	}

	#hacer backup de ssh/hwid/token
	menuback() {
		clear
		#msg -bar
		msg -tit
		msg -ama "	\e[37mBACKUP DE CUENTAS SSH|HWID|TOKEN\e[0m"
		msg -bar
		menu_func "CREAR BACKUP SSH" "CREAR BACKUP HWID" "CREAR BACKUP TOKEN"
		msg -bar
		unset selection
		while [[ ${selection} != @([0-3]) ]]; do
			echo -ne "\033[1;37m$(fun_trans "Seleccione una Opcion"): " && read selection
			tput cuu1 && tput dl1
		done
		case ${selection} in
		1) backup_ssh ;;
		2) backup_hwid ;;
		3) backup_token ;;
		0) usercodes ;;
		esac
	}
	baner_personalizado() {
		clear
		local="/etc/VPS-MX/bannerssh"
		msg -bar

		echo -e "\033[1;33m    Para Salir Ctrl + C o 0 Para Regresar\033[1;33m"
		echo -e " \033[1;31m[ !!! ]\033[1;33m INGRESA TU BANNER AQUI  \033[1;31m\033[1;33m"
		msg -bar

		echo -e " \033[1;31mLuego de Pegar tu banner Presiona Ctrl + x y Enter \033[1;33m \033[1;31m\033[1;33m"

		echo -ne "\033[1;33m"
		read -p " Presiona Enter para Continuar "
		apt install nano -y >/dev/null 2>&1
		touch /tmp/bannerssh
		nano /tmp/bannerssh
		cat /tmp/bannerssh >/etc/VPS-MX/bannerssh
		rm -rf /tmp/bannerssh
		#echo '<p style="text-align: center;"><span style="color: #9ffff;"><strong>'$credi'</strong></span><br /><em><span style="color: #ff0000;"><strong>By LACASITA&bull;MX</strong></span></em></p>' >> $local
		[[ -d /etc/dropbear ]] && {
			[[ -e /etc/VPS-MX/bannerssh ]] && cat /etc/VPS-MX/bannerssh >/etc/dropbear/banner
		} || men="NO EXISTE DROPBEAR"
		msg -bar
		echo -ne " \033[1;31m[ ! ] VERIFICANDO DROPBEAR"
		service dropbear restart >/dev/null 2>&1
		[[ -e /etc/init.d/dropbear ]] && {
			/etc/init.d/dropbear restart >/dev/null 2>&1 && echo -e "\033[1;32m [OK]" || {
				echo -e "\033[1;31m - BANNER INCOMPATIBLE CON DROPBEAR -"
				echo "" >/etc/dropbear/banner
				/etc/init.d/dropbear restart >/dev/null 2>&1 && echo -e "\033[1;32m [OK]"
			}
		} || echo -e "\033[1;31m [ $men ]"

		service ssh restart >/dev/null 2>&1
		service sshd restart >/dev/null 2>&1
		[[ -e /etc/init.d/ssh ]] && /etc/init.d/ssh restart >/dev/null 2>&1 && echo -e "\033[1;31m[ ! ] VERIFICANDO SSH\033[1;32m [OK]" || echo -e "\033[1;31m[ ! ] VERIFICANDO SSH\033[1;31m [FAIL]"
		sleep 0.1s

	}

	baner_fun() {
		banner_on() {
			clear
			clear
			local="/etc/VPS-MX/bannerssh"
			rm -rf $local >/dev/null 2>&1
			local2="/etc/dropbear/banner"
			chk=$(cat /etc/ssh/sshd_config | grep Banner)
			if [ "$(echo "$chk" | grep -v "#Banner" | grep Banner)" != "" ]; then
				local=$(echo "$chk" | grep -v "#Banner" | grep Banner | awk '{print $2}')
			else
				echo "" >>/etc/ssh/sshd_config
				echo "Banner /etc/VPS-MX/bannerssh" >>/etc/ssh/sshd_config
				local="/etc/VPS-MX/bannerssh"
			fi
			#msg -bar
			msg -tit
			msg -ama "         AGREGAR BANNER SSH/SSL/DROPBEAR"
			msg -bar
			msg -ne "$(fun_trans "Inserte el BANNER de preferencia en HTML sin saltos"): \n\n" && read ban_ner
			echo ""
			msg -bar
			credi="$(less /etc/VPS-MX/message.txt)"
			echo "$ban_ner" >>$local
			echo '<p style="text-align: center;"><span style="color: #9ffff;"><strong>'$credi'</strong></span><br /><em><span style="color: #ff0000;"><strong>By LACASITA&bull;MX</strong></span></em></p>' >>$local
			if [[ -e "$local2" ]]; then
				rm $local2 >/dev/null 2>&1
				cat $local >$local2
			fi
			msg -verd "$(fun_trans "           BANNER AGREGADO CON !! EXITO ¡¡")" && msg -bar
			service dropbear restart 2>/dev/null
			service ssh restart 2>/dev/null

		}

		banner_off() {
			clear
			clear
			#msg -bar
			msg -tit
			msg -ama "         ELIMINANDO  BANNER SSH/SSL/DROPBEAR"
			msg -bar
			rm -rf /etc/VPS-MX/bannerssh
			sed -i '/'Banner'/d' /etc/ssh/sshd_config
			sed -i -e 's/^[ \t]*//; s/[ \t]*$//; /^$/d' /etc/ssh/sshd_config
			echo "" >>/etc/ssh/sshd_config
			rm -rf /etc/dropbear/banner >/dev/null 2>&1
			echo "" >/etc/dropbear/banner >/dev/null 2>&1
			service dropbear stop 2>/dev/null
			service ssh restart 2>/dev/null
			service dropbear restart 2>/dev/null
			echo -e "\033[1;92m            BANNER ELIMINADO !! EXITO ¡¡ "
			msg -bar
		}
		clear
		clear
		#msg -bar
		msg -tit
		msg -ama "         AGREGAR BANNER SSH/SSL/DROPBEAR"
		msg -bar
		echo -e "${cor[1]}            Escoja la opcion deseada."
		msg -bar
		echo -e "\033[1;92m 1).- \033[1;37m AGREGAR BANNER SSH/SSL/DROPBEAR "
		echo -e "\033[1;92m 2).- \033[1;37m AGREGAR BANNER PERSONALIZADO "
		echo -e "\033[1;92m 3).- \033[1;37m ELIMINAR Y DESACTIVAR BANNER   "
		msg -bar
		echo -ne "\033[1;37mDigite solo el numero segun su respuesta: \033[1;32m"
		read opcao
		case $opcao in
		1)
			msg -bar
			banner_on
			;;
		2)
			clear
			msg -tit
			echo -e "\e[1;33m"
			echo -e " Al escojer que coloques tu Banner creado fuera del Script, no se "
			echo -e "    Responsabiliza por el Fallo de ciertos recursos del script\e[31m"

			local2="/etc/VPS-MX/bannerssh"
			chk=$(cat /etc/ssh/sshd_config | grep Banner)
			if [ "$(echo "$chk" | grep -v "#Banner" | grep Banner)" != "" ]; then
				local=$(echo "$chk" | grep -v "#Banner" | grep Banner | awk '{print $2}')
			else
				echo "Banner /etc/VPS-MX/bannerssh" >>/etc/ssh/sshd_config
				local="/etc/VPS-MX/bannerssh"
			fi
			while true; do
				echo -e "\e[1;31m ESTAS SEGURO QUE TIENES TU BANNER BIEN ESTRUCTURADO\e[1;33m "
				read -p " [ s | n ]: " si_no
				if [[ "$si_no" = @(s|S|y|Y) ]]; then
					baner_personalizado
				elif [[ "$si_no" = @(n|N) ]]; then
					return 0
				fi
			done
			;;
		3)
			msg -bar
			banner_off
			;;
		esac
		msg -ne " Enter Para Continuar" && read enter
		usercodes
	}

	rec_total() {
		clear
		clear
		#msg -bar
		msg -tit
		echo -e "\033[1;32m  REGISTRO TOTAL DE CUENTAS VIEJAS Y NUEVAS"
		msg -bar
		msg -ama "	CUENSTAS SSH"
		if [[ -e /etc/VPS-MX/VPS-MXuser ]]; then
			echo "$(cat /etc/VPS-MX/VPS-MXuser)"
		else
			msg -ama " NO HAY REGISTRO"
		fi
		msg -bar
		msg -ama "	CUENTAS HWID"
		if [[ -e /etc/VPS-MX/User-HWID ]]; then
			echo "$(cat /etc/VPS-MX/User-HWID)"
		else
			msg -ama " NO HAY REGISTRO"
		fi
		msg -bar
		msg -ama "	CUENTAS TOKEN"
		if [[ -e /etc/VPS-MX/User-TOKEN ]]; then
			echo "$(cat /etc/VPS-MX/User-TOKEN)"
		else
			msg -ama " NO HAY REGISTRO"
		fi
		msg -bar
		msg -ne " Enter Para Continuar" && read enter
		usercodes
	}

	verif_funx() {
		clear
		clear
		msg -bar
		msg -tit
		echo -e "\033[1;32m             LIMITADOR DE CUENTAS"
		msg -bar
		echo -e "Esta Opcion Limita las Conexiones de SSH/SSL/DROPBEAR"
		PIDVRF="$(ps aux | grep -v grep | grep "verif")"
		if [[ -z $PIDVRF ]]; then
			msg -bar
			echo -ne "\033[1;96m   ¿Cada cuantos segundos ejecutar el limitador?\n\033[1;97m  +Segundos = -Uso de CPU | -Segundos = +Uso de CPU\033[0;92m \n                Predeterminado:\033[1;37m 180s| 3 minutos\n     Cuantos Segundos (Numeros Unicamente): " && read tiemlim
			[[ -z "$tiemlim" ]] && tiemlim="180"
			echo "${tiemlim}" >/etc/VPS-MX/controlador/tiemlim.log
			screen -dmS verif ${SCPdir}/tmp/verifi
			[[ $(grep -wc "verif" /etc/autostart) = '0' ]] && {
				echo -e "ps x |grep 'verif' |grep -v 'grep' || screen -dmS verif ${SCPdir}/tmp/verifi" >>/etc/autostart
			} || {
				sed -i '/verif/d' /etc/autostart
				echo -e "ps x |grep 'verif' |grep -v 'grep' || screen -dmS verif ${SCPdir}/tmp/verifi" >>/etc/autostart
			}
		else

			screen -r -S "verif" -X quit
			screen -wipe 1>/dev/null 2>/dev/null
			[[ $(grep -wc "verif" /etc/autostart) != '0' ]] && {
				sed -i '/verif/d' /etc/autostart
			}

			[[ -e ${SCPdir}/USRonlines ]] && rm ${SCPdir}/USRonlines
			[[ -e ${SCPdir}/USRexpired ]] && rm ${SCPdir}/USRexpired
			[[ -e ${SCPdir}/USRbloqueados ]] && rm ${SCPdir}/USRbloqueados
		fi
		msg -bar
		[[ -z ${VERY} ]] && verificar="\033[1;32m ACTIVADO " || verificar="\033[1;31m DESACTIVADO "
		echo -e "            $verificar  --  CON EXITO"
		msg -bar
		msg -ne " Enter Para Continuar" && read enter
		usercodes
	}

	##DESBLOEUEAR

	verif2_funx() {
		clear
		clear
		msg -bar
		msg -tit
		echo -e "\033[1;32m      DESBLOQUEO AUT. Y LIMPIADOR DE EXPIARDOS"
		msg -bar
		echo -e "Esta opcion desbloquea cada 5 minutos a usuarios\nbloqueados por el limitador y limpia los usuarios expirados"
		PIDVRF2="$(ps aux | grep -v grep | grep "autode")"
		if [[ -z $PIDVRF2 ]]; then
			msg -bar
			echo -ne "\033[1;96m   ¿Cada cuantos segundos ejecutar el desbloqueador?\n\033[1;97m  +Segundos = -Uso de CPU | -Segundos = +Uso de CPU\033[0;92m \n                Predeterminado:\033[1;37m 300s\n     Cuantos Segundos (Numeros Unicamente): " && read tiemdes
			[[ -z "$tiemdes" ]] && tiemdes="300"
			echo "${tiemdes}" >/etc/VPS-MX/controlador/tiemdes.log
			#screen -dmS desbloqueo ${SCPdir}/tmp/autodes

			screen -dmS autode ${SCPdir}/tmp/autodes
			#
			[[ $(grep -wc "autodes" /etc/autostart) = '0' ]] && {
				echo -e "ps x | grep 'autode' |grep -v 'grep' || screen -dmS autode ${SCPdir}/tmp/autodes" >>/etc/autostart
			} || {
				sed -i '/autodes/d' /etc/autostart
				echo -e "ps x | grep 'autode' |grep -v 'grep' || screen -dmS autode ${SCPdir}/tmp/autodes" >>/etc/autostart
			}
		else

			screen -r -S "autode" -X quit
			screen -wipe >/dev/null
			[[ $(grep -wc "autodes" /etc/autostart) != '0' ]] && {
				sed -i '/autodes/d' /etc/autostart
			}
			sleep 1

		fi
		msg -bar
		[[ -z ${VERY2} ]] && desbloqueo="\033[1;32m ACTIVADO " || desbloqueo="\033[1;31m DESACTIVADO "
		echo -e "            $desbloqueo  --  CON EXITO"
		msg -bar
		msg -ne " Enter Para Continuar" && read enter
		usercodes
	}
	tokenpass() {
		#
		clear
		msg -bar
		msg -tit
		apass=$(cat ${SCPdir}/.passw)
		msg -ama "CONFIGURACION DE CONTRASEÑA TOKEN"
		msg -bar

		if [[ ! -z "$apass" ]]; then
			msg -azu "CONTRASEÑA ACTUAL: $apass"
			msg -bar
		fi
		while true; do
			echo -e " $(msg -verm "╭╼╼╼[")$(msg -azu "INGRESE SU CONTRASEÑA, ENTER PARA CANCELAR")$(msg -verm "]")"
			echo -ne " $(msg -verm "╰╼")\033[37;1m> " && read npass
			npass="$(echo $npass | sed 'y/áÁàÀãÃâÂéÉêÊíÍóÓõÕôÔúÚñÑçÇªº/aAaAaAaAeEeEiIoOoOoOuUnNcCao/')"
			if [[ -z $npass ]]; then
				break
			elif [[ "${#npass}" -lt "6" ]]; then
				err_fun 5 && tput cuu1 && tput dl1 && continue
			elif [[ "${#npass}" -gt "36" ]]; then
				err_fun 6 && tput cuu1 && tput dl1 && continue
			fi
			break
		done
		[[ -z "$npass" ]] && return 1
		tput cuu1 && tput dl1 && tput cuu1 && tput dl1
		printf "$npass" >${SCPdir}/.passw
		clear
		msg -bar
		echo -e " $(msg -ama "╭╼╼╼╼╼╼╼╼╼[")$(msg -azu "SE GUARDO LA NUEVA CONTRASEÑA")$(msg -ama "]")"
		echo -ne " $(msg -ama "╰╼")\033[37;1m> " && msg -azu "$npass"
		cat_users=$(cat "/etc/passwd" | grep 'home' | grep 'false' | grep -v 'syslog' | grep -v '::/' | grep -w 'token' | awk -F ':' '{print $1}')
		[[ ! -z "$cat_users" ]] && msg -bar && msg -ama " APLICAR A TODOS LOS CLIENTES [S/N]: " && read allpass
		if [[ "$allpass" = @(S|s) ]]; then
			msg -bar
			msg -ama "LA CONTRASEÑA TOKEN SERÁ APLICADO PARA TODOS"
			for u in $(echo "$cat_users"); do
				(
					echo $npass
					echo $npass
				) | passwd $u 2>/dev/null
			done
			tput cuu1 && tput dl1
			msg -verd "LA CONTRASEÑA TOKEN FUE APLICADA PARA TODOS"
		fi

	}

	veri=$(ps x | grep -v grep | grep "verif")
	[[ ! $veri ]] && verificar="\033[1;31m[DESACTIVADO]" || verificar="\033[1;32m[ACTIVADO] "
	des=$(ps x | grep -v grep | grep "autode")
	[[ ! $des ]] && desbloqueo="\033[1;31m[DESACTIVADO]" || desbloqueo="\033[1;32m[ACTIVADO] "
	msg -tit
	msg -bar
	msg -ama "  ADMINISTRADOR DE USUARIOS /SSH/HWID/TOKEN"
	msg -bar
	msg -bar3

	#menuusercodes
	echo -e " \e[1;93m[\e[92m1\e[93m] $(msg -verm2 "➛ ") $(msg -azu "CREAR NUEVO USUARIO [\e[93m\e[5;100mSSH/HWID/TOKEN \e[0m\e[37m]")"
	#
	echo -e " \e[1;93m[\e[92m2\e[93m] $(msg -verm2 "➛ ") $(msg -azu "REMOVER USUARIO [\e[93m\e[5;100mSSH/HWID/TOKEN \e[0m\e[37m]")"
	echo -e " \e[1;93m[\e[92m3\e[93m] $(msg -verm2 "➛ ") $(msg -azu "BLOQUEAR |DESBLOQUEAR USUARIO")"
	echo -e " \e[1;93m[\e[92m4\e[93m] $(msg -verm2 "➛ ") $(msg -azu "REINICIAR CONTADOR DE BLOQUEADOS |EXPIRADOS")"
	echo -e " \e[1;93m[\e[92m5\e[93m] $(msg -verm2 "➛ ") $(msg -azu "EDITAR USUARIO")"
	echo -e " \e[1;93m[\e[92m6\e[93m] $(msg -verm2 "➛ ") $(msg -azu "RENOVAR USUARIO [\e[93m\e[5;100mSSH/HWID/TOKEN \e[0m\e[37m]")"
	echo -e " \e[1;93m[\e[92m7\e[93m] $(msg -verm2 "➛ ") $(msg -azu "MOSTRAR CUENTAS [\e[93m\e[5;100mSSH/HWID/TOKEN \e[0m\e[37m]")"
	echo -e " \e[1;93m[\e[92m8\e[93m] $(msg -verm2 "➛ ") $(msg -azu "USUARIOS CONECTADOS [\e[93m\e[5;100mSSH/HWID/TOKEN \e[0m\e[37m] ")"
	echo -e " \e[1;93m[\e[92m9\e[93m] $(msg -verm2 "➛ ") $(msg -azu "ELIMINAR USUARIOS VENCIDOS")"
	echo -e " \e[1;93m[\e[92m10\e[93m] $(msg -verm2 "➛ ") $(msg -azu "BACKUP USUARIOS [\e[93m\e[5;100mSSH/HWID/TOKEN \e[0m\e[37m]")"
	echo -e " \e[1;93m[\e[92m11\e[93m] $(msg -verm2 "➛ ") $(msg -azu "AGREGAR/ELIMINAR BANNER")"
	echo -e " \e[1;93m[\e[92m12\e[93m] $(msg -verm2 "➛ ") $(msg -azu "\033[1;31m⚠️ELIMINAR TODOS LOS USUARIOS⚠️      ")"
	echo -e " \e[1;93m[\e[92m13\e[93m] $(msg -verm2 "➛ ") $(msg -azu "🔒 LIMITADOR-DE-CUENTAS 🔒   ${verificar}    ")"
	echo -e " \e[1;93m[\e[92m14\e[93m] $(msg -verm2 "➛ ") $(msg -azu "🔓 DESBLOQUEO-AUTOMATICO 🔓   ${desbloqueo}     ")"
	echo -e " \e[1;93m[\e[92m15\e[93m] $(msg -verm2 "➛ ") $(msg -azu "\033[1;92mLOG DE CUENTAS REGISTRADAS")"
	echo -e " \e[1;93m[\e[92m16\e[93m] $(msg -verm2 "➛ ") $(msg -azu "LIMPIAR LOG DE LIMITADOR")"
	[[ -e "${SCPusr}/Limiter2.log" ]] && echo -ne "$(msg -verd " [17]") $(msg -verm2 "➛ ") " && msg -azu "\033[1;91mVER LOG DE LIMITADOR"
	[[ -e "${SCPdir}/.passw" ]] && echo -ne "$(msg -verd " [18]") $(msg -verm2 "➛ ") " && msg -azu "CAMBIAR TOKEN GENERAL"
	echo -ne "$(msg -verd " [19]") $(msg -verm2 "➛ ") " && msg -azu "ELIMINAR LINKS DE OVPN"

	echo -ne ""$(msg -bar)"   \n$(msg -verd "  [0]") $(msg -verm2 "➛ ")" && msg -bra "  \e[97m\033[1;41m VOLVER \033[1;37m"
	msg -bar
	selection=$(selection_fun 19)
	case ${selection} in
	1) menu_crearuser ;;
	2) menudel ;;
	3) block_user ;;
	4) reset_contador ;;
	5) edit_user ;;
	6) menu_renova ;;
	7) menudata ;;
	8) menumoni ;;
	9) rm_vencidos ;;
	10) menuback ;;
	11) baner_fun ;;
	12) eliminar_all ;;
	13) verif_funx ;;  #/etc/VPS-MX/tmp/verifi ;;
	14) verif2_funx ;; #/etc/VPS-MX/tmp/autodes;;
	15) rec_total ;;
	16)
		rm -rf ${SCPusr}/Limiter2.log
		echo -e "\033[1;32m  LOG ELIMINADO CON EXITO"
		msg -bar
		msg -ne " Enter Para Continuar" && read enter
		usercodes
		;;
	17)
		clear
		clear
		msg -bar
		sed -i -e 's/^[ \t]*//; s/[ \t]*$//; /^$/d' /etc/VPS-MX/controlador/Limiter2.log
		[[ -e "${SCPusr}/Limiter2.log" ]] && {
			msg -tit
			msg -ama "              REGISTRO DEL LIMITADOR "
			cat ${SCPusr}/Limiter2.log
			msg -bar
		}
		msg -ne " Enter Para Continuar" && read enter
		usercodes
		;;
	18)
		clear
		tokenpass
		msg -ne " Enter Para Continuar" && read enter
		usercodes
		;;
	d | 19)
		delov() {
			clear
			msg -tit
			n=1
			for ovpns in $(ls /etc/ovpn); do
				#
				echo -e "\e[1;91m [$n] \e[93m-> \e[97m${ovpns} \n"
				let n++
			done
			msg -bar
			read -p " escribe el nombre para eliminar: " nom
			rm /etc/ovpn/${nom}.zip
			rm $HOME/${nom}.zip &>/dev/null
			rm /root/${nom}.zip &>/dev/null
			rm /var/www/${nom}.zip &>/dev/null
			rm /var/www/html/${nom}.zip &>/dev/null
			msg -bar
			msg -verd " Usuario: ${nom}.zip eliminado"
			msg -ne " Enter Para Continuar" && read enter
			usercodes
		}
		clear
		msg -tit
		msg -ama "	ELIMINADOR DE OVPN "
		msg -bar
		echo -e "\033[1;92m 1).- \033[1;37m ELIMINAR OVPN "
		echo -e "\033[1;92m 2).- \033[1;37m VOLVER AL MENÚ"
		msg -bar
		echo -ne "\033[1;37mDigite un numero : \033[1;32m"
		read opcao
		case $opcao in
		1)
			delov
			;;
		2)
			usercodes
			;;
		esac
		;;
	esac
}
menufirewall() {
	barra="\e[1;100m\e[1;31m——————————————————————————————————————————————\e[0m"
	sh_ver="1.0.10"
	Green_font_prefix="\033[32m" && Red_font_prefix="\033[31m" && Green_background_prefix="\033[42;37m" && Red_background_prefix="\033[41;37m" && Font_color_suffix="\033[0m"
	Info="${Green_font_prefix}[Informacion]${Font_color_suffix}"
	Error="${Red_font_prefix}[Error]${Font_color_suffix}"

	smtp_port="25,26,465,587"
	pop3_port="109,110,995"
	imap_port="143,218,220,993"
	other_port="24,50,57,105,106,158,209,1109,24554,60177,60179"
	bt_key_word="torrent
.torrent
peer_id=
announce
info_hash
get_peers
find_node
BitTorrent
announce_peer
BitTorrent protocol
announce.php?passkey=
magnet:
xunlei
sandai
Thunder
XLLiveUD"

	check_sys() {
		if [[ -f /etc/redhat-release ]]; then
			release="centos"
		elif cat /etc/issue | grep -q -E -i "debian"; then
			release="debian"
		elif cat /etc/issue | grep -q -E -i "ubuntu"; then
			release="ubuntu"
		elif cat /etc/issue | grep -q -E -i "centos|red hat|redhat"; then
			release="centos"
		elif cat /proc/version | grep -q -E -i "debian"; then
			release="debian"
		elif cat /proc/version | grep -q -E -i "ubuntu"; then
			release="ubuntu"
		elif cat /proc/version | grep -q -E -i "centos|red hat|redhat"; then
			release="centos"
		fi
		bit=$(uname -m)
	}
	check_BT() {
		Cat_KEY_WORDS
		BT_KEY_WORDS=$(echo -e "$Ban_KEY_WORDS_list" | grep "torrent")
	}
	check_SPAM() {
		Cat_PORT
		SPAM_PORT=$(echo -e "$Ban_PORT_list" | grep "${smtp_port}")
	}
	Cat_PORT() {
		Ban_PORT_list=$(iptables -t filter -L OUTPUT -nvx --line-numbers | grep "REJECT" | awk '{print $13}')
	}
	Cat_KEY_WORDS() {
		Ban_KEY_WORDS_list=""
		Ban_KEY_WORDS_v6_list=""
		if [[ ! -z ${v6iptables} ]]; then
			Ban_KEY_WORDS_v6_text=$(${v6iptables} -t mangle -L OUTPUT -nvx --line-numbers | grep "DROP")
			Ban_KEY_WORDS_v6_list=$(echo -e "${Ban_KEY_WORDS_v6_text}" | sed -r 's/.*\"(.+)\".*/\1/')
		fi
		Ban_KEY_WORDS_text=$(${v4iptables} -t mangle -L OUTPUT -nvx --line-numbers | grep "DROP")
		Ban_KEY_WORDS_list=$(echo -e "${Ban_KEY_WORDS_text}" | sed -r 's/.*\"(.+)\".*/\1/')
	}
	View_PORT() {
		Cat_PORT
		echo -e "========${Red_background_prefix} Puerto Bloqueado Actualmente ${Font_color_suffix}========="
		echo -e "$Ban_PORT_list" && echo && echo -e "==============================================="
	}
	View_KEY_WORDS() {
		Cat_KEY_WORDS
		echo -e "============${Red_background_prefix} Actualmente Prohibido ${Font_color_suffix}============"
		echo -e "$Ban_KEY_WORDS_list" && echo -e "==============================================="
	}
	View_ALL() {
		echo
		View_PORT
		View_KEY_WORDS
		echo
		msg -bar2
	}
	Save_iptables_v4_v6() {
		if [[ ${release} == "centos" ]]; then
			if [[ ! -z "$v6iptables" ]]; then
				service ip6tables save
				chkconfig --level 2345 ip6tables on
			fi
			service iptables save
			chkconfig --level 2345 iptables on
		else
			if [[ ! -z "$v6iptables" ]]; then
				ip6tables-save >/etc/ip6tables.up.rules
				echo -e "#!/bin/bash\n/sbin/iptables-restore < /etc/iptables.up.rules\n/sbin/ip6tables-restore < /etc/ip6tables.up.rules" >/etc/network/if-pre-up.d/iptables
			else
				echo -e "#!/bin/bash\n/sbin/iptables-restore < /etc/iptables.up.rules" >/etc/network/if-pre-up.d/iptables
			fi
			iptables-save >/etc/iptables.up.rules
			chmod +x /etc/network/if-pre-up.d/iptables
		fi
	}
	Set_key_word() { $1 -t mangle -$3 OUTPUT -m string --string "$2" --algo bm --to 65535 -j DROP; }
	Set_tcp_port() {
		[[ "$1" = "$v4iptables" ]] && $1 -t filter -$3 OUTPUT -p tcp -m multiport --dports "$2" -m state --state NEW,ESTABLISHED -j REJECT --reject-with icmp-port-unreachable
		[[ "$1" = "$v6iptables" ]] && $1 -t filter -$3 OUTPUT -p tcp -m multiport --dports "$2" -m state --state NEW,ESTABLISHED -j REJECT --reject-with tcp-reset
	}
	Set_udp_port() { $1 -t filter -$3 OUTPUT -p udp -m multiport --dports "$2" -j DROP; }
	Set_SPAM_Code_v4() {
		for i in ${smtp_port} ${pop3_port} ${imap_port} ${other_port}; do
			Set_tcp_port $v4iptables "$i" $s
			Set_udp_port $v4iptables "$i" $s
		done
	}
	Set_SPAM_Code_v4_v6() {
		for i in ${smtp_port} ${pop3_port} ${imap_port} ${other_port}; do
			for j in $v4iptables $v6iptables; do
				Set_tcp_port $j "$i" $s
				Set_udp_port $j "$i" $s
			done
		done
	}
	Set_PORT() {
		if [[ -n "$v4iptables" ]] && [[ -n "$v6iptables" ]]; then
			Set_tcp_port $v4iptables $PORT $s
			Set_udp_port $v4iptables $PORT $s
			Set_tcp_port $v6iptables $PORT $s
			Set_udp_port $v6iptables $PORT $s
		elif [[ -n "$v4iptables" ]]; then
			Set_tcp_port $v4iptables $PORT $s
			Set_udp_port $v4iptables $PORT $s
		fi
		Save_iptables_v4_v6
	}
	Set_KEY_WORDS() {
		key_word_num=$(echo -e "${key_word}" | wc -l)
		for ((integer = 1; integer <= ${key_word_num}; integer++)); do
			i=$(echo -e "${key_word}" | sed -n "${integer}p")
			Set_key_word $v4iptables "$i" $s
			[[ ! -z "$v6iptables" ]] && Set_key_word $v6iptables "$i" $s
		done
		Save_iptables_v4_v6
	}
	Set_BT() {
		key_word=${bt_key_word}
		Set_KEY_WORDS
		Save_iptables_v4_v6
	}
	Set_SPAM() {
		if [[ -n "$v4iptables" ]] && [[ -n "$v6iptables" ]]; then
			Set_SPAM_Code_v4_v6
		elif [[ -n "$v4iptables" ]]; then
			Set_SPAM_Code_v4
		fi
		Save_iptables_v4_v6
	}
	Set_ALL() {
		Set_BT
		Set_SPAM
	}
	Ban_BT() {
		check_BT
		[[ ! -z ${BT_KEY_WORDS} ]] && echo -e "${Error} Torrent bloqueados y Palabras Claves, no es\nnecesario volver a prohibirlas !" && msg -bar2 && exit 0
		s="A"
		Set_BT
		View_ALL
		echo -e "${Info} Torrent bloqueados y Palabras Claves !"
		msg -bar2
	}
	Ban_SPAM() {
		check_SPAM
		[[ ! -z ${SPAM_PORT} ]] && echo -e "${Error} Se detectó un puerto SPAM bloqueado, no es\nnecesario volver a bloquear !" && msg -bar2 && exit 0
		s="A"
		Set_SPAM
		View_ALL
		echo -e "${Info} Puertos SPAM Bloqueados !"
		msg -bar2
	}
	Ban_ALL() {
		check_BT
		check_SPAM
		s="A"
		if [[ -z ${BT_KEY_WORDS} ]]; then
			if [[ -z ${SPAM_PORT} ]]; then
				Set_ALL
				View_ALL
				echo -e "${Info} Torrent bloqueados, Palabras Claves y Puertos SPAM !"
				msg -bar2
			else
				Set_BT
				View_ALL
				echo -e "${Info} Torrent bloqueados y Palabras Claves !"
			fi
		else
			if [[ -z ${SPAM_PORT} ]]; then
				Set_SPAM
				View_ALL
				echo -e "${Info} Puerto SPAM (spam) prohibido !"
			else
				echo -e "${Error} Torrent Bloqueados, Palabras Claves y Puertos SPAM,\nno es necesario volver a prohibir !" && msg -bar2 && exit 0
			fi
		fi
	}
	UnBan_BT() {
		check_BT
		[[ -z ${BT_KEY_WORDS} ]] && echo -e "${Error} Torrent y Palabras Claves no bloqueadas, verifique !" && msg -bar2 && exit 0
		s="D"
		Set_BT
		View_ALL
		echo -e "${Info} Torrent Desbloqueados y Palabras Claves !"
		msg -bar2
	}
	UnBan_SPAM() {
		check_SPAM
		[[ -z ${SPAM_PORT} ]] && echo -e "${Error} Puerto SPAM no detectados, verifique !" && msg -bar2 && exit 0
		s="D"
		Set_SPAM
		View_ALL
		echo -e "${Info} Puertos de SPAM Desbloqueados !"
		msg -bar2
	}
	UnBan_ALL() {
		check_BT
		check_SPAM
		s="D"
		if [[ ! -z ${BT_KEY_WORDS} ]]; then
			if [[ ! -z ${SPAM_PORT} ]]; then
				Set_ALL
				View_ALL
				echo -e "${Info} Torrent, Palabras Claves y Puertos SPAM Desbloqueados !"
				msg -bar2
			else
				Set_BT
				View_ALL
				echo -e "${Info} Torrent, Palabras Claves Desbloqueados !"
				msg -bar2
			fi
		else
			if [[ ! -z ${SPAM_PORT} ]]; then
				Set_SPAM
				View_ALL
				echo -e "${Info} Puertos SPAM Desbloqueados !"
				msg -bar2
			else
				echo -e "${Error} No se  detectan Torrent, Palabras Claves y Puertos SPAM Bloqueados, verifique !" && msg -bar2 && exit 0
			fi
		fi
	}
	ENTER_Ban_KEY_WORDS_type() {
		Type=$1
		Type_1=$2
		if [[ $Type_1 != "ban_1" ]]; then
			echo -e "Por favor seleccione un tipo de entrada：
		
 1. Entrada manual (solo se admiten palabras clave únicas)
 
 2. Lectura local de archivos (admite lectura por lotes de palabras clave, una palabra clave por línea)
 
 3. Lectura de dirección de red (admite lectura por lotes de palabras clave, una palabra clave por línea)" && echo
			read -e -p "(Por defecto: 1. Entrada manual):" key_word_type
		fi
		[[ -z "${key_word_type}" ]] && key_word_type="1"
		if [[ ${key_word_type} == "1" ]]; then
			if [[ $Type == "ban" ]]; then
				ENTER_Ban_KEY_WORDS
			else
				ENTER_UnBan_KEY_WORDS
			fi
		elif [[ ${key_word_type} == "2" ]]; then
			ENTER_Ban_KEY_WORDS_file
		elif [[ ${key_word_type} == "3" ]]; then
			ENTER_Ban_KEY_WORDS_url
		else
			if [[ $Type == "ban" ]]; then
				ENTER_Ban_KEY_WORDS
			else
				ENTER_UnBan_KEY_WORDS
			fi
		fi
	}
	ENTER_Ban_PORT() {
		echo -e "Ingrese el puerto que Bloqueará:\n(segmento de Puerto único / Puerto múltiple / Puerto continuo)\n"
		if [[ ${Ban_PORT_Type_1} != "1" ]]; then
			echo -e "
	${Green_font_prefix}======== Ejemplo Descripción ========${Font_color_suffix}
	
 -Puerto único: 25 (puerto único)
 
 -Multipuerto: 25, 26, 465, 587 (varios puertos están separados por comas)

 -Segmento de puerto continuo: 25: 587 (todos los puertos entre 25-587)" && echo
		fi
		read -e -p "(Intro se cancela por defecto):" PORT
		[[ -z "${PORT}" ]] && echo "Cancelado..." && View_ALL && exit 0
	}
	ENTER_Ban_KEY_WORDS() {
		msg -bar2
		echo -e "Ingrese las palabras clave que se prohibirán\n(nombre de dominio, etc., solo admite una sola palabra clave)"
		if [[ ${Type_1} != "ban_1" ]]; then
			echo ""
			echo -e "${Green_font_prefix}======== Ejemplo Descripción ========${Font_color_suffix}
	
 -Palabras clave: youtube, que prohíbe el acceso a cualquier nombre de dominio que contenga la palabra clave youtube.
 
 -Palabras clave: youtube.com, que prohíbe el acceso a cualquier nombre de dominio (máscara de nombre de pan-dominio) que contenga la palabra clave youtube.com.

 -Palabras clave: www.youtube.com, que prohíbe el acceso a cualquier nombre de dominio (máscara de subdominio) que contenga la palabra clave www.youtube.com.

 -Autoevaluación de más efectos (como la palabra clave .zip se puede usar para deshabilitar la descarga de cualquier archivo de sufijo .zip)." && echo
		fi
		read -e -p "(Intro se cancela por defecto):" key_word
		[[ -z "${key_word}" ]] && echo "Cancelado ..." && View_ALL && exit 0
	}
	ENTER_Ban_KEY_WORDS_file() {
		echo -e "Ingrese el archivo local de palabras clave que se prohibirá / desbloqueará (utilice la ruta absoluta)" && echo
		read -e -p "(El valor predeterminado es leer key_word.txt en el mismo directorio que el script):" key_word
		[[ -z "${key_word}" ]] && key_word="key_word.txt"
		if [[ -e "${key_word}" ]]; then
			key_word=$(cat "${key_word}")
			[[ -z ${key_word} ]] && echo -e "${Error} El contenido del archivo está vacío. !" && View_ALL && exit 0
		else
			echo -e "${Error} Archivo no encontrado ${key_word} !" && View_ALL && exit 0
		fi
	}
	ENTER_Ban_KEY_WORDS_url() {
		echo -e "Ingrese la dirección del archivo de red de palabras clave que se prohibirá / desbloqueará (por ejemplo, http: //xxx.xx/key_word.txt)" && echo
		read -e -p "(Intro se cancela por defecto):" key_word
		[[ -z "${key_word}" ]] && echo "Cancelado ..." && View_ALL && exit 0
		key_word=$(wget --no-check-certificate -t3 -T5 -qO- "${key_word}")
		[[ -z ${key_word} ]] && echo -e "${Error} El contenido del archivo de red está vacío o se agotó el tiempo de acceso !" && View_ALL && exit 0
	}
	ENTER_UnBan_KEY_WORDS() {
		View_KEY_WORDS
		echo -e "Ingrese la palabra clave que desea desbloquear (ingrese la palabra clave completa y precisa de acuerdo con la lista anterior)" && echo
		read -e -p "(Intro se cancela por defecto):" key_word
		[[ -z "${key_word}" ]] && echo "Cancelado ..." && View_ALL && exit 0
	}
	ENTER_UnBan_PORT() {
		echo -e "Ingrese el puerto que desea desempaquetar:\n(ingrese el puerto completo y preciso de acuerdo con la lista anterior, incluyendo comas, dos puntos)" && echo
		read -e -p "(Intro se cancela por defecto):" PORT
		[[ -z "${PORT}" ]] && echo "Cancelado ..." && View_ALL && exit 0
	}
	Ban_PORT() {
		s="A"
		ENTER_Ban_PORT
		Set_PORT
		echo -e "${Info} Puerto bloqueado [ ${PORT} ] !\n"
		Ban_PORT_Type_1="1"
		while true; do
			ENTER_Ban_PORT
			Set_PORT
			echo -e "${Info} Puerto bloqueado [ ${PORT} ] !\n"
		done
		View_ALL
	}
	Ban_KEY_WORDS() {
		s="A"
		ENTER_Ban_KEY_WORDS_type "ban"
		Set_KEY_WORDS
		echo -e "${Info} Palabras clave bloqueadas [ ${key_word} ] !\n"
		while true; do
			ENTER_Ban_KEY_WORDS_type "ban" "ban_1"
			Set_KEY_WORDS
			echo -e "${Info} Palabras clave bloqueadas [ ${key_word} ] !\n"
		done
		View_ALL
	}
	UnBan_PORT() {
		s="D"
		View_PORT
		[[ -z ${Ban_PORT_list} ]] && echo -e "${Error} Se detecta cualquier puerto no bloqueado !" && exit 0
		ENTER_UnBan_PORT
		Set_PORT
		echo -e "${Info} Puerto descapsulado [ ${PORT} ] !\n"
		while true; do
			View_PORT
			[[ -z ${Ban_PORT_list} ]] && echo -e "${Error} No se detectó puertos bloqueados !" && msg -bar2 && exit 0
			ENTER_UnBan_PORT
			Set_PORT
			echo -e "${Info} Puerto descapsulado [ ${PORT} ] !\n"
		done
		View_ALL
	}
	UnBan_KEY_WORDS() {
		s="D"
		Cat_KEY_WORDS
		[[ -z ${Ban_KEY_WORDS_list} ]] && echo -e "${Error} No se ha detectado ningún bloqueo !" && exit 0
		ENTER_Ban_KEY_WORDS_type "unban"
		Set_KEY_WORDS
		echo -e "${Info} Palabras clave desbloqueadas [ ${key_word} ] !\n"
		while true; do
			Cat_KEY_WORDS
			[[ -z ${Ban_KEY_WORDS_list} ]] && echo -e "${Error} No se ha detectado ningún bloqueo !" && msg -bar2 && exit 0
			ENTER_Ban_KEY_WORDS_type "unban" "ban_1"
			Set_KEY_WORDS
			echo -e "${Info} Palabras clave desbloqueadas [ ${key_word} ] !\n"
		done
		View_ALL
	}
	UnBan_KEY_WORDS_ALL() {
		Cat_KEY_WORDS
		[[ -z ${Ban_KEY_WORDS_text} ]] && echo -e "${Error} No se detectó ninguna clave, verifique !" && msg -bar2 && exit 0
		if [[ ! -z "${v6iptables}" ]]; then
			Ban_KEY_WORDS_v6_num=$(echo -e "${Ban_KEY_WORDS_v6_list}" | wc -l)
			for ((integer = 1; integer <= ${Ban_KEY_WORDS_v6_num}; integer++)); do
				${v6iptables} -t mangle -D OUTPUT 1
			done
		fi
		Ban_KEY_WORDS_num=$(echo -e "${Ban_KEY_WORDS_list}" | wc -l)
		for ((integer = 1; integer <= ${Ban_KEY_WORDS_num}; integer++)); do
			${v4iptables} -t mangle -D OUTPUT 1
		done
		Save_iptables_v4_v6
		View_ALL
		echo -e "${Info} Todas las palabras clave han sido desbloqueadas !"
	}
	check_iptables() {
		v4iptables=$(iptables -V)
		v6iptables=$(ip6tables -V)
		if [[ ! -z ${v4iptables} ]]; then
			v4iptables="iptables"
			if [[ ! -z ${v6iptables} ]]; then
				v6iptables="ip6tables"
			fi
		else
			echo -e "${Error} El firewall de iptables no está instalado !
Por favor, instale el firewall de iptables：
CentOS Sistema： yum install iptables -y
Debian / Ubuntu Sistema： apt-get install iptables -y"
		fi
	}
	Update_Shell() {
		sh_new_ver=$(wget --no-check-certificate -qO- -t1 -T3 "https://raw.githubusercontent.com/pedrazadixon/LACASITANULLED/main/blockBT.sh" | grep 'sh_ver="' | awk -F "=" '{print $NF}' | sed 's/\"//g' | head -1)
		[[ -z ${sh_new_ver} ]] && echo -e "${Error} No se puede vincular a Github !" && exit 0
		wget https://raw.githubusercontent.com/pedrazadixon/LACASITANULLED/main/blockBT.sh -O /etc/ger-frm/blockBT.sh &>/dev/null
		chmod +x /etc/ger-frm/blockBT.sh
		echo -e "El script ha sido actualizado a la última versión.[ ${sh_new_ver} ]"
		msg -bar2
		exit 0
	}
	clear
	#mensaje="$(less /etc/newadm/message.txt)"
	check_sys
	check_iptables
	action=$1
	if [[ ! -z $action ]]; then
		[[ $action = "banbt" ]] && Ban_BT && exit 0
		[[ $action = "banspam" ]] && Ban_SPAM && exit 0
		[[ $action = "banall" ]] && Ban_ALL && exit 0
		[[ $action = "unbanbt" ]] && UnBan_BT && exit 0
		[[ $action = "unbanspam" ]] && UnBan_SPAM && exit 0
		[[ $action = "unbanall" ]] && UnBan_ALL && exit 0
	fi
	msg -bar
	echo -e "\e[1;33m  Panel de Firewall\e[1;37m [LACASITAMX] ${Red_font_prefix}[v${sh_ver}]${Font_color_suffix}"
	echo -e "$barra"
	echo -e "\e[1;31m[1]  \e[1;34m>\e[1;31m Bloquear Torrent, Palabras Clave"
	echo -e "\e[1;31m[2]  \e[1;34m>\e[1;31m Bloquear Puertos SPAM "
	echo -e "\e[1;31m[3]  \e[1;34m>\e[1;31m Bloquear Torrent, Palabras Clave + Puertos SPAM"
	echo -e "\e[1;31m[4]  \e[1;34m>\e[1;31m Bloquear Puerto personalizado"
	echo -e "\e[1;31m[5]  \e[1;34m>\e[1;31m Bloquear Palabras Clave Personalizadas"
	echo -e "$barra"
	echo -e "\e[1;31m[6]  \e[1;34m>\e[1;32m Desbloquear Torrent, Palabras Clave"
	echo -e "\e[1;31m[7]  \e[1;34m>\e[1;32m Desbloquear Puertos SPAM"
	echo -e "\e[1;31m[8]  \e[1;34m>\e[1;32m Desbloquear Torrent, Palabras Clave , Puertos SPAM"
	echo -e "\e[1;31m[9]  \e[1;34m>\e[1;32m Desbloquear Puerto Personalizado"
	echo -e "\e[1;31m[10] \e[1;34m>\e[1;32m Desbloquear Palabra Clave Personalizadas"
	echo -e "\e[1;31m[11] \e[1;34m>\e[1;32m Desbloquear Todas las palabras Clave Personalizadas"
	echo -e "\e[1;31m[12] \e[1;34m>\e[1;37m Ver la lista actual de prohibidos"
	echo -e "$barra"
	#echo -e "\e[1;31m[13] \e[1;34m>\e[1;32m Actualizar script"
	echo -e "\e[1;31m [0] \e[1;34m> \e[1;33m<<<\e[1;31m SALIR\e[1;33m >>> " && msg -bar
	read -p " Por favor ingrese un número [0-12]: " num
	case "$num" in

	1) Ban_BT ;;
	2) Ban_SPAM ;;
	3) Ban_ALL ;;
	4) Ban_PORT ;;
	5) Ban_KEY_WORDS ;;
	6) UnBan_BT ;;
	7) UnBan_SPAM ;;
	8) UnBan_ALL ;;
	9) UnBan_PORT ;;
	10) UnBan_KEY_WORDS ;;
	11) UnBan_KEY_WORDS_ALL ;;
	12) View_ALL ;;
	#13)Update_Shell ;;
	*)
		echo "Por favor ingrese el número correcto [0-12]"
		;;
	esac
}

funbbr() {
	sh_ver="2.0"
	amarillo="\e[33m" && bla="\e[1;37m" && final="\e[0m"
	Green_font_prefix="\033[32m" && Red_font_prefix="\033[31m" && Green_background_prefix="\033[42;37m" && Red_background_prefix="\033[41;37m" && Font_color_suffix="\033[0m"
	Info="${Green_font_prefix}[Informacion]${Font_color_suffix}"
	Error="${Red_font_prefix}[Error]${Font_color_suffix}"
	Tip="${Green_font_prefix}[Atencion]${Font_color_suffix}"

	remove_all() {
		sed -i '/net.core.default_qdisc/d' /etc/sysctl.conf
		sed -i '/net.ipv4.tcp_congestion_control/d' /etc/sysctl.conf
		echo -e "\e[1;31m ACELERADOR BBR DESINSTALADA\e[0m"
	}

	startbbr() {
		remove_all
		echo "net.core.default_qdisc=fq" >>/etc/sysctl.conf
		echo "net.ipv4.tcp_congestion_control=bbr" >>/etc/sysctl.conf
		sysctl -p
		echo -e "${Info}¡BBR comenzó con éxito!"
		msg -bar
	}

	#Habilitar BBRplus
	startbbrplus() {
		remove_all
		echo "net.core.default_qdisc=fq" >>/etc/sysctl.conf
		echo "net.ipv4.tcp_congestion_control=bbrplus" >>/etc/sysctl.conf
		sysctl -p
		echo -e "${Info}BBRplus comenzó con éxito!！"
		msg -bar
	}

	# Menú de inicio
	start_menu() {
		clear
		msg -bar
		msg -tit
		echo -e " TCP Aceleración (BBR/Plus) ${Red_font_prefix}By @lacasitamx${Font_color_suffix}
$(msg -bar)
 ${Green_font_prefix}[ 1 ]${Font_color_suffix} Acelerar VPS Con BBR ${amarillo}(recomendado)${final}
 ${Green_font_prefix}[ 2 ]${Font_color_suffix} Acelerar VPS Con BBRplus
 ${Green_font_prefix}[ 3 ]${Font_color_suffix} Detener Acelerador VPS
 ${Green_font_prefix}[ 0 ]${Font_color_suffix} Salir del script" && msg -bar

		run_status=$(grep "net.ipv4.tcp_congestion_control" /etc/sysctl.conf | awk -F "=" '{print $2}')
		if [[ ${run_status} ]]; then
			echo -e " Estado actual: ${Green_font_prefix}Instalado\n${Font_color_suffix} ${_font_prefix}BBR Comenzó exitosamente${Font_color_suffix} Kernel Acelerado, ${amarillo}${run_status}${Font_color_suffix}"
		else
			echo -e " Estado actual: ${Green_font_prefix}No instalado\n${Font_color_suffix} Kernel Acelerado: ${Red_font_prefix}Por favor,instale el Acelerador primero.${Font_color_suffix}"
		fi
		msg -bar
		read -p "$(echo -e "\e[31m► ${bla}Selecione Una Opcion [0-3]:${amarillo}") " num
		case "$num" in
		0) ;;
		1) startbbr ;;
		2) startbbrplus ;;
		3) remove_all ;;
		*)
			clear
			echo -e "${Error}:Por favor ingrese el número correcto [0-3]"
			sleep 1s
			start_menu
			;;
		esac
	}

	check_sys() {
		if [[ -f /etc/redhat-release ]]; then
			release="centos"
		elif cat /etc/issue | grep -q -E -i "debian"; then
			release="debian"
		elif cat /etc/issue | grep -q -E -i "ubuntu"; then
			release="ubuntu"
		elif cat /etc/issue | grep -q -E -i "centos|red hat|redhat"; then
			release="centos"
		elif cat /proc/version | grep -q -E -i "debian"; then
			release="debian"
		elif cat /proc/version | grep -q -E -i "ubuntu"; then
			release="ubuntu"
		elif cat /proc/version | grep -q -E -i "centos|red hat|redhat"; then
			release="centos"
		fi
	}

	#Verifique la versión de Linux
	check_version() {
		if [[ -s /etc/redhat-release ]]; then
			version=$(grep -oE "[0-9.]+" /etc/redhat-release | cut -d . -f 1)
		else
			version=$(grep -oE "[0-9.]+" /etc/issue | cut -d . -f 1)
		fi
		bit=$(uname -m)
		if [[ ${bit} = "x86_64" ]]; then
			bit="x64"
		else
			bit="x32"
		fi
	}
	check_sys
	check_version
	[[ ${release} != "debian" ]] && [[ ${release} != "ubuntu" ]] && [[ ${release} != "centos" ]] && echo -e "${Error} Este script no es compatible con el sistema actual. ${release} !" && exit 1
	start_menu
}

ftpup() {
	clear
	cor=([0]="\033[1;37m" [1]="\033[1;34m" [2]="\033[1;31m" [3]="\033[1;33m" [4]="\033[1;32m")
	msg -bar
	msg -tit
	echo -e "\033[1;96m           Gestor de Archivos FTP VPS•MX"
	msg -bar
	echo -e "${cor[4]} [1] >${cor[3]} $(fun_trans "Colocar Archivo Online")"
	echo -e "${cor[4]} [2] >${cor[3]} $(fun_trans "Remover Archivo Online")"
	echo -e "${cor[4]} [3] >${cor[3]} $(fun_trans "Ver Links de Archivos Online")"
	msg -bar
	while [[ ${arquivoonlineadm} != @([1-3]) ]]; do
		read -p "[1-3]: " arquivoonlineadm
		tput cuu1 && tput dl1
	done
	case ${arquivoonlineadm} in
	3)
		[[ -z $(ls /var/www/html) ]] && echo -e "$barra" || {
			for my_arqs in $(ls /var/www/html); do
				[[ "$my_arqs" = "index.html" ]] && continue
				[[ "$my_arqs" = "index.php" ]] && continue
				[[ -d "$my_arqs" ]] && continue
				echo -e "\033[1;31m[$my_arqs] \033[1;36mhttp://$IP:81/$my_arqs\033[0m"
			done
			msg -bar
		}
		;;
	2)
		i=1
		[[ -z $(ls /var/www/html) ]] && echo -e "$barra" || {
			for my_arqs in $(ls /var/www/html); do
				[[ "$my_arqs" = "index.html" ]] && continue
				[[ "$my_arqs" = "index.php" ]] && continue
				[[ -d "$my_arqs" ]] && continue
				select_arc[$i]="$my_arqs"
				echo -e "${cor[2]}[$i] > ${cor[3]}$my_arqs - \033[1;36mhttp://$IP:81/$my_arqs\033[0m"
				let i++
			done
			msg -bar
			echo -e "${cor[5]}$(fun_trans "Seleccione el archivo que desea borrar")"
			msg -bar
			while [[ -z ${select_arc[$slct]} ]]; do
				read -p " [1-$i]: " slct
				tput cuu1 && tput dl1
			done
			arquivo_move="${select_arc[$slct]}"
			[[ -d /var/www/html ]] && [[ -e /var/www/html/$arquivo_move ]] && rm -rf /var/www/html/$arquivo_move >/dev/null 2>&1
			[[ -e /var/www/$arquivo_move ]] && rm -rf /var/www/$arquivo_move >/dev/null 2>&1
			echo -e "${cor[5]}$(fun_trans "Exito!")"
			msg -bar
		}
		;;
	1)
		i="1"
		[[ -z $(ls $HOME) ]] && echo -e "$barra" || {
			for my_arqs in $(ls $HOME); do
				[[ -d "$my_arqs" ]] && continue
				select_arc[$i]="$my_arqs"
				echo -e "${cor[2]} [$i] > ${cor[3]}$my_arqs"
				let i++
			done
			i=$(($i - 1))
			msg -bar
			echo -e "${cor[5]}$(fun_trans "Seleccione el archivo")"
			msg -bar
			while [[ -z ${select_arc[$slct]} ]]; do
				read -p " [1-$i]: " slct
				tput cuu1 && tput dl1
			done
			arquivo_move="${select_arc[$slct]}"
			[ ! -d /var ] && mkdir /var
			[ ! -d /var/www ] && mkdir /var/www
			[ ! -d /var/www/html ] && mkdir /var/www/html
			[ ! -e /var/www/html/index.html ] && touch /var/www/html/index.html
			[ ! -e /var/www/index.html ] && touch /var/www/index.html
			chmod -R 755 /var/www
			cp $HOME/$arquivo_move /var/www/$arquivo_move
			cp $HOME/$arquivo_move /var/www/html/$arquivo_move
			echo -e "\033[1;36m http://$IP:81/$arquivo_move\033[0m"
			msg -bar
			echo -e "${cor[5]}$(fun_trans "Exito!")"
			msg -bar
		}
		;;
	esac
}

fundrop() {
	clear

	del_dropbear() {
		msg -bar
		echo -e "\033[1;32m REMOVIENDO SERVICIO DROPBEAR"
		msg -bar
		service dropbear stop >/dev/null 2>&1
		fun_bar "apt-get remove dropbear -y"
		killall dropbear >/dev/null 2>&1
		rm -rf /etc/dropbear/* >/dev/null 2>&1
		msg -bar
		echo -e "\033[1;32m             DROPBEAR DESINSTALADO EXITO"
		msg -bar
		rm /etc/VPS-MX/.pdropbear.txt &>/dev/null
		[[ -e /etc/default/dropbear ]] && rm /etc/default/dropbear
		return 0
	}

	inst_dropbear() {
		msg -bar
		msg -tit
		echo -e "\033[1;32m $(fun_trans "   INSTALADOR DROPBEAR")"
		msg -bar
		echo -e "\033[1;97m Puede activar varios puertos en orden secuencial\n Ejemplo: \033[1;32m 442 443 444\033[1;37m"
		msg -bar
		echo -ne "\033[1;97m Digite  Puertos:\033[1;32m" && read -p " " -e -i "444 445" DPORT
		tput cuu1 && tput dl1
		TTOTAL2=($DPORT)
		for ((i = 0; i < ${#TTOTAL2[@]}; i++)); do
			[[ $(mportas | grep "${TTOTAL2[$i]}") = "" ]] && {
				echo -e "\033[1;33m Puerto Elegido:\033[1;32m ${TTOTAL2[$i]} OK"
				PORT2="$PORT2 ${TTOTAL2[$i]}"
			} || {
				echo -e "\033[1;33m Puerto Elegido:\033[1;31m ${TTOTAL2[$i]} FAIL"
			}
		done
		[[ -z $PORT2 ]] && {
			echo -e "\033[1;31m Ningun Puerto Valido Fue Elegido\033[0m"
			return 1
		}

		msg -bar
		echo -e "\033[1;97m Revisando Actualizaciones"
		fun_bar "apt update; apt upgrade -y > /dev/null 2>&1"
		echo -e "\033[1;97m Instalando Dropbear"

		local="/etc/dropbear/banner"

		fun_bar "apt-get install dropbear -y"
		#  apt-get install dropbear -y >/dev/null 2>&1
		touch $local
		msg -bar

		#sed -i 's/NO_START=1/NO_START=0/g' /etc/default/dropbear
		#sed -i 's/DROPBEAR_PORT=22/DROPBEAR_PORT=44/g' /etc/default/dropbear
		#sed -i 's/DROPBEAR_EXTRA_ARGS=/DROPBEAR_EXTRA_ARGS="-p 69 -p 77 -p 300"/g' /etc/default/dropbear

		cat <<EOF >/etc/default/dropbear
NO_START=0
DROPBEAR_EXTRA_ARGS="VAR"
DROPBEAR_BANNER="$local"
DROPBEAR_RECEIVE_WINDOW=65536
EOF

		for dpts in $(echo $PORT2); do
			sed -i "s/VAR/-p $dpts VAR/g" /etc/default/dropbear
		done
		sed -i "s/VAR//g" /etc/default/dropbear

		dropbearkey -t ecdsa -f /etc/dropbear/dropbear_ecdsa_host_key >/dev/null 2>&1
		dropbearkey -t dss -f /etc/dropbear/dropbear_dss_host_key >/dev/null 2>&1
		service ssh restart >/dev/null 2>&1
		#
		service dropbear restart
		echo -e "/bin/false" >>/etc/shells
		echo "/usr/sbin/nologin" >>/etc/shells
		/etc/init.d/dropbear restart
		#
		for ufww in $(echo $PORT2); do
			ufw allow $ufww/tcp >/dev/null 2>&1
		done
		sleep 2s
		#echo "$PORT2" >/etc/VPS-MX/.pdropbear.txt
		echo -e "\033[1;92m        >> DROPBEAR INSTALADO CON EXITO <<"
		msg -bar
		#
	}
	pid_inst() {
		proto="dropbear"
		portas=$(lsof -V -i -P -n | grep -v "ESTABLISHED" | grep -v "COMMAND")
		for list in $proto; do
			case $list in
			dropbear)
				portas2=$(echo $portas | grep -w "LISTEN" | grep -w "$list")
				[[ $(echo "${portas2}" | grep "$list") ]] && inst[$list]="\033[1;32m[ACTIVO] " || inst[$list]="\033[1;31m[DESACTIVADO]"
				;;
			esac
		done
	}
	clear
	pid_inst
	msg -tit
	echo ""
	echo -e "	\e[1;97mSERVICIO: ${inst[dropbear]}"
	msg -bar
	if [[ -e /etc/default/dropbear ]]; then
		echo -e "  $(msg -verd "[1]")$(msg -verm2 "➛ ")$(msg -azu "DESINSTALAR SERVICIO DROPBEAR  ")"
	else
		echo -e "  $(msg -verd "[1]")$(msg -verm2 "➛ ")$(msg -azu "INSTALAR SERVICIO DROPBEAR  ")"
	fi
	echo -e "  $(msg -verd "[0]")$(msg -verm2 "➛ ")$(msg -azu "VOLVER")"
	msg -bar
	echo -ne "  \033[1;37mSelecione Una Opcion : "
	read opc
	case $opc in
	1)
		clear
		if [[ -e /etc/default/dropbear ]]; then
			del_dropbear
		else
			inst_dropbear
		fi
		;;

	esac
}

funssl() {
	clear
	tmp="/etc/VPS-MX/crt" && [[ ! -d ${tmp} ]] && mkdir ${tmp}
	tmp_crt="/etc/VPS-MX/crt/certificados" && [[ ! -d ${tmp_crt} ]] && mkdir ${tmp_crt}

	#======cloudflare========
	export correo='lacasitamx93@gmail.com'
	export _dns='6203e90660e7ec9d52154df4faab2ee5'        #zona
	export apikey='0ed2088dab294b848d52b94d011b3c6440f54' #key
	export _domain='lacasitamx.xyz'
	export url='https://api.cloudflare.com/client/v4/zones'
	#
	#========================

	#fun_ip &>/dev/null
	crear_subdominio() {
		clear
		clear
		wget -qO- ipv4.icanhazip.com >${SCPdir}/MEUIPvps
		apt install jq -y &>/dev/null
		msg -tit
		echo -e "       \e[91m\e[43mGENERADOR DE SUB-DOMINIOS\e[0m"
		msg -verd " Verificando direccion ip..."
		sleep 2

		ls_dom=$(curl -s -X GET "$url/$_dns/dns_records?per_page=100" \
			-H "X-Auth-Email: $correo" \
			-H "X-Auth-Key: $apikey" \
			-H "Content-Type: application/json" | jq '.')

		num_line=$(echo $ls_dom | jq '.result | length')
		ls_domi=$(echo $ls_dom | jq -r '.result[].name')
		ls_ip=$(echo $ls_dom | jq -r '.result[].content')
		my_ip=$(wget -qO- ipv4.icanhazip.com)

		if [[ $(echo "$ls_ip" | grep -w "$my_ip") = "$my_ip" ]]; then
			for ((i = 0; i < $num_line; i++)); do
				if [[ $(echo "$ls_dom" | jq -r ".result[$i].content" | grep -w "$my_ip") = "$my_ip" ]]; then
					domain=$(echo "$ls_dom" | jq -r ".result[$i].name")
					echo "$domain" >/etc/VPS-MX/tmp/dominio.txt
					break
				fi
			done
			tput cuu1 && tput dl1
			msg -verm2 " ya existe un sub-dominio asociado a esta IP"
			msg -bar
			echo -e " $(msg -ama "sub-dominio:") $(msg -verd "$domain")"
			msg -bar
			exit
		fi

		if [[ -z $name ]]; then
			tput cuu1 && tput dl1
			echo -e " $(msg -azu "El dominio principal es:") $(msg -verd "$_domain")\n $(msg -azu "El sub-dominio sera:") $(msg -verd "mivps.$_domain")"
			msg -bar
			while [[ -z "$name" ]]; do
				msg -ne " Nombre (ejemplo: mivps)  "
				read name
				tput cuu1 && tput dl1

				name=$(echo "$name" | tr -d '[[:space:]]')

				if [[ -z $name ]]; then
					msg -verm2 " ingresar un nombre...!"
					unset name
					sleep 2
					tput cuu1 && tput dl1
					continue
				elif [[ ! $name =~ $tx_num ]]; then
					msg -verm2 " ingresa solo letras y numeros...!"
					unset name
					sleep 2
					tput cuu1 && tput dl1
					continue
				elif [[ "${#name}" -lt "3" ]]; then
					msg -verm2 " nombre demaciado corto!"
					sleep 2
					tput cuu1 && tput dl1
					unset name
					continue
				else
					domain="$name.$_domain"
					msg -ama " Verificando disponibiliad..."
					sleep 2
					tput cuu1 && tput dl1
					if [[ $(echo "$ls_domi" | grep "$domain") = "" ]]; then
						echo -e " $(msg -verd "[ok]") $(msg -azu "sub-dominio disponible")"
						sleep 2
					else
						echo -e " $(msg -verm2 "[fail]") $(msg -azu "sub-dominio NO disponible")"
						unset name
						sleep 2
						tput cuu1 && tput dl1
						continue
					fi
				fi
			done
		fi
		tput cuu1 && tput dl1
		echo -e " $(msg -azu " El sub-dominio sera:") $(msg -verd "$domain")"
		msg -bar
		msg -ne " Continuar...[S/N]: "
		read opcion
		[[ $opcion = @(n|N) ]] && return 1
		tput cuu1 && tput dl1
		msg -azu " Creando sub-dominio"
		sleep 1

		var=$(
			cat <<EOF
{
  "type": "A",
  "name": "$name",
  "content": "$my_ip",
  "ttl": 1,
  "priority": 10,
  "proxied": false
}
EOF
		)
		chek_domain=$(curl -s -X POST "$url/$_dns/dns_records" \
			-H "X-Auth-Email: $correo" \
			-H "X-Auth-Key: $apikey" \
			-H "Content-Type: application/json" \
			-d $(echo $var | jq -c '.') | jq '.')

		tput cuu1 && tput dl1
		if [[ "$(echo $chek_domain | jq -r '.success')" = "true" ]]; then
			echo "$(echo $chek_domain | jq -r '.result.name')" >/etc/VPS-MX/tmp/dominio.txt
			msg -verd " Sub-dominio creado con exito!"
			userid="${SCPdir}/ID"
			TOKEN="xxxxxx"
			URL="https://api.telegram.org/bot$TOKEN/sendMessage"
			while read user; do

				if [[ $(cat ${userid} | grep "605531451") = "" ]]; then

					MSG="🔰SUB-DOMINIO CREADO 🔰"
					# curl -s --max-time 10 -d "chat_id=${user}&disable_web_page_preview=1&text=$MSG" $URL &>/dev/null
					# curl -s --max-time 10 -d "chat_id=605531451&disable_web_page_preview=1&text=$MSG" $URL &>/dev/null
				else

					MSG="🔰SUB-DOMINIO CREADO 🔰"
					# curl -s --max-time 10 -d "chat_id=${user}&disable_web_page_preview=1&text=$MSG" $URL &>/dev/null
				fi
			done <<<"$(cat ${userid} | cut -d' ' -f1)"
			#
		else
			echo "" >/etc/VPS-MX/tmp/dominio.txt
			msg -ama " Falla al crear Sub-dominio!"
		fi

	}
	ssl_stunel() {
		[[ $(mportas | grep stunnel4 | head -1) ]] && {
			echo -e "\033[1;33m $(fun_trans "Deteniendo Stunnel")"
			msg -bar
			service stunnel4 stop >/dev/null 2>&1
			service stunnel stop &>/dev/null
			apt-get purge stunnel4 -y &>/dev/null && echo -e "\e[31m DETENIENDO SERVICIO SSL" | pv -qL10
			apt-get purge stunnel -y &>/dev/null
			rm /etc/VPS-MX/.pssl.txt &>/dev/null
			if [[ ! -z $(crontab -l | grep -w "onssl.sh") ]]; then
				#si existe
				crontab -l >/root/cron
				sed -i '/onssl.sh/ d' /root/cron
				crontab /root/cron
				rm /tmp/st/onssl.sh
				rm -rf /tmp/st
			fi #saltando

			msg -bar
			echo -e "\033[1;33m $(fun_trans "Detenido Con Exito!")"
			msg -bar
			return 0
		}
		clear
		msg -bar
		echo -e "\033[1;33m $(fun_trans "Seleccione una puerta de redirección interna.")"
		echo -e "\033[1;33m $(fun_trans "Un puerto SSH/DROPBEAR/SQUID/OPENVPN/PYTHON")"
		msg -bar
		while true; do
			echo -ne "\033[1;37m"
			read -p " Puerto Local: " redir
			echo ""
			if [[ ! -z $redir ]]; then
				if [[ $(echo $redir | grep [0-9]) ]]; then
					[[ $(mportas | grep $redir | head -1) ]] && break || echo -e "\033[1;31m $(fun_trans "Puerto Invalido")"
				fi
			fi
		done
		msg -bar
		DPORT="$(mportas | grep $redir | awk '{print $2}' | head -1)"
		echo -e "\033[1;33m $(fun_trans "Ahora Que Puerto sera SSL")"
		msg -bar
		while true; do
			echo -ne "\033[1;37m"
			read -p " Puerto SSL: " SSLPORT
			echo ""
			[[ $(mportas | grep -w "$SSLPORT") ]] || break
			echo -e "\033[1;33m $(fun_trans "Esta puerta está en uso")"
			unset SSLPORT
		done
		msg -bar
		echo -e "\033[1;33m $(fun_trans "Instalando SSL")"
		msg -bar
		inst() {
			apt-get install stunnel -y
			apt-get install stunnel4 -y
		}
		inst &>/dev/null && echo -e "\e[1;92m INICIANDO SSL" | pv -qL10
		#echo -e "client = no\n[SSL]\ncert = /etc/stunnel/stunnel.pem\naccept = ${SSLPORT}\nconnect = 127.0.0.1:${DPORT}" > /etc/stunnel/stunnel.conf
		echo -e "cert = /etc/stunnel/stunnel.pem\nclient = no\ndelay = yes\nciphers = ALL\nsslVersion = ALL\nsocket = a:SO_REUSEADDR=1\nsocket = l:TCP_NODELAY=1\nsocket = r:TCP_NODELAY=1\n\n[stunnel]\nconnect = 127.0.0.1:${DPORT}\naccept = ${SSLPORT}" >/etc/stunnel/stunnel.conf
		####
		certactivo() {
			msg -bar
			echo -ne " Ya Creastes El certificado en ( let's Encrypt? o en Zero SSL? )\n Si Aun No Lo Instala Por Favor Precione N [S/N]: "
			read seg
			[[ $seg = @(n|N) ]] && msg -bar && crearcert
			db="$(ls ${tmp_crt})"
			#  opcion="n"
			if [[ ! "$(echo "$db" | grep ".crt")" = "" ]]; then
				cert=$(echo "$db" | grep ".crt")
				key=$(echo "$db" | grep ".key")
				msg -bar
				msg -azu "CERTIFICADO SSL ENCONTRADO"
				msg -bar
				echo -e "$(msg -azu "CERT:") $(msg -ama "$cert")"
				echo -e "$(msg -azu "KEY:")  $(msg -ama "$key")"
				msg -bar
				cp ${tmp_crt}/$cert ${tmp}/stunnel.crt
				cp ${tmp_crt}/$key ${tmp}/stunnel.key
				cat ${tmp}/stunnel.key ${tmp}/stunnel.crt >/etc/stunnel/stunnel.pem

				sed -i 's/ENABLED=0/ENABLED=1/g' /etc/default/stunnel4
				echo "ENABLED=1" >>/etc/default/stunnel4
				systemctl start stunnel4 &>/dev/null
				systemctl start stunnel &>/dev/null
				systemctl restart stunnel4 &>/dev/null
				systemctl restart stunnel &>/dev/null

				msg -bar
				echo -e "\033[1;33m $(fun_trans "CERTIFICADO INSTALADO CON EXITO")"
				msg -bar

				rm -rf ${tmp_crt}/stunnel.crt >/dev/null 2>&1
				rm -rf ${tmp_crt}/stunnel.key >/dev/null 2>&1
			fi
			return 0
		}
		crearcert() {
			openssl genrsa -out ${tmp}/stunnel.key 2048 >/dev/null 2>&1
			(
				echo "mx"
				echo "mx"
				echo "Speed"
				echo "@conectedmx_bot"
				echo "@conectedmx"
				echo "@lacasitamx"
				echo "@conectedmx_vip"
			) | openssl req -new -key ${tmp}/stunnel.key -x509 -days 1000 -out ${tmp}/stunnel.crt >/dev/null 2>&1

			cat ${tmp}/stunnel.key ${tmp}/stunnel.crt >/etc/stunnel/stunnel.pem
			######-------
			sed -i 's/ENABLED=0/ENABLED=1/g' /etc/default/stunnel4
			echo "ENABLED=1" >>/etc/default/stunnel4
			systemctl start stunnel4 &>/dev/null
			systemctl start stunnel &>/dev/null
			systemctl restart stunnel4 &>/dev/null
			systemctl restart stunnel &>/dev/null

			msg -bar
			echo "$SSLPORT" >/etc/VPS-MX/.pssl.txt
			echo -e "\033[1;33m $(fun_trans "SSL INSTALADO CON EXITO")"
			msg -bar

			rm -rf /root/stunnel.crt >/dev/null 2>&1
			rm -rf /root/stunnel.key >/dev/null 2>&1
			return 0
		}
		clear
		msg -tit
		echo -e "$(msg -verd "[1]")$(msg -verm2 "➛ ")$(msg -azu "CERIFICADO SSL STUNNEL4 ")"
		echo -e "$(msg -verd "[2]")$(msg -verm2 "➛ ")$(msg -azu "Certificado Existen de Zero ssl | Let's Encrypt")"
		msg -bar
		echo -ne "\033[1;37mSelecione Una Opcion: "
		read opcao
		case $opcao in
		1) crearcert ;;
		2) certactivo ;;
		esac
	}
	SPR &
	ssl_stunel_2() {
		echo -e "\033[1;32m $(fun_trans "             AGREGAR MAS PUERTOS SSL")"
		msg -bar
		echo -e "\033[1;33m $(fun_trans "Seleccione una puerta de redirección interna.")"
		echo -e "\033[1;33m $(fun_trans "Un puerto SSH/DROPBEAR/SQUID/OPENVPN/SSL")"
		msg -bar
		while true; do
			echo -ne "\033[1;37m"
			read -p " Puerto-Local: " portx
			echo ""
			if [[ ! -z $portx ]]; then
				if [[ $(echo $portx | grep [0-9]) ]]; then
					[[ $(mportas | grep $portx | head -1) ]] && break || echo -e "\033[1;31m $(fun_trans "Puerto Invalido")"
				fi
			fi
		done
		msg -bar
		DPORT="$(mportas | grep $portx | awk '{print $2}' | head -1)"
		echo -e "\033[1;33m $(fun_trans "Ahora Que Puerto sera SSL")"
		msg -bar
		while true; do
			echo -ne "\033[1;37m"
			read -p " Listen-SSL: " SSLPORT
			echo ""
			[[ $(mportas | grep -w "$SSLPORT") ]] || break
			echo -e "\033[1;33m $(fun_trans "Esta puerta está en uso")"
			unset SSLPORT
		done
		msg -bar
		echo -e "\033[1;33m $(fun_trans "Instalando SSL")"
		msg -bar
		apt-get install stunnel4 -y &>/dev/null && echo -e "\e[1;92m INICIANDO SSL" | pv -qL10
		echo -e "client = no\n[stunnel+]\ncert = /etc/stunnel/stunnel.pem\naccept = ${SSLPORT}\nconnect = 127.0.0.1:${DPORT}" >>/etc/stunnel/stunnel.conf
		######
		sed -i 's/ENABLED=0/ENABLED=1/g' /etc/default/stunnel4
		echo "ENABLED=1" >>/etc/default/stunnel4
		systemctl start stunnel4 &>/dev/null
		systemctl start stunnel &>/dev/null
		systemctl restart stunnel4 &>/dev/null
		systemctl restart stunnel &>/dev/null
		msg -bar
		echo "$SSLPORT" >/etc/VPS-MX/.pssl.txt
		echo -e "${cor[4]}            INSTALADO CON EXITO"
		msg -bar

		rm -rf /root/stunnel.crt >/dev/null 2>&1
		rm -rf /root/stunnel.key >/dev/null 2>&1
		return 0
	}
	sslpython() {
		msg -bar
		echo -e "\033[1;37mSe Requiere tener el puerto 80 y el 443 libres"
		echo -ne " Desea Continuar? [S/N]: "
		read seg
		[[ $seg = @(n|N) ]] && msg -bar && return
		clear
		install_python() {
			apt-get install python -y &>/dev/null && echo -e "\033[1;97m Activando Python Directo ►80\n" | pv -qL 10

			sleep 2
			echo -e "[Unit]\nDescription=python.py Service by @lacasitamx\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nUser=root\nWorkingDirectory=/root\nExecStart=/usr/bin/python ${SCPinst}/python.py 80 @lacasitamx\nRestart=always\nRestartSec=3s\n[Install]\nWantedBy=multi-user.target" >/etc/systemd/system/python.PD.service
			systemctl enable python.PD &>/dev/null
			systemctl start python.PD &>/dev/null
			echo "80 @LACASITAMX" >/etc/VPS-MX/PortPD.log
			echo "80 @LACASITAMX" >/etc/VPS-MX/PySSL.log
			echo "80" >/etc/VPS-MX/.ppython.txt
			msg -bar
		}

		install_ssl() {
			apt-get install stunnel4 -y &>/dev/null && echo -e "\033[1;97m Activando Servicios SSL ►443\n" | pv -qL 12

			apt-get install stunnel4 -y >/dev/null 2>&1
			#echo -e "client = no\ncert = /etc/stunnel/stunnel.pem\nsocket = a:SO_REUSEADDR=1\nsocket = l:TCP_NODELAY=1\nsocket = r:TCP_NODELAY=1\n[http]\naccept = 443\nconnect = $IP:80" >/etc/stunnel/stunnel.conf
			echo -e "cert = /etc/stunnel/stunnel.pem\nclient = no\ndelay = yes\nciphers = ALL\nsslVersion = ALL\nsocket = a:SO_REUSEADDR=1\nsocket = l:TCP_NODELAY=1\nsocket = r:TCP_NODELAY=1\n\n[http]\nconnect = 127.0.0.1:80\naccept = 443" >/etc/stunnel/stunnel.conf
			openssl genrsa -out stunnel.key 2048 >/dev/null 2>&1
			(
				echo mx
				echo @lacasitamx
				echo Full
				echo speed
				echo internet
				echo @conectedmx
				echo @conectedmx_bot
			) | openssl req -new -key stunnel.key -x509 -days 1095 -out stunnel.crt >/dev/null 2>&1
			cat stunnel.crt stunnel.key >stunnel.pem
			mv stunnel.pem /etc/stunnel/
			######-------
			sed -i 's/ENABLED=0/ENABLED=1/g' /etc/default/stunnel4
			echo "ENABLED=1" >>/etc/default/stunnel4
			systemctl start stunnel4 &>/dev/null
			systemctl start stunnel &>/dev/null
			systemctl restart stunnel4 &>/dev/null
			systemctl restart stunnel &>/dev/null
			rm -rf /root/stunnel.crt >/dev/null 2>&1
			rm -rf /root/stunnel.key >/dev/null 2>&1
		}
		install_python
		install_ssl
		echo "443" >/etc/VPS-MX/.pssl.txt
		msg -bar
		echo -e "${cor[4]}               INSTALACION COMPLETA"
		msg -bar
	}

	python22() {
		msg -bar
		echo -e "\033[1;37mSe Activara el Python 22 > 80 directo"
		echo -ne " Desea Continuar? [S/N]: "
		read seg
		[[ $seg = @(n|N) ]] && msg -bar && return
		clear
		install() {
			apt-get install python -y &>/dev/null && echo -e "\033[1;97m Activando Python Directo ►80\n" | pv -qL 10

			sleep 2
			echo -e "[Unit]\nDescription=python.py Service by @lacasitamx\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nUser=root\nWorkingDirectory=/root\nExecStart=/usr/bin/python ${SCPinst}/python.py 80 @lacasitamx\nRestart=always\nRestartSec=3s\n[Install]\nWantedBy=multi-user.target" >/etc/systemd/system/python.PD.service
			systemctl enable python.PD &>/dev/null
			systemctl start python.PD &>/dev/null
			echo "80 @LACASITAMX" >/etc/VPS-MX/PortPD.log
			echo "80 @LACASITAMX" >/etc/VPS-MX/PySSL.log
			#echo "443" >/etc/VPS-MX/.pssl.txt
			echo "80" >/etc/VPS-MX/.ppython.txt
			msg -bar
		}
		install
		msg -bar
		echo -e "${cor[4]}               INSTALACION COMPLETA"
		msg -bar
	}
	l="/usr/local/lib/sped" && [[ ! -d ${l} ]] && exit
	unistall() {
		clear
		msg -bar
		msg -ama "DETENIENDO SERVICIOS SSL Y PYTHON"
		msg -bar
		service stunnel4 stop >/dev/null 2>&1
		apt-get purge stunnel4 -y &>/dev/null
		apt-get purge stunnel -y &>/dev/null
		kill -9 $(ps aux | grep -v grep | grep -w "python.py" | grep dmS | awk '{print $2}') &>/dev/null
		systemctl stop python.PD &>/dev/null
		systemctl disable python.PD &>/dev/null
		rm /etc/systemd/system/python.PD.service &>/dev/null
		rm /etc/VPS-MX/PortPD.log &>/dev/null
		rm /etc/VPS-MX/.pssl.txt &>/dev/null
		rm /etc/VPS-MX/PySSL.log &>/dev/null
		rm /etc/VPS-MX/.ppython.txt &>/dev/null
		#rm -rf /etc/stunnel/certificado.zip private.key certificate.crt ca_bundle.crt &>/dev/null
		clear
		msg -bar
		msg -verd "LOS SERVICIOS SE HAN DETENIDO"
		msg -bar
	}

	#
	certif() {
		if [ -f /etc/stunnel/stunnel.conf ]; then
			msg -bar
			msg -tit
			echo -e "\e[1;37m ACONTINUACION ES TENER LISTO EL LINK DEL CERTIFICADO.zip\n VERIFICADO EN ZEROSSL, DESCARGALO Y SUBELO\n EN TU GITHUB O DROPBOX"
			echo -ne " Desea Continuar? [S/N]: "
			read seg
			[[ $seg = @(n|N) ]] && msg -bar && return
			clear
			####Cerrificado ssl/tls#####
			msg -bar
			echo -e "\e[1;33m👇 LINK DEL CERTIFICADO.zip 👇           \n     \e[0m"
			echo -ne "\e[1;36m LINK\e[37m: \e[34m"
			#extraer certificado.zip
			read linkd
			wget $linkd -O /etc/stunnel/certificado.zip
			cd /etc/stunnel/
			unzip certificado.zip
			cat private.key certificate.crt ca_bundle.crt >stunnel.pem
			#
			sed -i 's/ENABLED=0/ENABLED=1/g' /etc/default/stunnel4
			echo "ENABLED=1" >>/etc/default/stunnel4
			systemctl start stunnel4 &>/dev/null
			systemctl start stunnel &>/dev/null
			systemctl restart stunnel4 &>/dev/null
			systemctl restart stunnel &>/dev/null
			msg -bar
			echo -e "${cor[4]} CERTIFICADO INSTALADO CON EXITO \e[0m"
			msg -bar
		else
			msg -bar
			echo -e "${cor[3]} SERVICIO SSL NO ESTÁ INSTALADO \e[0m"
			msg -bar
		fi
	}

	certificadom() {
		if [ -f /etc/stunnel/stunnel.conf ]; then
			insapa2() {
				for pid in $(pgrep python); do
					kill $pid
				done
				for pid in $(pgrep apache2); do
					kill $pid
				done
				service dropbear stop
				apt install apache2 -y
				echo "Listen 80

<IfModule ssl_module>
        Listen 443
</IfModule>

<IfModule mod_gnutls.c>
        Listen 443
</IfModule> " >/etc/apache2/ports.conf
				service apache2 restart
			}
			clear
			msg -bar
			insapa2 &>/dev/null && echo -e " \e[1;33mAGREGANDO RECURSOS " | pv -qL 10
			msg -bar
			echo -e "\e[1;37m Verificar dominio \e[0m\n\n"
			echo -e "\e[1;37m TIENES QUE MODIFICAR EL ARCHIVO DESCARGADO\n EJEMPLO: 530DDCDC3 comodoca.com 7bac5e210\e[0m"
			msg -bar
			read -p " LLAVE > Nombre Del Archivo: " keyy
			msg -bar
			read -p " DATOS > De La LLAVE: " dat2w
			[[ ! -d /var/www/html/.well-known ]] && mkdir /var/www/html/.well-known
			[[ ! -d /var/www/html/.well-known/pki-validation ]] && mkdir /var/www/html/.well-known/pki-validation
			datfr1=$(echo "$dat2w" | awk '{print $1}')
			datfr2=$(echo "$dat2w" | awk '{print $2}')
			datfr3=$(echo "$dat2w" | awk '{print $3}')
			echo -ne "${datfr1}\n${datfr2}\n${datfr3}" >/var/www/html/.well-known/pki-validation/$keyy.txt
			msg -bar
			echo -e "\e[1;37m VERIFIQUE EN LA PÁGINA ZEROSSL \e[0m"
			msg -bar
			read -p " ENTER PARA CONTINUAR"
			clear
			msg -bar
			echo -e "\e[1;33m👇 LINK DEL CERTIFICADO 👇       \n     \e[0m"
			echo -e "\e[1;36m LINK\e[37m: \e[34m"
			read link
			incertis() {
				wget $link -O /etc/stunnel/certificado.zip
				cd /etc/stunnel/
				unzip certificado.zip
				cat private.key certificate.crt ca_bundle.crt >stunnel.pem
				#
				sed -i 's/ENABLED=0/ENABLED=1/g' /etc/default/stunnel4
				echo "ENABLED=1" >>/etc/default/stunnel4
				systemctl start stunnel4 &>/dev/null
				systemctl start stunnel &>/dev/null
				systemctl restart stunnel4 &>/dev/null
				systemctl restart stunnel &>/dev/null
			}
			incertis &>/dev/null && echo -e " \e[1;33mEXTRAYENDO CERTIFICADO " | pv -qL 10
			msg -bar
			echo -e "${cor[4]} CERTIFICADO INSTALADO \e[0m"
			msg -bar

			for pid in $(pgrep apache2); do
				kill $pid
			done
			apt install apache2 -y &>/dev/null
			echo "Listen 81

<IfModule ssl_module>
        Listen 443
</IfModule>

<IfModule mod_gnutls.c>
        Listen 443
</IfModule> " >/etc/apache2/ports.conf
			service apache2 restart &>/dev/null
			service dropbear start &>/dev/null
			service dropbear restart &>/dev/null
			for port in $(cat /etc/VPS-MX/PortPD.log | grep -v "nobody" | cut -d' ' -f1); do
				PIDVRF3="$(ps aux | grep pid-"$port" | grep -v grep | awk '{print $2}')"
				Portd="$(cat /etc/VPS-MX/PortPD.log | grep -v "nobody" | cut -d' ' -f1)"
				if [[ -z ${Portd} ]]; then
					# systemctl start python.PD &>/dev/null
					#screen -dmS pydic-"$port" python /etc/VPS-MX/protocolos/python.py "$port"
					screen -dmS ws$port python ${SCPinst}/PDirect.py $port >/root/proxy.log &
				else
					echo ""
					#  systemctl start python.PD &>/dev/null
				fi
			done
		else
			msg -bar
			echo -e "${cor[3]} SSL/TLS NO INSTALADO \e[0m"
			msg -bar
		fi
	}
	#
	stop_port() {
		msg -bar
		msg -ama " Comprovando puertos..."
		ports=('80' '443')

		for i in ${ports[@]}; do
			if [[ 0 -ne $(lsof -i:$i | grep -i -c "listen") ]]; then
				msg -bar
				echo -ne "$(msg -ama " Liberando puerto: $i")"
				lsof -i:$i | awk '{print $2}' | grep -v "PID" | xargs kill -9
				sleep 1s
				if [[ 0 -ne $(lsof -i:$i | grep -i -c "listen") ]]; then
					tput cuu1 && tput dl1
					msg -verm2 "ERROR AL LIBERAR PURTO $i"
					msg -bar
					msg -ama " Puerto $i en uso."
					msg -ama " auto-liberacion fallida"
					msg -ama " detenga el puerto $i manualmente"
					msg -ama " e intentar nuevamente..."
					msg -bar

					return 1
				fi
			fi
		done
	}

	acme_install() {

		if [[ ! -e $HOME/.acme.sh/acme.sh ]]; then
			msg -bar3
			msg -ama " INSTALANDO SCRIPT ACME"
			curl -s "https://get.acme.sh" | sh &>/dev/null
		fi
		if [[ ! -z "${mail}" ]]; then
			msg -bar
			msg -ama " LOGEANDO EN Zerossl"
			sleep 1
			$HOME/.acme.sh/acme.sh --register-account -m ${mail} --server zerossl
			$HOME/.acme.sh/acme.sh --set-default-ca --server zerossl

		else
			msg -bar
			msg -ama " APLICANDO SERVIDOR letsencrypt"
			msg -bar
			sleep 1
			$HOME/.acme.sh/acme.sh --set-default-ca --server letsencrypt

		fi
		msg -bar
		msg -ama " GENERANDO CERTIFICADO SSL"
		msg -bar
		sleep 1
		if "$HOME"/.acme.sh/acme.sh --issue -d "${domain}" --standalone -k ec-256 --force; then
			"$HOME"/.acme.sh/acme.sh --installcert -d "${domain}" --fullchainpath ${tmp_crt}/${domain}.crt --keypath ${tmp_crt}/${domain}.key --ecc --force &>/dev/null

			rm -rf $HOME/.acme.sh/${domain}_ecc
			msg -bar
			msg -verd " Certificado SSL se genero con éxito"
			msg -bar

		else
			rm -rf "$HOME/.acme.sh/${domain}_ecc"
			msg -bar
			msg -verm2 "Error al generar el certificado SSL"
			msg -bar
			msg -ama " verifique los posibles error"
			msg -ama " o intente de nuevo"

		fi
	}

	gerar_cert() {
		clear
		case $1 in
		1)
			msg -bar
			msg -ama "Generador De Certificado Let's Encrypt"
			msg -bar
			;;
		2)
			msg -bar
			msg -ama "Generador De Certificado Zerossl"
			msg -bar
			;;
		esac
		msg -ama "Requiere ingresar un dominio."
		msg -ama "el mismo solo deve resolver DNS, y apuntar"
		msg -ama "a la direccion ip de este servidor."
		msg -bar
		msg -ama "Temporalmente requiere tener"
		msg -ama "los puertos 80 y 443 libres."
		if [[ $1 = 2 ]]; then
			msg -bar
			msg -ama "Requiere tener una cuenta Zerossl."
		fi
		msg -bar
		msg -ne " Continuar [S/N]: "
		read opcion
		[[ $opcion != @(s|S|y|Y) ]] && return 1

		if [[ $1 = 2 ]]; then
			while [[ -z $mail ]]; do
				clear
				msg -bar
				msg -ama "ingresa tu correo usado en Zerossl"
				msg -bar3
				msg -ne " >>> "
				read mail
			done
		fi

		if [[ -e ${tmp_crt}/dominio.txt ]]; then
			domain=$(cat ${tmp_crt}/dominio.txt)
			[[ $domain = "multi-domain" ]] && unset domain
			if [[ ! -z $domain ]]; then
				clear
				msg -bar
				msg -azu "Dominio asociado a esta ip"
				msg -bar
				echo -e "$(msg -verm2 " >>> ") $(msg -ama "$domain")"
				msg -ne "Continuar, usando este dominio? [S/N]: "
				read opcion
				tput cuu1 && tput dl1
				[[ $opcion != @(S|s|Y|y) ]] && unset domain
			fi
		fi

		while [[ -z $domain ]]; do
			clear
			msg -bar
			msg -ama "ingresa tu dominio"
			msg -bar
			msg -ne " >>> "
			read domain
		done
		msg -bar
		msg -ama " Comprovando direccion IP ..."
		local_ip=$(wget -qO- ipv4.icanhazip.com)
		domain_ip=$(ping "${domain}" -c 1 | sed '1{s/[^(]*(//;s/).*//;q}')
		sleep 1
		[[ -z "${domain_ip}" ]] && domain_ip="ip no encontrada"
		if [[ $(echo "${local_ip}" | tr '.' '+' | bc) -ne $(echo "${domain_ip}" | tr '.' '+' | bc) ]]; then
			clear
			msg -bar
			msg -verm2 "ERROR DE DIRECCION IP"
			msg -bar
			msg -ama " La direccion ip de su dominio\n no coincide con la de su servidor."
			msg -bar
			echo -e " $(msg -azu "IP dominio:  ")$(msg -verm2 "${domain_ip}")"
			echo -e " $(msg -azu "IP servidor: ")$(msg -verm2 "${local_ip}")"
			msg -bar
			msg -ama " Verifique su dominio, e intente de nuevo."
			msg -bar

		fi

		stop_port
		acme_install
		echo "$domain" >${tmp_crt}/dominio.txt

	}
	if [[ ! -z $(crontab -l | grep -w "onssl.sh") ]]; then
		ons="\e[1;92m[ON]"
	else
		ons="\e[1;91m[OFF]"
	fi
	clear
	[[ $(ps x | grep stunnel4 | grep -v grep | awk '{print $1}') ]] && stunel4="\e[1;32m[ ON ]" || stunel4="\e[1;31m[ OFF ]"

	#msg -bar
	msg -bar3
	msg -tit
	msg -bar
	echo -e "       \e[91m\e[43mINSTALADOR MULTI SSL/TLS\e[0m "
	msg -bar
	echo -e "$(msg -verd "[1]")$(msg -verm2 "➛ ")$(msg -azu "INICIAR |DETENER SSL") $stunel4"
	echo -e "$(msg -verd "[2]")$(msg -verm2 "➛ ")$(msg -azu "AGREGAR + PUERTOS SSL")"
	msg -bar
	echo -e "$(msg -verd "[3]")$(msg -verm2 "➛ ")$(msg -azu "SSL+Websocket Auto-Config 80➮443    ")"
	echo -e "$(msg -verd "[4]")$(msg -verm2 "➛ ")$(msg -azu "Websocket Auto-Config 22➮443    ")"
	echo -e "$(msg -verd "[5]")$(msg -verm2 "➛ ")$(msg -azu "\e[1;31mDETENER SERVICIO SSL+Websocket  ")"
	msg -bar
	echo -e "$(msg -verd "[6]")$(msg -verm2 "➛ ")$(msg -azu "CREAR SUBDOMINIO") \e[1;92m( Nuevo )"
	msg -bar
	echo -e "$(msg -verd "[7]")$(msg -verm2 "➛ ")$(msg -azu "CERTIFICADO SSL/TLS")"
	echo -e "$(msg -verd "[8]")$(msg -verm2 "➛ ")$(msg -azu "ENCENDER SSL")"
	echo -e "$(msg -verd "[9]")$(msg -verm2 "➛ ")$(msg -azu "AUTO-MANTENIMIENTO SSL") $ons"
	[[ -e /etc/stunnel/private.key ]] && echo -e "$(msg -verd "[10]")$(msg -verm2 "➛ ")$(msg -azu "Usar Certificado Zerossl")"
	msg -bar
	echo -ne "\033[1;37mSelecione Una Opcion: "
	read opcao
	case $opcao in
	1)
		msg -bar
		ssl_stunel

		;;
	2)
		msg -bar
		ssl_stunel_2
		sleep 3
		exit
		;;
	3)
		sslpython
		exit
		;;
	4)
		python22
		exit
		;;
	5) unistall ;;
	6)
		crear_subdominio
		exit
		;;
	7)
		clear
		msg -bar
		echo -e "	\e[91m\e[43mCERTIFICADO SSL/TLS\e[0m"
		msg -bar
		echo -e "$(msg -verd "[1]")$(msg -verm2 "➛ ")$(msg -azu "CERTIFICADO ZIP DIRECTO")"
		echo -e "$(msg -verd "[2]")$(msg -verm2 "➛ ")$(msg -azu "CERTIFICADO MANUAL ZEROSSL")"
		echo -e "$(msg -verd "[3]")$(msg -verm2 "➛ ")$(msg -azu "GENERAR CERTIFICADO SSL (Let's Encrypt)")"
		echo -e "$(msg -verd "[4]")$(msg -verm2 "➛ ")$(msg -azu "GENERAR CERTIFICADO SSL (Zerossl Directo)")"
		msg -bar
		echo -ne "\033[1;37mSelecione Una Opcion : "
		read opc
		case $opc in
		1)
			certif
			exit
			;;
		2)
			certificadom
			exit
			;;
		3)
			gerar_cert 1
			exit
			;;
		4)
			gerar_cert 2
			exit
			;;
		esac
		;;
	8)
		clear
		msg -bar
		msg -ama "	START STUNNEL\n	ESTA OPCION ES SOLO SI LLEGA A DETENER EL PUERTO"
		msg -ama
		echo -ne " Desea Continuar? [S/N]: "
		read seg
		[[ $seg = @(n|N) ]] && msg -bar && return
		clear
		#systemctl start stunnel4 &>/dev/null
		#systemctl start stunnel &>/dev/null
		systemctl restart stunnel4 &>/dev/null
		systemctl restart stunnel &>/dev/null
		msg -bar
		msg -verd "	SERVICIOS STUNNEL REINICIADOS"
		msg -bar
		;;
	9)
		clear
		msg -tit
		if [[ ! -z $(crontab -l | grep -w "onssl.sh") ]]; then
			msg -azu " Auto-Inicio SSL programada cada $(msg -verd "[ $(crontab -l | grep -w "onssl.sh" | awk '{print $2}' | sed $'s/[^[:alnum:]\t]//g')HS ]")"
			msg -bar
			while :; do
				echo -ne "$(msg -azu " Detener Auto-Inicio SSL [S/N]: ")" && read yesno
				tput cuu1 && tput dl1
				case $yesno in
				s | S)
					crontab -l >/root/cron && sed -i '/onssl.sh/ d' /root/cron && crontab /root/cron && rm /tmp/st/onssl.sh
					msg -azu " Auto-Inicio SSL Detenida!" && msg -bar && sleep 2
					return 1
					;;
				n | N) return 1 ;;
				*) return 1 ;;
				esac
			done
		fi
		clear
		msg -bar
		msg -ama "	  \e[1;97m\e[2;100mAUTO-INICIAR SSL \e[0m"
		msg -bar
		echo -ne "$(msg -azu "Desea programar El Auto-Inicio SSL [s/n]:") "
		read initio
		if [[ $initio = @(s|S|y|Y) ]]; then
			tput cuu1 && tput dl1
			echo -ne "$(msg -azu " PONGA UN NÚMERO, EJEMPLO [1-12HORAS]:") "
			read initio
			if [[ $initio =~ ^[0-9]+$ ]]; then
				crontab -l >/root/cron
				[[ ! -d /tmp/st ]] && mkdir /tmp/st
				[[ ! -e /tmp/st/onssl.sh ]] && wget -O /tmp/st/onssl.sh https://raw.githubusercontent.com/pedrazadixon/LACASITANULLED/main/onssl.sh &>/dev/null
				chmod 777 /tmp/st/onssl.sh
				echo "0 */$initio * * * bash /tmp/st/onssl.sh" >>/root/cron
				crontab /root/cron

				service cron restart
				rm /root/cron
				tput cuu1 && tput dl1
				msg -azu " Auto-Limpieza programada cada: $(msg -verd "${initio} HORAS")" && msg -bar && sleep 2
			else
				tput cuu1 && tput dl1
				msg -verm2 " ingresar solo numeros entre 1 y 12"
				sleep 2
				msg -bar
			fi
		fi
		return 1
		;;
	10)
		clear
		msg -bar
		msg -ama "	CERTIFICADOS ALMACENADOS de Zerossl\n	QUIERES USAR EL CERTIFICADO DE ZEROSSL?\n  private.key certificate.crt ca_bundle.crt"
		msg -ama
		echo -ne " Desea Continuar? [S/N]: "
		read seg
		[[ $seg = @(n|N) ]] && msg -bar && return
		clear
		cd /etc/stunnel/
		cat private.key certificate.crt ca_bundle.crt >stunnel.pem
		#systemctl start stunnel4 &>/dev/null
		#systemctl start stunnel &>/dev/null
		systemctl restart stunnel4 &>/dev/null
		systemctl restart stunnel &>/dev/null
		msg -bar
		msg -verd "	CERTIFICADO ZEROSSL AGREGADO\n	SERVICIO SSL INICIADO"
		msg -bar
		;;
	esac
}

funpython() {
	clear
	[[ $(dpkg --get-selections | grep -w "python" | head -1) ]] || apt-get install python -y &>/dev/null
	[[ $(dpkg --get-selections | grep -w "python-pip" | head -1) ]] || apt-get install python pip -y &>/dev/null
	[[ $(dpkg --get-selections | grep -w "net-tools" | head -1) ]] || apt-get install net-tools -y &>/dev/null

	#IP=$(wget -qO- ipv4.icanhazip.com)
	tcpbypass_fun() {
		[[ -e $HOME/socks ]] && rm -rf $HOME/socks >/dev/null 2>&1
		[[ -d $HOME/socks ]] && rm -rf $HOME/socks >/dev/null 2>&1
		cd $HOME && mkdir socks >/dev/null 2>&1
		cd socks
		patch="https://raw.githubusercontent.com/pedrazadixon/LACASITANULLED/main/backsocz"
		arq="backsocz"
		wget $patch -o /dev/null
		unzip $arq >/dev/null 2>&1
		mv -f ./ssh /etc/ssh/sshd_config && service ssh restart 1>/dev/null 2>/dev/null
		mv -f sckt$(python3 --version | awk '{print $2}' | cut -d'.' -f1,2) /usr/sbin/sckt
		mv -f scktcheck /bin/scktcheck
		chmod +x /bin/scktcheck
		chmod +x /usr/sbin/sckt
		rm -rf $HOME/socks
		cd $HOME
		msg="$2"
		[[ $msg = "" ]] && msg="@vpsmod"
		portxz="$1"
		[[ $portxz = "" ]] && portxz="8080"
		screen -dmS sokz scktcheck "$portxz" "$msg" >/dev/null 2>&1
	}
	l="/usr/local/lib/sped" && [[ ! -d ${l} ]] && exit
	gettunel_fun() {
		echo "master=NetVPS" >${SCPinst}/pwd.pwd
		while read service; do
			[[ -z $service ]] && break
			echo "127.0.0.1:$(echo $service | cut -d' ' -f2)=$(echo $service | cut -d' ' -f1)" >>${SCPinst}/pwd.pwd
		done <<<"$(mportas)"
		screen -dmS getpy python ${SCPinst}/PGet.py -b "0.0.0.0:$1" -p "${SCPinst}/pwd.pwd"
		[[ "$(ps x | grep "PGet.py" | grep -v "grep" | awk -F "pts" '{print $1}')" ]] && {
			echo -e "Gettunel Iniciado con Sucesso"
			msg -bar
			echo -ne "Su contraseña Gettunel es:"
			echo -e "\033[1;32m NetVPS"
			msg -bar
		} || echo -e "Gettunel no fue iniciado"
		msg -bar
	}

	sistema20() {
		if [[ ! -e /etc/VPS-MX/fix ]]; then
			export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games/
			if apt-get install python -y &>/dev/null; then
				msg -bar
				msg -verd "	SERVICIO PYTHON INSTALADO"
				msg -bar
			else
				msg -bar
				msg -verm2 "	SERVICIO PYTHON FALLIDA"
				msg -bar
				msg -ama "	APLIACANDO FIX"
				msg -bar
				if apt-get install python2 -y &>/dev/null; then
					[[ ! -e /usr/bin/python ]] && ln -s /usr/bin/python2 /usr/bin/python
					msg -verd "	FIX PYTHON APLICADO"
				else
					msg -verm2 "	FIX PYTHON FALLIDA"
				fi
				continue
			fi
			sleep 1.s
			[[ ! -e /etc/VPS-MX/fix ]] && touch /etc/VPS-MX/fix
		else
			echo ""
		fi
	}

	sistema22() {
		if [[ ! -e /etc/VPS-MX/fixer ]]; then
			echo ""
			ins() {
				export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games/
				apt-get install python2 -y
				apt-get install python -y
				apt install python pip -y
				rm -rf /usr/bin/python
				ln -s /usr/bin/python2.7 /usr/bin/python
			}
			ins &>/dev/null && echo -e "INSTALANDO FIX" | pv -qL 40
			sleep 1.s
			[[ ! -e /etc/VPS-MX/fixer ]] && touch /etc/VPS-MX/fixer
		else
			echo ""
		fi
	}

	PythonDic_fun() {

		clear
		echo ""
		echo ""
		msg -tit
		msg -bar
		echo -e "\033[1;31m  SOCKS DIRECTO-PY | CUSTOM\033[0m"
		while true; do
			msg -bar
			echo -ne "\033[1;37m"
			read -p " ESCRIBE SU PUERTO: " porta_socket
			tput cuu1 && tput dl1
			if [[ -z $porta_socket ]]; then
				porta_socket='80'
				echo -e "	\e[31mPuerto Default: \033[1;32m${porta_socket} "
			else
				echo -e "	\e[31mPuerto: \033[1;32m ${porta_socket}"
			fi
			echo -e ""
			[[ $(mportas | grep -w "$porta_socket") ]] || break
			echo -e " ESTE PUERTO YA ESTÁ EN USO"
			unset porta_socket
		done
		msg -bar
		echo -e "\033[1;97m Digite Un Puerto Local 22|443|80\033[1;37m"
		msg -bar
		while true; do
			echo -ne "\033[1;36m"
			read -p " Digite Un Puerto SSH/DROPBEAR activo: " PORTLOC
			tput cuu1 && tput dl1
			if [[ -z $PORTLOC ]]; then
				PORTLOC='22'
				echo -e "	\e[31mLocal Default: \033[1;32m${PORTLOC} "
			else
				echo -e "	\e[31mLocal: \033[1;32m ${PORTLOC}"
			fi
			echo -e ""
			if [[ ! -z $PORTLOC ]]; then
				if [[ $(echo $PORTLOC | grep [0-9]) ]]; then
					[[ $(mportas | grep $PORTLOC | head -1) ]] && break || echo -e "ESTE PUERTO NO EXISTE"
				fi
			fi
		done
		#
		puertoantla="$(mportas | grep $PORTLOC | awk '{print $2}' | head -1)"
		msg -bar
		echo -ne " Escribe El HTTP Response? 101|200|300: \033[1;37m" && read cabezado
		tput cuu1 && tput dl1
		if [[ -z $cabezado ]]; then
			cabezado="101"
			echo -e "	\e[31mResponse Default:\033[1;32m ${cabezado}"
		else
			echo -e "	\e[31mResponse Elegido:\033[1;32m ${cabezado}"
		fi
		msg -bar
		echo -e "$(fun_trans "Introdusca su Mini-Banner")"
		msg -bar
		echo -ne " Introduzca el texto de estado plano o en HTML:\n \033[1;37m" && read texto_soket
		tput cuu1 && tput dl1
		if [[ -z $texto_soket ]]; then
			texto_soket="@lacasitamx"
			echo -e "	\e[31mMensage Default: \033[1;32m${texto_soket} "
		else
			echo -e "	\e[31mMensage: \033[1;32m ${texto_soket}"
		fi
		msg -bar

		(
			less <<CPM >/etc/VPS-MX/protocolos/PDirect.py
import socket, threading, thread, select, signal, sys, time, getopt

# Listen
LISTENING_ADDR = '0.0.0.0'
LISTENING_PORT = int("$porta_socket")
PASS = ''

# CONST
BUFLEN = 4096 * 4
TIMEOUT = 60
DEFAULT_HOST = '127.0.0.1:$puertoantla'
RESPONSE = 'HTTP/1.1 $cabezado <span style="color: #9ffff;"><strong>$texto_soket</strong></span>\r\nConnection: Upgrade\r\nUpgrade: websocket\r\n\r\nHTTP/1.1 200 Connection Established\r\n\r\n'

class Server(threading.Thread):
    def __init__(self, host, port):
        threading.Thread.__init__(self)
        self.running = False
        self.host = host
        self.port = port
        self.threads = []
        self.threadsLock = threading.Lock()
        self.logLock = threading.Lock()
    def run(self):
        self.soc = socket.socket(socket.AF_INET)
        self.soc.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.soc.settimeout(2)
        self.soc.bind((self.host, self.port))
        self.soc.listen(0)
        self.running = True
        try:
            while self.running:
                try:
                    c, addr = self.soc.accept()
                    c.setblocking(1)
                except socket.timeout:
                    continue
                conn = ConnectionHandler(c, self, addr)
                conn.start()
                self.addConn(conn)
        finally:
            self.running = False
            self.soc.close()
    def printLog(self, log):
        self.logLock.acquire()
        print log
        self.logLock.release()
    def addConn(self, conn):
        try:
            self.threadsLock.acquire()
            if self.running:
                self.threads.append(conn)
        finally:
            self.threadsLock.release()
    def removeConn(self, conn):
        try:
            self.threadsLock.acquire()
            self.threads.remove(conn)
        finally:
            self.threadsLock.release()
    def close(self):
        try:
            self.running = False
            self.threadsLock.acquire()
            threads = list(self.threads)
            for c in threads:
                c.close()
        finally:
            self.threadsLock.release()
class ConnectionHandler(threading.Thread):
    def __init__(self, socClient, server, addr):
        threading.Thread.__init__(self)
        self.clientClosed = False
        self.targetClosed = True
        self.client = socClient
        self.client_buffer = ''
        self.server = server
        self.log = 'Connection: ' + str(addr)
    def close(self):
        try:
            if not self.clientClosed:
                self.client.shutdown(socket.SHUT_RDWR)
                self.client.close()
        except:
            pass
        finally:
            self.clientClosed = True
        try:
            if not self.targetClosed:
                self.target.shutdown(socket.SHUT_RDWR)
                self.target.close()
        except:
            pass
        finally:
            self.targetClosed = True
    def run(self):
        try:
            self.client_buffer = self.client.recv(BUFLEN)
            hostPort = self.findHeader(self.client_buffer, 'X-Real-Host')
            if hostPort == '':
                hostPort = DEFAULT_HOST
            split = self.findHeader(self.client_buffer, 'X-Split')
            if split != '':
                self.client.recv(BUFLEN)
            if hostPort != '':
                passwd = self.findHeader(self.client_buffer, 'X-Pass')
				
                if len(PASS) != 0 and passwd == PASS:
                    self.method_CONNECT(hostPort)
                elif len(PASS) != 0 and passwd != PASS:
                    self.client.send('HTTP/1.1 400 WrongPass!\r\n\r\n')
                elif hostPort.startswith('127.0.0.1') or hostPort.startswith('localhost'):
                    self.method_CONNECT(hostPort)
                else:
                    self.client.send('HTTP/1.1 403 Forbidden!\r\n\r\n')
            else:
                print '- No X-Real-Host!'
                self.client.send('HTTP/1.1 400 NoXRealHost!\r\n\r\n')
        except Exception as e:
            self.log += ' - error: ' + e.strerror
            self.server.printLog(self.log)
	    pass
        finally:
            self.close()
            self.server.removeConn(self)
    def findHeader(self, head, header):
        aux = head.find(header + ': ')
        if aux == -1:
            return ''
        aux = head.find(':', aux)
        head = head[aux+2:]
        aux = head.find('\r\n')
        if aux == -1:
            return ''
        return head[:aux];
    def connect_target(self, host):
        i = host.find(':')
        if i != -1:
            port = int(host[i+1:])
            host = host[:i]
        else:
            if self.method=='CONNECT':
            	
                port = 443
            else:
                port = 80
                port = 8080
                port = 8799
                port = 3128
        (soc_family, soc_type, proto, _, address) = socket.getaddrinfo(host, port)[0]
        self.target = socket.socket(soc_family, soc_type, proto)
        self.targetClosed = False
        self.target.connect(address)
    def method_CONNECT(self, path):
        self.log += ' - CONNECT ' + path
        self.connect_target(path)
        self.client.sendall(RESPONSE)
        self.client_buffer = ''
        self.server.printLog(self.log)
        self.doCONNECT()
    def doCONNECT(self):
        socs = [self.client, self.target]
        count = 0
        error = False
        while True:
            count += 1
            (recv, _, err) = select.select(socs, [], socs, 3)
            if err:
                error = True
            if recv:
                for in_ in recv:
		    try:
                        data = in_.recv(BUFLEN)
                        if data:
			    if in_ is self.target:
				self.client.send(data)
                            else:
                                while data:
                                    byte = self.target.send(data)
                                    data = data[byte:]
                            count = 0
			else:
			    break
		    except:
                        error = True
                        break
            if count == TIMEOUT:
                error = True
            if error:
                break
def main(host=LISTENING_ADDR, port=LISTENING_PORT):
    print "\n:-------PythonProxy-------:\n"
    print "Listening addr: " + LISTENING_ADDR
    print "Listening port: " + str(LISTENING_PORT) + "\n"
    print ":-------------------------:\n"
    server = Server(LISTENING_ADDR, LISTENING_PORT)
    server.start()
    while True:
        try:
            time.sleep(2)
        except KeyboardInterrupt:
            print 'Stopping...'
            server.close()
            break
if __name__ == '__main__':
    main()
CPM
		) >$HOME/proxy.log &

		chmod +x /etc/VPS-MX/protocolos/PDirect.py
		#screen -dmS wsla python ${SCPinst}/PDirect.py $porta_socket $texto_soket &
		#screen -dmS pydic-"$porta_socket" python ${SCPinst}/PDirect.py "$porta_socket" "$texto_soket" && echo ""$porta_socket" "$texto_soket"" >> /etc/VPS-MX/PortPD.log
		echo "$porta_socket" >/etc/VPS-MX/.ppython.txt
		echo "$porta_socket $texto_soket" >/etc/VPS-MX/PortPD.log
		echo -e "[Unit]
Description=wsla by lacasitamx Service
After=network.target
StartLimitIntervalSec=0

[Service]
Type=simple
User=root
WorkingDirectory=/root
ExecStart=/usr/bin/python ${SCPinst}/PDirect.py $porta_socket $texto_soket
Restart=always
RestartSec=3s

[Install]
WantedBy=multi-user.target" >/etc/systemd/system/wsla.service

		systemctl enable wsla &>/dev/null
		systemctl start wsla &>/dev/null
		systemctl restart wsla &>/dev/null

	}

	pythontest() {
		clear
		echo ""
		echo ""
		msg -tit
		msg -bar
		echo -e "\033[1;31m  SOCKS DIRECTO-PY | CUSTOM\033[0m"
		while true; do
			msg -bar
			echo -ne "\033[1;37m"
			read -p " ESCRIBE SU PUERTO: " porta_socket
			echo -e ""
			[[ $(mportas | grep -w "$porta_socket") ]] || break
			echo -e " ESTE PUERTO YA ESTÁ EN USO"
			unset porta_socket
		done
		msg -bar
		echo -e "\033[1;97m Digite Un Puerto Local 22|443|80\033[1;37m"
		msg -bar
		while true; do
			echo -ne "\033[1;36m"
			read -p " Digite Un Puerto SSH/DROPBEAR activo: " PORTLOC
			echo -e ""
			if [[ ! -z $PORTLOC ]]; then
				if [[ $(echo $PORTLOC | grep [0-9]) ]]; then
					[[ $(mportas | grep $PORTLOC | head -1) ]] && break || echo -e "ESTE PUERTO NO EXISTE"
				fi
			fi
		done
		#
		puertoantla="$(mportas | grep $PORTLOC | awk '{print $2}' | head -1)"
		msg -bar
		echo -ne " Escribe El HTTP Response? 101|200|300: \033[1;37m" && read cabezado
		tput cuu1 && tput dl1
		if [[ -z $cabezado ]]; then
			cabezado="101"
			echo -e "	\e[31mResponse Default:\033[1;32m ${cabezado}"
		else
			echo -e "	\e[31mResponse Elegido:\033[1;32m ${cabezado}"
		fi
		msg -bar
		echo -e "$(fun_trans "Introdusca su Mini-Banner")"
		msg -bar
		echo -ne " Introduzca el texto de estado plano o en HTML:\n \033[1;37m" && read texto_soket
		tput cuu1 && tput dl1
		if [[ -z $texto_soket ]]; then
			texto_soket="@lacasitamx"
			echo -e "	\e[31mMensage Default: \033[1;32m${texto_soket} "
		else
			echo -e "	\e[31mMensage: \033[1;32m ${texto_soket}"
		fi
		msg -bar

		(
			less <<CPM >/etc/VPS-MX/protocolos/python.py
import socket, threading, thread, select, signal, sys, time, getopt

# Listen
LISTENING_ADDR = '0.0.0.0'
LISTENING_PORT = int("$porta_socket")
PASS = ''

# CONST
BUFLEN = 4096 * 4
TIMEOUT = 60
DEFAULT_HOST = '127.0.0.1:$puertoantla'
RESPONSE = 'HTTP/1.1 $cabezado <span style="color: #9ffff;"><strong>$texto_soket</strong></span>\r\nConnection: Upgrade\r\nUpgrade: websocket\r\n\r\nHTTP/1.1 200 Connection Established\r\n\r\n'

class Server(threading.Thread):
    def __init__(self, host, port):
        threading.Thread.__init__(self)
        self.running = False
        self.host = host
        self.port = port
        self.threads = []
        self.threadsLock = threading.Lock()
        self.logLock = threading.Lock()
    def run(self):
        self.soc = socket.socket(socket.AF_INET)
        self.soc.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.soc.settimeout(2)
        self.soc.bind((self.host, self.port))
        self.soc.listen(0)
        self.running = True
        try:
            while self.running:
                try:
                    c, addr = self.soc.accept()
                    c.setblocking(1)
                except socket.timeout:
                    continue
                conn = ConnectionHandler(c, self, addr)
                conn.start()
                self.addConn(conn)
        finally:
            self.running = False
            self.soc.close()
    def printLog(self, log):
        self.logLock.acquire()
        print log
        self.logLock.release()
    def addConn(self, conn):
        try:
            self.threadsLock.acquire()
            if self.running:
                self.threads.append(conn)
        finally:
            self.threadsLock.release()
    def removeConn(self, conn):
        try:
            self.threadsLock.acquire()
            self.threads.remove(conn)
        finally:
            self.threadsLock.release()
    def close(self):
        try:
            self.running = False
            self.threadsLock.acquire()
            threads = list(self.threads)
            for c in threads:
                c.close()
        finally:
            self.threadsLock.release()
class ConnectionHandler(threading.Thread):
    def __init__(self, socClient, server, addr):
        threading.Thread.__init__(self)
        self.clientClosed = False
        self.targetClosed = True
        self.client = socClient
        self.client_buffer = ''
        self.server = server
        self.log = 'Connection: ' + str(addr)
    def close(self):
        try:
            if not self.clientClosed:
                self.client.shutdown(socket.SHUT_RDWR)
                self.client.close()
        except:
            pass
        finally:
            self.clientClosed = True
        try:
            if not self.targetClosed:
                self.target.shutdown(socket.SHUT_RDWR)
                self.target.close()
        except:
            pass
        finally:
            self.targetClosed = True
    def run(self):
        try:
            self.client_buffer = self.client.recv(BUFLEN)
            hostPort = self.findHeader(self.client_buffer, 'X-Real-Host')
            if hostPort == '':
                hostPort = DEFAULT_HOST
            split = self.findHeader(self.client_buffer, 'X-Split')
            if split != '':
                self.client.recv(BUFLEN)
            if hostPort != '':
                passwd = self.findHeader(self.client_buffer, 'X-Pass')
				
                if len(PASS) != 0 and passwd == PASS:
                    self.method_CONNECT(hostPort)
                elif len(PASS) != 0 and passwd != PASS:
                    self.client.send('HTTP/1.1 400 WrongPass!\r\n\r\n')
                elif hostPort.startswith('127.0.0.1') or hostPort.startswith('localhost'):
                    self.method_CONNECT(hostPort)
                else:
                    self.client.send('HTTP/1.1 403 Forbidden!\r\n\r\n')
            else:
                print '- No X-Real-Host!'
                self.client.send('HTTP/1.1 400 NoXRealHost!\r\n\r\n')
        except Exception as e:
            self.log += ' - error: ' + e.strerror
            self.server.printLog(self.log)
	    pass
        finally:
            self.close()
            self.server.removeConn(self)
    def findHeader(self, head, header):
        aux = head.find(header + ': ')
        if aux == -1:
            return ''
        aux = head.find(':', aux)
        head = head[aux+2:]
        aux = head.find('\r\n')
        if aux == -1:
            return ''
        return head[:aux];
    def connect_target(self, host):
        i = host.find(':')
        if i != -1:
            port = int(host[i+1:])
            host = host[:i]
        else:
            if self.method=='CONNECT':
            	
                port = 443
            else:
                port = 80
                port = 8080
                port = 8799
                port = 3128
        (soc_family, soc_type, proto, _, address) = socket.getaddrinfo(host, port)[0]
        self.target = socket.socket(soc_family, soc_type, proto)
        self.targetClosed = False
        self.target.connect(address)
    def method_CONNECT(self, path):
        self.log += ' - CONNECT ' + path
        self.connect_target(path)
        self.client.sendall(RESPONSE)
        self.client_buffer = ''
        self.server.printLog(self.log)
        self.doCONNECT()
    def doCONNECT(self):
        socs = [self.client, self.target]
        count = 0
        error = False
        while True:
            count += 1
            (recv, _, err) = select.select(socs, [], socs, 3)
            if err:
                error = True
            if recv:
                for in_ in recv:
		    try:
                        data = in_.recv(BUFLEN)
                        if data:
			    if in_ is self.target:
				self.client.send(data)
                            else:
                                while data:
                                    byte = self.target.send(data)
                                    data = data[byte:]
                            count = 0
			else:
			    break
		    except:
                        error = True
                        break
            if count == TIMEOUT:
                error = True
            if error:
                break
def main(host=LISTENING_ADDR, port=LISTENING_PORT):
    print "\n:-------PythonProxy-------:\n"
    print "Listening addr: " + LISTENING_ADDR
    print "Listening port: " + str(LISTENING_PORT) + "\n"
    print ":-------------------------:\n"
    server = Server(LISTENING_ADDR, LISTENING_PORT)
    server.start()
    while True:
        try:
            time.sleep(2)
        except KeyboardInterrupt:
            print 'Stopping...'
            server.close()
            break
if __name__ == '__main__':
    main()
CPM
		) >$HOME/proxy.log &

		chmod +x /etc/VPS-MX/protocolos/python.py
		echo -e "[Unit]\nDescription=python.py Service by @lacasitamx\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nUser=root\nWorkingDirectory=/root\nExecStart=/usr/bin/python ${SCPinst}/python.py $porta_socket $texto_soket\nRestart=always\nRestartSec=3s\n[Install]\nWantedBy=multi-user.target" >/etc/systemd/system/python.PD.service
		echo "$porta_socket $texto_soket" >/etc/VPS-MX/PortPD.log
		echo "$porta_socket" >/etc/VPS-MX/.ppython.txt
		systemctl enable python.PD &>/dev/null
		systemctl start python.PD &>/dev/null

	}

	pid_kill() {
		[[ -z $1 ]] && refurn 1
		pids="$@"
		for pid in $(echo $pids); do
			kill -9 $pid &>/dev/null
		done
	}
	selecionador() {
		clear
		echo ""
		echo ""
		echo ""
		while true; do
			msg -bar
			echo -ne "\033[1;37m"
			read -p " ESCRIBE SU PUERTO: " porta_socket
			echo -e ""
			[[ $(mportas | grep -w "$porta_socket") ]] || break
			echo -e " ESTE PUERTO YA ESTÁ EN USO"
			unset porta_socket
		done
		echo -e "Introdusca su Mini-Banner"
		msg -bar
		echo -ne "Introduzca el texto de estado plano o en HTML:\n \033[1;37m" && read texto_soket
		msg -bar
	}
	remove_fun() {
		echo -e "Parando Socks Python"
		msg -bar
		pidproxy=$(ps x | grep "PPub.py" | grep -v "grep" | awk -F "pts" '{print $1}') && [[ ! -z $pidproxy ]] && pid_kill $pidproxy
		pidproxy2=$(ps x | grep "PPriv.py" | grep -v "grep" | awk -F "pts" '{print $1}') && [[ ! -z $pidproxy2 ]] && pid_kill $pidproxy2
		pidproxy3=$(ps x | grep "PDirect.py" | grep -v "grep" | awk -F "pts" '{print $1}') && [[ ! -z $pidproxy3 ]] && pid_kill $pidproxy3
		pidproxy4=$(ps x | grep "POpen.py" | grep -v "grep" | awk -F "pts" '{print $1}') && [[ ! -z $pidproxy4 ]] && pid_kill $pidproxy4
		pidproxy5=$(ps x | grep "PGet.py" | grep -v "grep" | awk -F "pts" '{print $1}') && [[ ! -z $pidproxy5 ]] && pid_kill $pidproxy5
		pidproxy6=$(ps x | grep "scktcheck" | grep -v "grep" | awk -F "pts" '{print $1}') && [[ ! -z $pidproxy6 ]] && pid_kill $pidproxy6
		pidproxy7=$(ps x | grep "python.py" | grep -v "grep" | awk -F "pts" '{print $1}') && [[ ! -z $pidproxy7 ]] && pid_kill $pidproxy7
		pidproxy8=$(ps x | grep "lacasitamx.py" | grep -v "grep" | awk -F "pts" '{print $1}') && [[ ! -z $pidproxy8 ]] && pid_kill $pidproxy8

		rm /etc/VPS-MX/PortPD.log &>/dev/null
		echo "" >/etc/VPS-MX/PortPD.log

		systemctl stop wsla &>/dev/null
		systemctl disable wsla &>/dev/null
		rm /etc/systemd/system/wsla.service &>/dev/null

		systemctl stop python.PD &>/dev/null
		systemctl disable python.PD &>/dev/null
		rm /etc/systemd/system/python.PD.service &>/dev/null
		rm /etc/VPS-MX/.ppython.txt &>/dev/null
		msg -bar
		echo -e "\033[1;91mSocks DETENIDOS"
		msg -bar

	}
	wsocks() {
		clear
		echo ""
		echo ""
		msg -tit
		msg -bar
		echo -e "\033[1;31m  WS-EPRO | CUSTOM\033[0m"
		while true; do
			msg -bar
			echo -ne "\033[1;37m"
			read -p " ESCRIBE SU PUERTO: " porta_socket
			echo -e ""
			[[ $(mportas | grep -w "$porta_socket") ]] || break
			echo -e " ESTE PUERTO YA ESTÁ EN USO"
			unset porta_socket
		done
		msg -bar
		echo -e "\033[1;97m Digite Un Puerto Local 22|443|80\033[1;37m"
		msg -bar
		while true; do
			echo -ne "\033[1;36m"
			read -p " Digite Un Puerto SSH/DROPBEAR activo: " PORTLOC
			echo -e ""
			if [[ ! -z $PORTLOC ]]; then
				if [[ $(echo $PORTLOC | grep [0-9]) ]]; then
					[[ $(mportas | grep $PORTLOC | head -1) ]] && break || echo -e "ESTE PUERTO NO EXISTE"
				fi
			fi
		done
		#
		puertoantla="$(mportas | grep $PORTLOC | awk '{print $2}' | head -1)"
		msg -bar
		msg -verd "	espere un momento"

		wget -O /bin/ws-epro https://raw.githubusercontent.com/pedrazadixon/LACASITANULLED/main/SCRIPTMOD/Reiniciar/reboot &>/dev/null
		chmod +x /bin/ws-epro

		sleep 1
		#
		WS_DIR=/usr/local/etc/ws-epro
		mkdir "$WS_DIR" &>/dev/null
		#echo "Procesing to server..."
		sleep 0.5
		echo "# verbose level 0=info, 1=verbose, 2=very verbose
verbose: 0
listen:
#wbsocket
- target_host: 127.0.0.1
#puertolocal
  target_port: ${puertoantla}
  #puertoescucha
  listen_port: ${porta_socket}" >/usr/local/etc/ws-epro/config.yml

		chmod +x /usr/local/etc/ws-epro/config.yml

		echo -e "[Unit]
Description=ws-epro Parametizado Service
After=network.target
StartLimitIntervalSec=0

[Service]
Type=simple
User=root
WorkingDirectory=/root
ExecStart=/bin/ws-epro -f /usr/local/etc/ws-epro/config.yml
Restart=always
RestartSec=3s

[Install]
WantedBy=multi-user.target" >/etc/systemd/system/ws-epro.service

		systemctl enable ws-epro &>/dev/null
		systemctl start ws-epro &>/dev/null
		systemctl restart ws-epro &>/dev/null

	}

	unws() {
		clear

		pkill -f ws-epro

		systemctl stop ws-epro &>/dev/null
		systemctl disable ws-epro &>/dev/null
		rm /usr/local/bin/ws-epro &>/dev/null
		rm /etc/systemd/system/ws-epro.service &>/dev/null
		rm /usr/bin/ws-port &>/dev/null

		msg -bar
		echo -e "\033[1;91mWS Directo DETENIDO"
		msg -bar

	}

	addws() {
		clear
		echo ""
		echo ""
		msg -tit
		msg -bar
		echo -e "\033[1;31m  WS-EPRO+ | CUSTOM\033[0m"
		while true; do
			msg -bar
			echo -ne "\033[1;37m"
			read -p " ESCRIBE SU PUERTO: " porta_socket
			echo -e ""
			[[ $(mportas | grep -w "$porta_socket") ]] || break
			echo -e " ESTE PUERTO YA ESTÁ EN USO"
			unset porta_socket
		done
		msg -bar
		echo -e "\033[1;97m Digite Un Puerto Local 22|443|80\033[1;37m"
		msg -bar
		while true; do
			echo -ne "\033[1;36m"
			read -p " Digite Un Puerto SSH/DROPBEAR activo: " PORTLOC
			echo -e ""
			if [[ ! -z $PORTLOC ]]; then
				if [[ $(echo $PORTLOC | grep [0-9]) ]]; then
					[[ $(mportas | grep $PORTLOC | head -1) ]] && break || echo -e "ESTE PUERTO NO EXISTE"
				fi
			fi
		done
		#
		puertoantla="$(mportas | grep $PORTLOC | awk '{print $2}' | head -1)"
		msg -bar
		systemctl stop ws-epro &>/dev/null
		echo "#+
- target_host: 127.0.0.1
#puertolocal
  target_port: ${puertoantla}
  #puertoescucha
  listen_port: ${porta_socket}" >>/usr/local/etc/ws-epro/config.yml
		systemctl start ws-epro &>/dev/null
		systemctl restart ws-epro &>/dev/null
	}
	menuws() {
		clear
		[[ $(ps x | grep ws-epro | grep -v grep) ]] && P8="\033[1;32m[ON]" || P8="\e[37m[\033[1;31mOFF\e[37m]"

		msg -tit
		msg -bar
		echo -e "   	\e[91m\e[43mINSTALADOR WS-EPRO CUSTOM\e[0m "
		msg -bar
		echo -e " \e[1;93m[\e[92m1\e[93m] \e[97m$(msg -verm2 "➛ ")\033[1;97mINSTALAR SERVICIO WS-EPRO $P8"
		echo -e " \e[1;93m[\e[92m2\e[93m] \e[97m$(msg -verm2 "➛ ")\033[1;97mAGREGAR + PUERTOS WS-EPRO"
		echo -e " \e[1;93m[\e[92m3\e[93m] \e[97m$(msg -verm2 "➛ ")\033[1;97mDESINSTALAR WS-EPRO"
		echo -e " \e[1;93m[\e[92m0\e[93m] \e[97m$(msg -verm2 "➛ ")\033[1;97mVOLVER"
		msg -bar
		echo -ne " Digite Una Opcion :\033[1;37m "
		read portproxy
		case $portproxy in
		1) wsocks ;;
		2) addws ;;
		3) unws ;;

		esac
	}

	pidproxy=$(ps x | grep -w "PPub.py" | grep -v "grep" | awk -F "pts" '{print $1}') && [[ ! -z $pidproxy ]] && P1="\033[1;32m[ON]" || P1="\e[37m[\033[1;31mOFF\e[37m]"
	pidproxy2=$(ps x | grep -w "PPriv.py" | grep -v "grep" | awk -F "pts" '{print $1}') && [[ ! -z $pidproxy2 ]] && P2="\033[1;32m[ON]" || P2="\e[37m[\033[1;31mOFF\e[37m]"
	pidproxy3=$(ps x | grep -w "PDirect.py" | grep -v "grep" | awk -F "pts" '{print $1}') && [[ ! -z $pidproxy3 ]] && P3="\033[1;32m[ON]" || P3="\e[37m[\033[1;31mOFF\e[37m]"
	pidproxy4=$(ps x | grep -w "POpen.py" | grep -v "grep" | awk -F "pts" '{print $1}') && [[ ! -z $pidproxy4 ]] && P4="\033[1;32m[ON]" || P4="\e[37m[\033[1;31mOFF\e[37m]"

	pidproxy5=$(ps x | grep "PGet.py" | grep -v "grep" | awk -F "pts" '{print $1}') && [[ ! -z $pidproxy5 ]] && P5="\033[1;32m[ON]" || P5="\e[37m[\033[1;31mOFF\e[37m]"
	pidproxy6=$(ps x | grep "scktcheck" | grep -v "grep" | awk -F "pts" '{print $1}') && [[ ! -z $pidproxy6 ]] && P6="\033[1;32m[ON]" || P6="\e[37m[\033[1;31mOFF\e[37m]"
	pidproxy7=$(ps x | grep "python.py" | grep -v "grep" | awk -F "pts" '{print $1}') && [[ ! -z $pidproxy7 ]] && P7="\033[1;32m[ON]" || P7="\e[37m[\033[1;31mOFF\e[37m]"
	[[ $(ps x | grep ws-epro | grep -v grep) ]] && P8="\033[1;32m[ON]" || P8="\e[37m[\033[1;31mOFF\e[37m]"

	#msg -bar
	msg -tit
	msg -bar
	echo -e "   	\e[91m\e[43mINSTALADOR DE PROXY'S\e[0m "
	msg -bar
	echo -e " \e[1;93m[\e[92m1\e[93m] \e[97m$(msg -verm2 "➛ ")\033[1;97mProxy Python SIMPLE      $P1"
	echo -e " \e[1;93m[\e[92m2\e[93m] \e[97m$(msg -verm2 "➛ ")\033[1;97mProxy Python SEGURO      $P2"
	echo -e " \e[1;93m[\e[92m3\e[93m] \e[97m$(msg -verm2 "➛ ")\033[1;97mProxy WEBSOCKET Custom   $P3 \e[1;32m(Socks HTTP)"
	echo -e " \e[1;93m[\e[92m4\e[93m] \e[97m$(msg -verm2 "➛ ")\033[1;97mProxy WEBSOCKET Custom   $P7 \e[1;33m(SYSTEMCTL)"
	echo -e " \e[1;93m[\e[92m5\e[93m] \e[97m$(msg -verm2 "➛ ")\033[1;97mWS DIRECTO  HTTPCustom   $P8 \e[1;32m(WS)"
	echo -e " \e[1;93m[\e[92m6\e[93m] \e[97m$(msg -verm2 "➛ ")\033[1;97mProxy Python OPENVPN     $P4"
	echo -e " \e[1;93m[\e[92m7\e[93m] \e[97m$(msg -verm2 "➛ ")\033[1;97mProxy Python GETTUNEL    $P5"
	echo -e " \e[1;93m[\e[92m8\e[93m] \e[97m$(msg -verm2 "➛ ")\033[1;97mProxy Python TCP BYPASS  $P6"
	echo -e " \e[1;93m[\e[92m9\e[93m] \e[97m$(msg -verm2 "➛ ")\033[1;97mAplicar Fix en \e[1;32m(Ubu22 o Debian11 )"
	echo -e " \e[1;93m[\e[92m10\e[93m] \e[97m$(msg -verm2 "➛ ")\033[1;97mDETENER SERVICIO PYTHON"
	msg -bar
	echo -e " \e[1;93m[\e[92m0\e[93m] \e[97m$(msg -verm2 "➛ ") \e[97m\033[1;41m VOLVER \033[1;37m"
	msg -bar
	#IP=(meu_ip)
	echo -ne " Digite Una Opcion (recomendado 3):\033[1;37m "
	read portproxy
	case $portproxy in
	1)
		selecionador
		screen -dmS screen python ${SCPinst}/PPub.py "$porta_socket" "$texto_soket"
		;;
	2)
		selecionador
		screen -dmS screen python3 ${SCPinst}/PPriv.py "$porta_socket" "$texto_soket" "$IP"
		;;
	3)
		PIDI="$(ps aux | grep -v grep | grep "wsla")"
		if [[ -z $PIDI ]]; then
			sistema20
			PythonDic_fun
		else
			systemctl stop wsla &>/dev/null
			systemctl disable wsla &>/dev/null
			rm /etc/systemd/system/wsla.service &>/dev/null

			rm /etc/VPS-MX/.ppython.txt &>/dev/null
			msg -bar
			echo -e "\033[1;91mSocks Directo DETENIDO"
			msg -bar

		fi
		;;
	4)
		if [[ ! -e /etc/systemd/system/python.PD.service ]]; then
			sistema20
			pythontest
		else
			systemctl stop python.PD &>/dev/null
			systemctl disable python.PD &>/dev/null
			rm /etc/systemd/system/python.PD.service &>/dev/null

			rm /etc/VPS-MX/.ppython.txt &>/dev/null
			msg -bar
			echo -e "\033[1;91mSocks Directo DETENIDO"
			msg -bar

		fi
		;;
	5) menuws ;;
	6)
		selecionador
		screen -dmS screen python ${SCPinst}/POpen.py "$porta_socket" "$texto_soket"
		;;
	7)
		selecionador
		gettunel_fun "$porta_socket"
		;;
	8)
		selecionador
		tcpbypass_fun "$porta_socket" "$texto_soket"
		;;
	9)
		sistema22
		msg -bar
		msg -ama " AHORA REGRESA EN LA OPCION 3 DE SOCKS HTTP"
		msg -bar

		;;
	10) remove_fun ;;

	esac
	echo -e "\033[1;92mProcedimiento COMPLETO"
	msg -bar
}

funshadow() {
	config="/etc/shadowsocks-libev/config.json"
	#
	del_shadowsocks() {
		[[ -e /etc/shadowsocks-libev/config.json ]] && {
			[[ $(ps ax | grep ss-server | grep -v grep | awk '{print $1}') != "" ]] && kill -9 $(ps ax | grep ss-server | grep -v grep | awk '{print $1}') >/dev/null 2>&1 && ss-server -c /etc/shadowsocks-libev/config.json -d stop >/dev/null 2>&1
			echo -e "\033[1;33m	SHADOWSOCKS LIBEV DETENIDO"
			msg -bar
			rm /etc/shadowsocks-libev/config.json
			rm -rf Instalador-libev.sh Instalador-libev.log shadowsocks_libev_qr.png
			rm -rf Instalador-libev.sh Instalador-libev.log
			return 0
		}
	}

	[[ $(ps ax | grep ss-server | grep -v grep | awk '{print $1}') ]] && ss="\e[92m[ ON ]" || ss="\e[91m[ OFF ]"
	clear
	msg -bar
	msg -tit
	echo -e "       \e[91m\e[43mINSTALADOR SHADOWSOCKS-LIBEV+(obfs)\e[0m "
	msg -bar
	echo -e "$(msg -verd "[1]")$(msg -verm2 "➛ ")$(msg -azu "INSTALAR SHADOWSOCKS LIBEV") $ss"
	echo -e "$(msg -verd "[2]")$(msg -verm2 "➛ ")$(msg -azu "DESINSTALAR SHADOWSOCKS LIBEV")"
	echo -e "$(msg -verd "[3]")$(msg -verm2 "➛ ")$(msg -azu "VER CONFI LIBEV")"
	echo -e "$(msg -verd "[4]")$(msg -verm2 "➛ ")$(msg -azu "MODIFICAR CONFIGURACION (nano)")"
	echo -e "$(msg -verd "[0]")$(msg -verm2 "➛ ")$(msg -azu "VOLVER")"
	msg -bar
	echo -n " Selecione Una Opcion: "
	read opcao
	case $opcao in

	1)
		clear
		msg -bar
		wget --no-check-certificate -O Instalador-libev.sh https://raw.githubusercontent.com/pedrazadixon/LACASITANULLED/main/ZETA/sha/Instalador-libev.sh >/dev/null 2>&1
		chmod +x Instalador-libev.sh
		./Instalador-libev.sh 2>&1 | tee Instalador-libev.log
		value=$(ps ax | grep ss-server | grep -v grep)
		[[ $value != "" ]] && value="\033[1;32mINICIADO CON EXITO" || value="\033[1;31mERROR"
		msg -bar
		echo -e "${value}"
		msg -bar
		;;
	2)
		clear
		msg -bar
		echo -e "\033[1;93m  Desinstalar  ..."
		del_shadowsocks
		msg -bar
		wget --no-check-certificate -O Instalador-libev.sh https://raw.githubusercontent.com/pedrazadixon/LACASITANULLED/main/ZETA/sha/Instalador-libev.sh >/dev/null 2>&1
		chmod +x Instalador-libev.sh
		./Instalador-libev.sh uninstall &>/dev/null
		rm -rf Instalador-libev.sh Instalador-libev.log shadowsocks_libev_qr.png &>/dev/null

		msg -bar
		sleep 3
		return 0
		;;
	3)
		clear
		msg -bar
		msg -ama " VER CONFIGURACION"
		msg -bar
		if [[ ! -e ${config} ]]; then
			msg -verm " NO HAY INFORMACION"
		else
			cat /etc/shadowsocks-libev/confis
			msg -bar
		fi
		;;
	4)
		clear
		msg -bar
		msg -ama " MODIFICAR CONFIGURACION"
		msg -bar

		if [[ ! -e ${config} ]]; then
			msg -verm " NO HAY INFORMACION"
		else
			msg -verd " para guardar la confi precione ( crtl + x )"
			read -p " enter para continuar"
			nano ${config}
			msg -bar
			/etc/init.d/shadowsocks-libev restart
			msg -bar
		fi
		;;
	esac
}

funbadvpn() {
	unistall() {
		msg -bar
		msg -tit
		msg -ama "          DESACTIVADOR DE BADVPN (UDP)"
		msg -bar

		systemctl stop badvpn &>/dev/null
		systemctl disable badvpn &>/dev/null
		rm -rf /etc/systemd/system/badvpn.service

		rm -rf $HOME/badvpn*
		kill -9 $(ps x | grep badvpn | grep -v grep | awk '{print $1'}) >/dev/null 2>&1
		killall badvpn-udpgw >/dev/null 2>&1
		rm -rf /bin/badvpn-udpgw
		[[ ! "$(ps x | grep badvpn | grep -v grep | awk '{print $1}')" ]] && msg -ne "                DESACTIVADO CON EXITO \n"
		unset pid_badvpn
		msg -bar
	}

	activado() {
		msg -bar
		#puerto local
		[[ "$(ps x | grep badvpn | grep -v grep | awk '{print $1}')" ]] && msg -verd "                  ACTIVADO CON EXITO" || msg -ama "                 Falló"
		msg -bar
	}

	pid_badvpn=$(ps x | grep badvpn | grep -v grep | awk '{print $1}')

	clear
	msg -tit
	msg -ama "  \e[1;43m\e[91mACTIVADOR DE BADVPN (7100-7200-7300-Multi Port)\e[0m"
	msg -bar
	echo -e "$(msg -verd "[1]")$(msg -verm2 "➛ ")$(msg -azu "ACTIVAR BADVPN 7300") \e[92m(System)"
	echo -e "$(msg -verd "[2]")$(msg -verm2 "➛ ")$(msg -azu "ACTIVAR BADVPN 7300") \e[92m(Screen Directo)"
	echo -e "$(msg -verd "[3]")$(msg -verm2 "➛ ")$(msg -azu "AGREGAR +PORT BADVPN ")"
	echo -e "$(msg -verd "[4]")$(msg -verm2 "➛ ")$(msg -azu "APLICAR FIX CMAKE")"
	echo -e "$(msg -verd "[5]")$(msg -verm2 "➛ ")$(msg -azu "DETENER SERVICIO BADVPN")"
	echo -e "$(msg -verd "[0]")$(msg -verm2 "➛ ")$(msg -azu "VOLVER")"
	msg -bar
	read -p "Digite una opción (default 2): " -e -i 2 portasx
	#tput cuu1 && tput dl1
	if [[ ${portasx} = 1 ]]; then
		if [[ -z $pid_badvpn ]]; then
			msg -ama "	DESCARGANDO PAQUETES....."
			apt install wget -y &>/dev/null
			apt-get install -y gcc &>/dev/null             # 2>/dev/null
			apt-get install -y make &>/dev/null            #2>/dev/null
			apt-get install -y g++ &>/dev/null             #2>/dev/null
			apt-get install -y openssl &>/dev/null         #2>/dev/null
			apt-get install -y build-essential &>/dev/null #2>/dev/null
			if apt-get install cmake -y &>/dev/null; then
				msg -verd "	CMAKE INSTALADO"
			else
				msg -verm2 "	FALLÓ"
				return
			fi

			cd $HOME
			if wget https://raw.githubusercontent.com/pedrazadixon/LACASITANULLED/main/SCRIPTMOD/test/badvpn-master.zip &>/dev/null; then
				msg -verd "	DESCARGA CORRECTA"
			else
				msg -verm2 "	DESCARGA FALLIDA"
				return
			fi

			if unzip badvpn-master.zip &>/dev/null; then
				msg -verd "	Descomprimiendo archivo"
			else
				msg -verm2 "	La descomprecion ha fallado"
				return
			fi

			cd badvpn-master
			mkdir build
			cd build
			if cmake .. -DCMAKE_INSTALL_PREFIX="/" -DBUILD_NOTHING_BY_DEFAULT=1 -DBUILD_UDPGW=1 &>/dev/null && make install &>/dev/null; then
				msg -verd "	Cmake con exito"
			else
				msg -verm2 "	Cmake Fallido"
				return
			fi
			cd $HOME
			rm -rf badvpn-master.zip
			#rm -rf badvpn*
			#arm
			sleep 1s
			clear
			echo -e "[Unit]
Description=BadVPN UDPGW Service
After=network.target
StartLimitIntervalSec=0

[Service]
Type=simple
User=root
WorkingDirectory=/root
ExecStart=$(which badvpn-udpgw) --listen-addr 127.0.0.1:7300 --max-clients 1000 --max-connections-for-client 100
Restart=always
RestartSec=3s

[Install]
WantedBy=multi-user.target" >/etc/systemd/system/badvpn.service

			systemctl enable badvpn &>/dev/null
			systemctl start badvpn &>/dev/null
			systemctl daemon-reload &>/dev/null
			activado
		else
			systemctl stop badvpn &>/dev/null
			systemctl disable badvpn &>/dev/null
			rm -rf /etc/systemd/system/badvpn.service
			msg -ne "                7300 DESACTIVADO CON EXITO \n"
		fi
	elif [[ ${portasx} = 2 ]]; then
		if [[ -z $pid_badvpn ]]; then
			if [[ ! -e /bin/badvpn-udpgw ]]; then
				wget -O /bin/badvpn-udpgw https://raw.githubusercontent.com/pedrazadixon/LACASITANULLED/main/ArchivosUtilitarios/badvpn-udpgw &>/dev/null
				chmod 777 /bin/badvpn-udpgw
			fi
			echo -ne " \e[93mLIMITE DE CADA CONEXION POR USUARIO > 10\n SI DESEAS ALTERAR EL LIMITE SERÁ BAJO SU RESPONSABILIDAD: \033[1;37m" && read casitaport
			tput cuu1 && tput dl1
			if [[ -z $casitaport ]]; then
				casitaport="10"
				echo -e "	\e[31mLimite Default:\033[1;32m ${casitaport} POR USUARIO"
			else
				echo -e "	\e[31mLimite Alterado:\033[1;32m ${casitaport} POR USUARIO"
			fi
			#screen -dmS badvpn $(which badvpn-udpgw) --listen-addr 127.0.0.1:7300 --max-clients 10000 --max-connections-for-client $casitaport
			echo -e "[Unit]
Description=BadVPN UDPGW Service
After=network.target
StartLimitIntervalSec=0

[Service]
Type=simple
User=root
WorkingDirectory=/root
ExecStart=/bin/badvpn-udpgw --listen-addr 127.0.0.1:7300 --max-clients 10000 --max-connections-for-client $casitaport
Restart=always
RestartSec=3s

[Install]
WantedBy=multi-user.target" >/etc/systemd/system/badvpn.service

			systemctl enable badvpn &>/dev/null
			systemctl start badvpn &>/dev/null
			systemctl daemon-reload &>/dev/null
			activado
		else
			unistall
		fi
	elif [[ ${portasx} = 3 ]]; then
		if [[ ! -e /bin/badvpn-udpgw ]]; then
			wget -O /bin/badvpn-udpgw https://raw.githubusercontent.com/pedrazadixon/LACASITANULLED/main/ArchivosUtilitarios/badvpn-udpgw &>/dev/null
			chmod 777 /bin/badvpn-udpgw
		fi
		read -p " Digite El Puerto Para Badvpn: " ud
		systemctl stop badvpn &>/dev/null
		echo -e "[Unit]
Description=BadVPN UDPGW Service
After=network.target
StartLimitIntervalSec=0

[Service]
Type=simple
User=root
WorkingDirectory=/root
ExecStart=/bin/badvpn-udpgw --listen-addr 127.0.0.1:$ud --max-clients 10000 --max-connections-for-client 100
Restart=always
RestartSec=3s

[Install]
WantedBy=multi-user.target" >/etc/systemd/system/badvpn.service

		#systemctl enable badvpn &>/dev/null
		systemctl start badvpn &>/dev/null
		systemctl restart badvpn &>/dev/null
		systemctl daemon-reload &>/dev/null
		activado

	elif [[ ${portasx} = 4 ]]; then
		wget https://cmake.org/files/v3.8/cmake-3.8.2.tar.gz
		tar xf cmake-3.8.2.tar.gz &>/dev/null
		cd cmake-3.8.2
		./configure &>/dev/null
		sudo make install &>/dev/null
		cd $HOME
		if wget https://raw.githubusercontent.com/pedrazadixon/LACASITANULLED/main/SCRIPTMOD/test/badvpn-master.zip &>/dev/null; then
			msg -verd "	DESCARGA CORRECTA"
		else
			msg -verm2 "	DESCARGA FALLIDA"
			return
		fi

		if unzip badvpn-master.zip &>/dev/null; then
			msg -verd "	Descomprimiendo archivo"
		else
			msg -verm2 "	La descomprecion ha fallado"
			return
		fi

		cd badvpn-master
		mkdir build
		cd build
		if cmake .. -DCMAKE_INSTALL_PREFIX="/" -DBUILD_NOTHING_BY_DEFAULT=1 -DBUILD_UDPGW=1 &>/dev/null && make install &>/dev/null; then
			msg -verd "	Cmake con exito"
		else
			msg -verm2 "	Cmake Fallido"
			return
		fi
		cd $HOME
		rm -rf badvpn-master.zip
		#rm -rf badvpn*
		#arm
		sleep 1s
		clear
		echo -e "[Unit]
Description=BadVPN UDPGW Service
After=network.target

[Service]
Type=simple
User=root
WorkingDirectory=/root
ExecStart=$(which badvpn-udpgw)  --listen-addr 127.0.0.1:7300 --max-clients 1000 --max-connections-for-client 10
Restart=always
RestartSec=3s

[Install]
WantedBy=multi-user.target" >/etc/systemd/system/badvpn.service

		systemctl enable badvpn &>/dev/null
		systemctl start badvpn &>/dev/null
		systemctl daemon-reload &>/dev/null
		activado
		unset pid_badvpn
	elif [[ ${portasx} = 5 ]]; then
		unistall
	elif [[ ${portasx} = 0 ]]; then
		msg -verm "	SALIENDO"
		return 0
	fi

}

v2ra() {
	clear
	err_fun() {
		case $1 in
		1)
			msg -verm "$(fun_trans "Usuario Nulo")"
			sleep 2s
			tput cuu1
			tput dl1
			tput cuu1
			tput dl1
			;;
		2)
			msg -verm "$(fun_trans "Nombre muy corto (MIN: 2 CARACTERES)")"
			sleep 2s
			tput cuu1
			tput dl1
			tput cuu1
			tput dl1
			;;
		3)
			msg -verm "$(fun_trans "Nombre muy grande (MAX: 5 CARACTERES)")"
			sleep 2s
			tput cuu1
			tput dl1
			tput cuu1
			tput dl1
			;;
		4)
			msg -verm "$(fun_trans "Contraseña Nula")"
			sleep 2s
			tput cuu1
			tput dl1
			tput cuu1
			tput dl1
			;;
		5)
			msg -verm "$(fun_trans "Contraseña muy corta")"
			sleep 2s
			tput cuu1
			tput dl1
			tput cuu1
			tput dl1
			;;
		6)
			msg -verm "$(fun_trans "Contraseña muy grande")"
			sleep 2s
			tput cuu1
			tput dl1
			tput cuu1
			tput dl1
			;;
		7)
			msg -verm "$(fun_trans "Duracion Nula")"
			sleep 2s
			tput cuu1
			tput dl1
			tput cuu1
			tput dl1
			;;
		8)
			msg -verm "$(fun_trans "Duracion invalida utilize numeros")"
			sleep 2s
			tput cuu1
			tput dl1
			tput cuu1
			tput dl1
			;;
		9)
			msg -verm "$(fun_trans "Duracion maxima y de un año")"
			sleep 2s
			tput cuu1
			tput dl1
			tput cuu1
			tput dl1
			;;
		11)
			msg -verm "$(fun_trans "Limite Nulo")"
			sleep 2s
			tput cuu1
			tput dl1
			tput cuu1
			tput dl1
			;;
		12)
			msg -verm "$(fun_trans "Limite invalido utilize numeros")"
			sleep 2s
			tput cuu1
			tput dl1
			tput cuu1
			tput dl1
			;;
		13)
			msg -verm "$(fun_trans "Limite maximo de 999")"
			sleep 2s
			tput cuu1
			tput dl1
			tput cuu1
			tput dl1
			;;
		14)
			msg -verm "$(fun_trans "Usuario Ya Existe")"
			sleep 2s
			tput cuu1
			tput dl1
			tput cuu1
			tput dl1
			;;
		15)
			msg -verm "$(fun_trans "(Solo numeros) GB = Min: 1gb Max: 1000gb")"
			sleep 2s
			tput cuu1
			tput dl1
			tput cuu1
			tput dl1
			;;
		16)
			msg -verm "$(fun_trans "(Solo numeros)")"
			sleep 2s
			tput cuu1
			tput dl1
			tput cuu1
			tput dl1
			;;
		17)
			msg -verm "$(fun_trans "(Sin Informacion - Para Cancelar Digite CRTL + C)")"
			sleep 4s
			tput cuu1
			tput dl1
			tput cuu1
			tput dl1
			;;
		esac
	}
	intallv2ray() {
		apt install python3-pip -y
		source <(curl -sL https://raw.githubusercontent.com/pedrazadixon/LACASITANULLED/main/install-v2ray.sh)
		msg -ama "$(fun_trans "Intalado con Exito")!"
		USRdatabase="/etc/VPS-MX/RegV2ray"
		[[ ! -e ${USRdatabase} ]] && touch ${USRdatabase}
		sort ${USRdatabase} | uniq >${USRdatabase}tmp
		mv -f ${USRdatabase}tmp ${USRdatabase}
		msg -bar
		service v2ray restart
		msg -ne "Enter Para Continuar" && read enter
		v2ra

	}

	v2path() {
		clear && clear
		pat="$(cat /etc/v2ray/config.json | grep 'path' | cut -d'"' -f4 | cut -d'/' -f2)"
		unset _col
		msg -bar
		msg -bra "	SU PATH DEFAULT ES: ${pat}"
		msg -ama "	INGRESE EL NUEVO path "
		read -p " path : " _col

		[[ ${_col} ]] && {
			sed -i "s/${pat}/${_col}/" /etc/v2ray/config.json
			#sed -i "s/${pat}/${_col}/" /root/config.json
			service v2ray restart &>/dev/null
			msg -ama "	PATH MODIFICADO: $_col"
		}

	}

	v2host() {
		clear && clear
		ht="$(cat /etc/v2ray/config.json | grep 'Host' | cut -d'"' -f4 | cut -d' ' -f2)"
		unset _col
		msg -bar
		msg -bra "	SU HOST DEFAULT ES: ${ht}"
		msg -ama "	INGRESE SU NUEVO host"
		read -p " host : " _col

		[[ ${_col} ]] && {
			sed -i "s/${ht}/${_col}/" /etc/v2ray/config.json
			#sed -i "s/${ht}/${_col}/" /root/config.json
			service v2ray restart &>/dev/null
			msg -ama "	HOST MODIFICADO: $_col"
		}

	}

	protocolv2ray() {
		msg -ama "$(fun_trans "Escojer opcion 3 y poner el dominio de nuestra IP")!"
		msg -bar
		v2ray stream
		msg -bar
		msg -ne "Enter Para Continuar" && read enter
		v2ra
	}
	dirapache="/usr/local/lib/ubuntn/apache/ver" && [[ ! -d ${dirapache} ]] && exit
	tls() {
		msg -ama "$(fun_trans "Activar o Desactivar TLS")!"
		msg -bar
		v2ray tls
		msg -bar
		msg -ne "Enter Para Continuar" && read enter
		v2ra
	}
	portv() {
		msg -ama "$(fun_trans "Cambiar Puerto v2ray")!"
		msg -bar
		v2ray port
		msg -bar
		msg -ne "Enter Para Continuar" && read enter
		v2ra
	}
	stats() {
		msg -ama "$(fun_trans "Estadisticas de Consumo")!"
		msg -bar
		v2ray stats
		msg -bar
		msg -ne "Enter Para Continuar" && read enter
		v2ra
	}
	unistallv2() {
		source <(curl -sL https://www.dropbox.com/s/gh8vll0a8nejwr8/install-v2ray.sh) --remove >/dev/null 2>&1
		rm -rf /etc/VPS-MX/RegV2ray >/dev/null 2>&1
		echo -e "\033[1;92m                  V2RAY REMOVIDO OK "
		msg -bar
		msg -ne "Enter Para Continuar" && read enter
		v2ra
	}
	infocuenta() {
		v2ray info
		msg -bar
		msg -ne "Enter Para Continuar" && read enter
		v2ra
	}

	addusr() {
		clear
		clear
		msg -bar
		msg -tit
		msg -ama "             AGREGAR USUARIO | UUID V2RAY"
		msg -bar
		##DAIS
		valid=$(date '+%C%y-%m-%d' -d " +31 days")
		##CORREO
		MAILITO=$(cat /dev/urandom | tr -dc '[:alnum:]' | head -c 10)
		##ADDUSERV2RAY
		UUID=$(cat /proc/sys/kernel/random/uuid)
		sed -i '13i\           \{' /etc/v2ray/config.json
		sed -i '14i\           \"alterId": 0,' /etc/v2ray/config.json
		sed -i '15i\           \"id": "'$UUID'",' /etc/v2ray/config.json
		sed -i '16i\           \"email": "'$MAILITO'@gmail.com"' /etc/v2ray/config.json
		sed -i '17i\           \},' /etc/v2ray/config.json
		echo ""
		while true; do
			echo -ne "\e[91m >> Digita un Nombre: \033[1;92m"
			read -p ": " nick
			nick="$(echo $nick | sed -e 's/[^a-z0-9 -]//ig')"
			if [[ -z $nick ]]; then
				err_fun 17 && continue
			elif [[ "${#nick}" -lt "2" ]]; then
				err_fun 2 && continue
			elif [[ "${#nick}" -gt "5" ]]; then
				err_fun 3 && continue
			fi
			break
		done
		echo -e "\e[91m >> Agregado UUID: \e[92m$UUID "
		while true; do
			echo -ne "\e[91m >> Duracion de UUID (Dias):\033[1;92m " && read diasuser
			if [[ -z "$diasuser" ]]; then
				err_fun 17 && continue
			elif [[ "$diasuser" != +([0-9]) ]]; then
				err_fun 8 && continue
			elif [[ "$diasuser" -gt "360" ]]; then
				err_fun 9 && continue
			fi
			break
		done
		#Lim
		#[[ $(cat /etc/passwd |grep $1: |grep -vi [a-z]$1 |grep -v [0-9]$1 > /dev/null) ]] && return 1
		valid=$(date '+%C%y-%m-%d' -d " +$diasuser days") && datexp=$(date "+%F" -d " + $diasuser days")

		echo -e "\e[91m >> Expira el : \e[92m$datexp "
		##Registro
		echo "$UUID |$nick |$valid" >>/etc/VPS-MX/RegV2ray
		Fecha=$(date +%d-%m-%y-%R)
		cp /etc/VPS-MX/RegV2ray /etc/VPS-MX/v2ray/RegV2ray-"$Fecha"
		v2ray restart >/dev/null 2>&1
		echo ""
		v2ray info >/etc/VPS-MX/v2ray/confuuid.log
		lineP=$(sed -n '/'${UUID}'/=' /etc/VPS-MX/v2ray/confuuid.log)
		numl1=4
		let suma=$lineP+$numl1
		sed -n ${suma}p /etc/VPS-MX/v2ray/confuuid.log
		echo ""
		msg -bar
		echo -e "\e[92m           UUID AGREGADO CON EXITO "
		msg -bar
		msg -ne "Enter Para Continuar" && read enter
		v2ra
	}

	v2renov() {
		clear
		msg -bar
		msg -tit
		msg -ama "             RENOVAR USUARIO | V2RAY"
		msg -bar
		echo -e "\e[97m               USUARIOS REGISTRADOS"
		msg -bar
		n=1
		for i in $(cat /etc/VPS-MX/RegV2ray | cut -d'|' -f1); do
			user="$i"
			useruid=$(printf '%-12s' "$user")

			nombre="$(cat /etc/VPS-MX/RegV2ray | grep -w "$i" | cut -d'|' -f2)"
			fech="$(cat /etc/VPS-MX/RegV2ray | grep -w "$i" | cut -d'|' -f3)"
			echo -e " $(msg -verd "[$n]") $(msg -verm2 ">") $(msg -ama "$useruid")$(msg -azu "$nombre | $fech")"
			drop[$n]=$user
			num_opc="$n"
			let n++
		done
		msg -bar
		opc=$(selection_fun $num_opc)

		useredit="${drop[$opc]}"

		fecha="$(cat /etc/VPS-MX/RegV2ray | grep -w "$useredit" | cut -d'|' -f3)"
		nombrex="$(cat /etc/VPS-MX/RegV2ray | grep -w "$useredit" | cut -d'|' -f2)"

		echo "$useredit|$nombrex" >/etc/v2ray/fecha
		msg -bar
		msg -ne "Nuevo Tiempo de Duracion de:\033[1;37m $useredit\e[33m"
		read -p ": " diasuser
		msg -bar

		valid=$(date '+%C%y-%m-%d' -d " +$diasuser days") && datexp=$(date "+%F" -d " + $diasuser days")
		#nueva fecha
		uid="$(cat /etc/v2ray/fecha | cut -d'|' -f1)"
		nombre="$(cat /etc/v2ray/fecha | cut -d'|' -f2)"
		#del
		sed -i "/${useredit}/d" /etc/VPS-MX/RegV2ray
		echo "$uid |$nombre |$valid" >>/etc/VPS-MX/RegV2ray
		msg -ama "	Fecha MODIFICADO: ${uid} | $valid"

		Fecha=$(date +%d-%m-%y-%R)
		cp /etc/VPS-MX/RegV2ray /etc/VPS-MX/v2ray/RegV2ray-"$Fecha"
		v2ray restart >/dev/null 2>&1
		echo ""

		msg -bar
		echo -e "\e[92m           USUARIO RENOVADO CON EXITO "
		msg -verd "  $uid | $nombre | $datexp "
		msg -bar
		msg -ne "Enter Para Continuar" && read enter
		v2ra
	}

	delusr() {
		clear
		clear
		invaliduuid() {
			msg -bar
			echo -e "\e[91m                    UUID INVALIDO \n$(msg -bar)"
			msg -ne "Enter Para Continuar" && read enter
			v2ra
		}
		msg -bar
		msg -tit
		msg -ama "             ELIMINAR USUARIO | UUID V2RAY"
		msg -bar
		echo -e "\e[97m               USUARIOS REGISTRADOS"
		echo -e "\e[33m$(cat /etc/VPS-MX/RegV2ray | cut -d '|' -f2,1)"
		msg -bar
		echo -ne "\e[91m >> Digita el UUID a eliminar:\n \033[1;92m " && read uuidel
		[[ $(sed -n '/'${uuidel}'/=' /etc/v2ray/config.json | head -1) ]] || invaliduuid
		lineP=$(sed -n '/'${uuidel}'/=' /etc/v2ray/config.json)
		linePre=$(sed -n '/'${uuidel}'/=' /etc/VPS-MX/RegV2ray)
		sed -i "${linePre}d" /etc/VPS-MX/RegV2ray
		numl1=2
		let resta=$lineP-$numl1
		sed -i "${resta}d" /etc/v2ray/config.json
		sed -i "${resta}d" /etc/v2ray/config.json
		sed -i "${resta}d" /etc/v2ray/config.json
		sed -i "${resta}d" /etc/v2ray/config.json
		sed -i "${resta}d" /etc/v2ray/config.json
		v2ray restart >/dev/null 2>&1
		msg -bar
		msg -ne "Enter Para Continuar" && read enter
		v2ra
	}

	mosusr_kk() {
		clear
		clear
		msg -bar
		msg -tit
		msg -ama "         USUARIOS REGISTRADOS | UUID V2RAY"
		msg -bar
		# usersss=$(cat /etc/VPS-MX/RegV2ray|cut -d '|' -f1)
		# cat /etc/VPS-MX/RegV2ray|cut -d'|' -f3
		VPSsec=$(date +%s)
		local HOST="/etc/VPS-MX/RegV2ray"
		local HOST2="/etc/VPS-MX/RegV2ray"
		local RETURN="$(cat $HOST | cut -d'|' -f2)"
		local IDEUUID="$(cat $HOST | cut -d'|' -f1)"
		if [[ -z $RETURN ]]; then
			echo -e "----- NINGUN USER REGISTRADO -----"
			msg -ne "Enter Para Continuar" && read enter
			v2ra

		else
			i=1
			echo -e "\e[97m                 UUID                | USER | EXPIRACION \e[93m"
			msg -bar
			while read hostreturn; do
				DateExp="$(cat /etc/VPS-MX/RegV2ray | grep -w "$hostreturn" | cut -d'|' -f3)"
				if [[ ! -z $DateExp ]]; then
					DataSec=$(date +%s --date="$DateExp")
					[[ "$VPSsec" -gt "$DataSec" ]] && EXPTIME="\e[91m[EXPIRADO]\e[97m" || EXPTIME="\e[92m[$(($(($DataSec - $VPSsec)) / 86400))]\e[97m Dias"
				else
					EXPTIME="\e[91m[ S/R ]"
				fi
				usris="$(cat /etc/VPS-MX/RegV2ray | grep -w "$hostreturn" | cut -d'|' -f2)"
				local contador_secuencial+="\e[93m$hostreturn \e[97m|\e[93m$usris\e[97m|\e[93m $EXPTIME \n"
				if [[ $i -gt 30 ]]; then
					echo -e "$contador_secuencial"
					unset contador_secuencial
					unset i
				fi
				let i++
			done <<<"$IDEUUID"

			[[ ! -z $contador_secuencial ]] && {
				linesss=$(cat /etc/VPS-MX/RegV2ray | wc -l)
				echo -e "$contador_secuencial \n Numero de Registrados: $linesss"
			}
		fi
		msg -bar
		msg -ne "Enter Para Continuar" && read enter
		v2ra
	}
	lim_port() {
		clear
		clear
		msg -bar
		msg -tit
		msg -ama "          LIMITAR MB X PORT | UUID V2RAY"
		msg -bar
		###VER
		estarts() {
			VPSsec=$(date +%s)
			local HOST="/etc/VPS-MX/v2ray/lisportt.log"
			local HOST2="/etc/VPS-MX/v2ray/lisportt.log"
			local RETURN="$(cat $HOST | cut -d'|' -f2)"
			local IDEUUID="$(cat $HOST | cut -d'|' -f1)"
			if [[ -z $RETURN ]]; then
				echo -e "----- NINGUN PUERTO REGISTRADO -----"
				msg -ne "Enter Para Continuar" && read enter
				v2ra
			else
				i=1
				while read hostreturn; do
					iptables -n -v -L >/etc/VPS-MX/v2ray/data1.log
					statsss=$(cat /etc/VPS-MX/v2ray/data1.log | grep -w "tcp spt:$hostreturn quota:" | cut -d' ' -f3,4,5)
					gblim=$(cat /etc/VPS-MX/v2ray/lisportt.log | grep -w "$hostreturn" | cut -d'|' -f2)
					local contador_secuencial+="         \e[97mPUERTO: \e[93m$hostreturn \e[97m|\e[93m$statsss \e[97m|\e[93m $gblim GB  \n"
					if [[ $i -gt 30 ]]; then
						echo -e "$contador_secuencial"
						unset contador_secuencial
						unset i
					fi
					let i++
				done <<<"$IDEUUID"

				[[ ! -z $contador_secuencial ]] && {
					linesss=$(cat /etc/VPS-MX/v2ray/lisportt.log | wc -l)
					echo -e "$contador_secuencial \n Puertos Limitados: $linesss"
				}
			fi
			msg -bar
			msg -ne "Enter Para Continuar" && read enter
			v2ra
		}
		###LIM
		liport() {
			while true; do
				echo -ne "\e[91m >> Digite Port a Limitar:\033[1;92m " && read portbg
				if [[ -z "$portbg" ]]; then
					err_fun 17 && continue
				elif [[ "$portbg" != +([0-9]) ]]; then
					err_fun 16 && continue
				elif [[ "$portbg" -gt "1000" ]]; then
					err_fun 16 && continue
				fi
				break
			done
			while true; do
				echo -ne "\e[91m >> Digite Cantidad de GB:\033[1;92m " && read capgb
				if [[ -z "$capgb" ]]; then
					err_fun 17 && continue
				elif [[ "$capgb" != +([0-9]) ]]; then
					err_fun 15 && continue
				elif [[ "$capgb" -gt "1000" ]]; then
					err_fun 15 && continue
				fi
				break
			done
			uml1=1073741824
			gbuser="$capgb"
			let multiplicacion=$uml1*$gbuser
			sudo iptables -I OUTPUT -p tcp --sport $portbg -j DROP
			sudo iptables -I OUTPUT -p tcp --sport $portbg -m quota --quota $multiplicacion -j ACCEPT
			iptables-save >/etc/iptables/rules.v4
			echo ""
			echo -e " Port Seleccionado: $portbg | Cantidad de GB: $gbuser"
			echo ""
			echo " $portbg | $gbuser | $multiplicacion " >>/etc/VPS-MX/v2ray/lisportt.log
			msg -bar
			msg -ne "Enter Para Continuar" && read enter
			v2ra
		}
		#monitor

		###RES
		resdata() {
			VPSsec=$(date +%s)
			local HOST="/etc/VPS-MX/v2ray/lisportt.log"
			local HOST2="/etc/VPS-MX/v2ray/lisportt.log"
			local RETURN="$(cat $HOST | cut -d'|' -f2)"
			local IDEUUID="$(cat $HOST | cut -d'|' -f1)"
			if [[ -z $RETURN ]]; then
				echo -e "----- NINGUN PUERTO REGISTRADO -----"
				return 0
			else
				i=1
				while read hostreturn; do
					iptables -n -v -L >/etc/VPS-MX/v2ray/data1.log
					statsss=$(cat /etc/VPS-MX/v2ray/data1.log | grep -w "tcp spt:$hostreturn quota:" | cut -d' ' -f3,4,5)
					gblim=$(cat /etc/VPS-MX/v2ray/lisportt.log | grep -w "$hostreturn" | cut -d'|' -f2)
					local contador_secuencial+="         \e[97mPUERTO: \e[93m$hostreturn \e[97m|\e[93m$statsss \e[97m|\e[93m $gblim GB  \n"

					if [[ $i -gt 30 ]]; then
						echo -e "$contador_secuencial"
						unset contador_secuencial
						unset i
					fi
					let i++
				done <<<"$IDEUUID"

				[[ ! -z $contador_secuencial ]] && {
					linesss=$(cat /etc/VPS-MX/v2ray/lisportt.log | wc -l)
					echo -e "$contador_secuencial \n Puertos Limitados: $linesss"
				}
			fi
			msg -bar

			while true; do
				echo -ne "\e[91m >> Digite Puerto a Limpiar:\033[1;92m " && read portbg
				if [[ -z "$portbg" ]]; then
					err_fun 17 && continue
				elif [[ "$portbg" != +([0-9]) ]]; then
					err_fun 16 && continue
				elif [[ "$portbg" -gt "1000" ]]; then
					err_fun 16 && continue
				fi
				break
			done
			invaliduuid() {
				msg -bar
				echo -e "\e[91m                PUERTO INVALIDO \n$(msg -bar)"
				msg -ne "Enter Para Continuar" && read enter
				v2ra
			}
			[[ $(sed -n '/'${portbg}'/=' /etc/VPS-MX/v2ray/lisportt.log | head -1) ]] || invaliduuid
			gblim=$(cat /etc/VPS-MX/v2ray/lisportt.log | grep -w "$portbg" | cut -d'|' -f3)
			sudo iptables -D OUTPUT -p tcp --sport $portbg -j DROP
			sudo iptables -D OUTPUT -p tcp --sport $portbg -m quota --quota $gblim -j ACCEPT
			iptables-save >/etc/iptables/rules.v4
			lineP=$(sed -n '/'${portbg}'/=' /etc/VPS-MX/v2ray/lisportt.log)
			sed -i "${linePre}d" /etc/VPS-MX/v2ray/lisportt.log
			msg -bar
			msg -ne "Enter Para Continuar" && read enter
			v2ra
		}
		## MENU
		echo -ne "\033[1;32m [1] > " && msg -azu "$(fun_trans "LIMITAR DATA x PORT") "
		echo -ne "\033[1;32m [2] > " && msg -azu "$(fun_trans "RESETEAR DATA DE PORT") "
		echo -ne "\033[1;32m [3] > " && msg -azu "$(fun_trans "VER DATOS CONSUMIDOS") "
		echo -ne "$(msg -bar)\n\033[1;32m [0] > " && msg -bra "\e[97m\033[1;41m VOLVER \033[1;37m"
		msg -bar
		selection=$(selection_fun 3)
		case ${selection} in
		1) liport ;;
		2) resdata ;;
		3) estarts ;;
		0)
			v2ra
			;;
		esac
	}

	limpiador_activador() {
		unset PIDGEN
		PIDGEN=$(ps aux | grep -v grep | grep "limv2ray")
		if [[ ! $PIDGEN ]]; then
			wget -O /usr/bin/limv2ray https://www.dropbox.com/s/goty5g155vcp02r/limv2ray &>/dev/null
			chmod 777 /usr/bin/limv2ray
			screen -dmS limv2ray watch -n 21600 limv2ray
		else
			#killall screen
			screen -S limv2ray -p 0 -X quit
		fi
		unset PID_GEN
		PID_GEN=$(ps x | grep -v grep | grep "limv2ray")
		[[ ! $PID_GEN ]] && PID_GEN="\e[91m [ DESACTIVADO ] " || PID_GEN="\e[92m [ ACTIVADO ] "
		statgen="$(echo $PID_GEN)"
		clear
		clear
		msg -bar
		msg -tit
		msg -ama "          ELIMINAR EXPIRADOS | UUID V2RAY"
		msg -bar
		echo ""
		echo -e "                    $statgen "
		echo ""
		msg -bar
		msg -ne "Enter Para Continuar" && read enter
		v2ra

	}

	pidr_inst() {
		proto="v2ray"
		portas=$(lsof -V -i -P -n | grep -v "ESTABLISHED" | grep -v "COMMAND")
		for list in $proto; do
			case $list in
			v2ray)
				portas2=$(echo $portas | grep -w "LISTEN" | grep -w "$list")
				[[ $(echo "${portas2}" | grep "$list") ]] && inst[$list]="\033[1;32m[ACTIVO] " || inst[$list]="\033[1;31m[DESACTIVADO]"
				;;
			esac
		done
	}
	PID_GEN=$(ps x | grep -v grep | grep "limv2ray")
	[[ ! $PID_GEN ]] && PID_GEN="\e[91m [ OFF ] " || PID_GEN="\e[92m [ ON ] "
	statgen="$(echo $PID_GEN)"
	SPR &
	on="\e[1;32m[ACTIVO]" && off="\e[1;31m[DESACTIVADO]"

	declare -A inst
	pidr_inst

	msg -bar3
	#msg -bar
	msg -tit
	msg -bar
	echo -e "        \e[91m\e[43mINSTALADOR DE V2RAY\e[0m"
	msg -bar
	## INSTALADOR
	echo -e "$(msg -verd "  [1]")$(msg -verm2 " ➛ ")$(msg -azu " INSTALAR V2RAY ") ${inst[v2ray]}"
	echo -e "$(msg -verd "  [2]")$(msg -verm2 " ➛ ")$(msg -azu " CAMBIAR PROTOCOLO ") "
	echo -e "$(msg -verd "  [3]")$(msg -verm2 " ➛ ")$(msg -azu " ACTIVAR TLS ") "
	echo -e "$(msg -verd "  [4]")$(msg -verm2 " ➛ ")$(msg -azu " CAMBIAR PUERTO V2RAY ")"
	msg -bar
	## CONTROLER
	echo -e "$(msg -verd "  [5]")$(msg -verm2 " ➛ ")$(msg -azu " AGREGAR USUARIO UUID ")"
	echo -e "$(msg -verd "  [6]")$(msg -verm2 " ➛ ")$(msg -azu " ELIMINAR USUARIO UUID ")"
	#editar
	echo -e "$(msg -verd "  [7]")$(msg -verm2 " ➛ ")$(msg -azu " RENOVAR USUARIO UUID ")"
	echo -e "$(msg -verd "  [8]")$(msg -verm2 " ➛ ")$(msg -azu " MODIFICAR PATH ")"
	echo -e "$(msg -verd "  [9]")$(msg -verm2 " ➛ ")$(msg -azu " MODIFICAR HOST ")"

	echo -e "$(msg -verd "  [10]")$(msg -verm2 "➛ ")$(msg -azu " MOSTRAR USUARIOS REGISTRADOS ")"
	echo -e "$(msg -verd "  [11]")$(msg -verm2 "➛ ")$(msg -azu " INFORMACION DE CUENTAS ")"
	echo -e "$(msg -verd "  [12]")$(msg -verm2 "➛ ")$(msg -azu " ESTADISTICAS DE CONSUMO ")"
	echo -e "$(msg -verd "  [13]")$(msg -verm2 "➛ ")$(msg -azu " LIMITADOR POR CONSUMO ")\e[91m ( BETA x PORT )"
	echo -e "$(msg -verd "  [14]")$(msg -verm2 "➛ ")$(msg -azu " LIMPIADOR DE EXPIRADOS ------- $statgen ")"
	#

	msg -bar
	## DESISNTALAR
	echo -e "$(msg -verd "  [D]")$(msg -verm2 "➛ ")$(msg -azu "\033[1;31mDESINSTALAR V2RAY ")"
	echo -e "$(msg -verd "  [0]") $(msg -verm2 "➛ ")$(msg -azu " \e[97m\033[1;41m VOLVER \033[1;37m ")"
	msg -bar
	#echo -e "         \e[97mEstado actual: $(pid_inst v2ray)"
	#msg -bar
	echo -ne "\033[1;37m ► Selecione una Opcion: " >&2
	read selection
	tput cuu1 >&2 && tput dl1 >&2
	case ${selection} in
	1) intallv2ray ;;
	2) protocolv2ray ;;
	3) tls ;;
	4) portv ;;
	5) addusr ;;
	6) delusr ;;
	7) v2renov ;;
	8) v2path ;;
	9) v2host ;;
	10) mosusr_kk ;;
	#8)monitor;;
	11) infocuenta ;;
	12) stats ;;
	13) lim_port ;;
	14) limpiador_activador ;;
	d | D) unistallv2 ;;
	0) ;;
	esac
}

os_system() {
	system=$(echo $(cat -n /etc/issue | grep 1 | cut -d' ' -f6,7,8 | sed 's/1//' | sed 's/      //'))
	echo $system | awk '{print $1, $2}'
}
lacasita() {
	unset puertos
	declare -A port
	local portasVAR=$(lsof -V -i tcp -P -n | grep -v "ESTABLISHED" | grep -v "COMMAND" | grep "LISTEN")
	#local portas=$(lsof -V -i tcp -P -n | grep -v "ESTABLISHED" |grep -v "COMMAND" | grep "LISTEN" | grep "stunnel4")
	# Port=$(echo ${port} | awk '{print $9}' | awk -F ":" '{print $2}')
	local NOREPEAT
	local reQ
	local Port
	while read port; do
		reQ=$(echo ${port} | awk '{print $1}')
		Port=$(echo ${port} | awk '{print $9}' | awk -F ":" '{print $2}')
		[[ $(echo -e $NOREPEAT | grep -w "$Port") ]] && continue
		NOREPEAT+="$Port\n"
		case ${reQ} in
		squid | squid3)
			[[ -z ${port[SQD]} ]] && local port[SQD]="\033[1;31m SQUID: \033[1;32m"
			port[SQD]+="$Port "
			;;

		systemd-r | systemd-re | systemd-resolv)
			[[ -z ${port[md]} ]] && local port[md]="\033[1;31m SYSTEMD: \033[1;32m"
			port[md]+="$Port "
			;;
		apache | apache2)
			[[ -z ${port[APC]} ]] && local port[APC]="\033[1;31m APACHE: \033[1;32m"
			port[APC]+="$Port "
			;;

		nginx)
			[[ -z ${port[NG]} ]] && local port[NG]="\033[1;31m NGINX: \033[1;32m"
			port[NG]+="$Port "
			;;
		ssh | sshd)
			[[ -z ${port[SSH]} ]] && local port[SSH]="\033[1;31m SSH: \033[1;32m"
			port[SSH]+="$Port "
			;;

		dropbear)
			[[ -z ${port[DPB]} ]] && local port[DPB]="\033[1;31m DROPBEAR: \033[1;32m"
			port[DPB]+="$Port "
			;;

		ssserver | ss-server)
			[[ -z ${port[SSV]} ]] && local port[SSV]="\033[1;31m SHADOWSOCKS: \033[1;32m"
			port[SSV]+="$Port "
			;;

		obfs-serv)
			[[ -z ${port[OB]} ]] && local port[OB]="\033[1;31m OBFS: \033[1;32m"
			port[OB]+="$Port "
			;;

		trojan-go)
			[[ -z ${port[GO]} ]] && local port[GO]="\033[1;31m TROJAN GO: \033[1;32m"
			port[GO]+="$Port "
			;;
		trojan)
			[[ -z ${port[tro]} ]] && local port[tro]="\033[1;31m TROJAN: \033[1;32m"
			port[tro]+="$Port "
			;;
		openvpn)
			[[ -z ${port[OVPN]} ]] && local port[OVPN]="\033[1;31m OPENVPN-TCP: \033[1;32m"
			port[OVPN]+="$Port "
			;;

		stunnel4 | stunnel)
			[[ -z ${port[SSL]} ]] && local port[SSL]="\033[1;31m SSL: \033[1;32m"
			port[SSL]+="$Port "
			;;

		stunnel5)
			[[ -z ${port[SSL5]} ]] && local port[SSL5]="\033[1;31m STUNNEL5: \033[1;32m"
			port[SSL5]+="$Port "
			;;
		python | python3)
			[[ -z ${port[PY3]} ]] && local port[PY3]="\033[1;31m PYTHON: \033[1;32m"
			port[PY3]+="$Port "
			;;

		node)
			[[ -z ${port[WS]} ]] && local port[WS]="\033[1;31m WEBSOCKET: \033[1;32m"
			port[WS]+="$Port "
			;;
		v2ray)
			[[ -z ${port[V2R]} ]] && local port[V2R]="\033[1;31m V2RAY: \033[1;32m"
			port[V2R]+="$Port "
			;;

		badvpn-ud)
			[[ -z ${port[BAD]} ]] && local port[BAD]="\033[1;31m BADVPN: \033[1;32m"
			port[BAD]+="$Port "
			;;

		psiphon | psiphond)
			[[ -z ${port[PSI]} ]] && local port[PSI]="\033[1;31m PSIPHON: \033[1;32m"
			port[PSI]+="$Port "
			;;
		ws-epro)
			[[ -z ${port[w]} ]] && local port[w]="\033[1;31m WS~Epro: \033[1;32m"
			port[w]+="$Port "
			;;
		DIOS)
			[[ -z ${port[d]} ]] && local port[d]="\033[1;31m WS~PRO: \033[1;32m"
			port[d]+="$Port "
			;;

		esac
	done <<<"${portasVAR}"

	#UDP
	local portasVAR=$(lsof -V -i udp -P -n | grep -v "ESTABLISHED" | grep -v "COMMAND")
	local NOREPEAT
	local reQ
	local Port
	while read port; do
		reQ=$(echo ${port} | awk '{print $1}')
		Port=$(echo ${port} | awk '{print $9}' | awk -F ":" '{print $2}')
		[[ $(echo -e $NOREPEAT | grep -w "$Port") ]] && continue
		NOREPEAT+="$Port\n"
		case ${reQ} in
		openvpn)
			[[ -z ${port[OVPN]} ]] && local port[OVPN]="\033[1;31m OPENVPN-UDP: \033[1;32m"
			port[OVPN]+="$Port "
			;;

		dns-serve)
			[[ -z ${port[SLOW]} ]] && local port[SLOW]="\033[1;31m SlowDNS: \033[1;32m"
			port[SLOW]+="$Port "
			;;
		hysteria)
			[[ -z ${port[hys]} ]] && local port[hys]="\033[1;31m HYSTERIA: \033[1;32m"
			port[hys]+="$Port "
			;;
		ZipVPN)
			[[ -z ${port[zip]} ]] && local port[zip]="\033[1;31m ZIVPN: \033[1;32m"
			port[zip]+="$Port "
			;;
		udp-custo)
			[[ -z ${port[cu]} ]] && local port[cu]="\033[1;31m UDP: \033[1;32m"
			port[cu]+="$Port "
			;;
		udpServer)
			[[ -z ${port[se]} ]] && local port[se]="\033[1;31m UDPServer: \033[1;32m"
			port[se]+="$Port "
			;;

		esac
	done <<<"${portasVAR}"
	[[ $(dpkg --get-selections | grep -w 'wireguard' | head -1) ]] && {
		if [[ ! $(wg | grep -w 'interface') = "" ]]; then
			wg=$(wg | grep -w 'port' | awk -F ' ' '{print $3}')

			port[wg]="\033[1;31m WIREGUARD:\033[1;32m $wg"
		fi
	}

	k=1

	for line in "${port[@]}"; do
		[[ -z "$line" ]] && continue
		let RESTO=k%2

		if [[ $RESTO -eq 0 ]]; then
			puertos+="$line\n"
		else
			puertos+="$line-"
		fi
		let k++

	done

	echo -e "$puertos" | column -t -s '-'

}

remove_script() {
	clear
	clear
	#msg -bar
	msg -tit
	msg -ama "          ¿ DESEA DESINSTALAR SCRIPT ?"
	msg -bar
	echo -e " Esto borrara todos los archivos del scrip VPS_MX"
	msg -bar
	while [[ ${yesno} != @(s|S|y|Y|n|N) ]]; do
		read -p " [S/N]: " yesno
		tput cuu1 && tput dl1
	done
	if [[ ${yesno} = @(s|S|y|Y) ]]; then
		rm -rf ${SCPdir} &>/dev/null
		rm -rf ${SCPusr} &>/dev/null
		rm -rf ${SCPinst} &>/dev/null
		[[ ! -d /usr/local/lib/ubuntn ]] && rm -rf /usr/local/lib/ubuntn
		[[ ! -d /usr/share/mediaptre/local/log ]] && rm -rf /usr/share/mediaptre/local/log
		[[ ! -d /usr/local/protec ]] && rm -rf /usr/local/protec
		[[ -e /bin/VPSMX ]] && rm /bin/VPSMX
		[[ -e /usr/bin/VPSMX ]] && rm /usr/bin/VPSMX
		[[ -e /bin/menu ]] && rm /bin/menu
		[[ -e /usr/bin/menu ]] && rm /usr/bin/menu
		cd $HOME
	fi
	sudo apt-get --purge remove squid -y >/dev/null 2>&1
	sudo apt-get --purge remove stunnel4 -y >/dev/null 2>&1
	sudo apt-get --purge remove dropbear -y >/dev/null 2>&1
	sudo apt-get autoremove -y &>/dev/null
}
horas() {
	#code by rufu99
	msg -bar
	echo -e "	\e[41mACTUALIZAR HORA LOCAL\e[0m"
	msg -bar
	n=1
	for i in $(ls /usr/share/zoneinfo/America); do
		loc=$(echo $i | awk -F ":" '{print $1}')
		zona=$(printf '%-12s' "$loc")
		echo -e " \e[37m [$n] \e[31m> \e[32m$zona"
		r[$n]=$zona
		selec="$n"
		let n++
	done
	msg -bar
	opci=$(selection_fun $selec)
	rm -rf /etc/localtime >/dev/null 2>&1
	echo "America/${r[$opci]}" >/etc/timezone
	ln -fs /usr/share/zoneinfo/America/${r[$opci]} /etc/localtime >/dev/null 2>&1
	dpkg-reconfigure --frontend noninteractive tzdata >/dev/null 2>&1 && echo -e "\033[1;32m [HORA ACTUALIZADA]" || echo -e "\033[1;31m [HORA NO ACTUALIZADO]"
	#fin
	#
}
onlineapp() {
	msg -bar
	echo -e "\033[1;92m                ACTIVANDO SERVICIO"
	msg -bar
	wget -O /etc/VPS-MX/herramientas/.onapp https://www.dropbox.com/s/z0xb6pbe1uagdjt/onapp &>/dev/null
	chmod 777 /etc/VPS-MX/herramientas/.onapp &>/dev/null
	apt install apache2 -y >/dev/null 2>&1
	sed -i "s/Listen 81/Listen 8888/g" /etc/apache2/ports.conf >/dev/null 2>&1
	sed -i 's/:81>/:8888>/' /etc/apache2/sites-available/000-default.conf
	service apache2 restart
	rm -rf /var/www/html/server >/dev/null 2>&1
	mkdir /var/www/html/server >/dev/null 2>&1
	echo -e "[Unit]
Description=.onapp Service by @lacasitamx
After=network.target
StartLimitIntervalSec=0

[Service]
Type=simple
User=root
WorkingDirectory=/root
ExecStart=/bin/bash /etc/VPS-MX/herramientas/.onapp
Restart=always
RestartSec=3s

[Install]
WantedBy=multi-user.target" >/etc/systemd/system/app.service
	ufw allow 8888/tcp &>/dev/null
	systemctl enable app &>/dev/null
	systemctl start app &>/dev/null
	#IP=$(wget -qO- ipv4.icanhazip.com) >/dev/null 2>&1
	msg -bar
	echo -e "\033[1;92m                APP ONLINE INICIADO CON EXITO"
	msg -bar
	echo -e "\033[1;37m URL de usuarios en línea para usar en la aplicación‌‌\033[0m"
	echo -e "\e[1;92m http://$IP:8888/server/online"
	msg -bar
}
killapp() {
	systemctl stop app &>/dev/null
	systemctl disable app &>/dev/null
	rm /etc/systemd/system/app.service &>/dev/null
	rm -rf /var/www/html/server >/dev/null 2>&1
	sed -i "s/Listen 8888/Listen 81/g" /etc/apache2/ports.conf >/dev/null 2>&1
	sed -i 's/:8888>/:81>/' /etc/apache2/sites-available/000-default.conf
	service apache2 restart
	msg -bar
	echo -e "\033[1;91m                APP ONLINE DETENIDO"
	msg -bar

}
menuapp() {
	clear
	msg -tit
	msg -azu "	\e[91m\e[43mACTIVAR APP EN LINEA\e[0m"
	msg -bar
	echo -e " \e[1;93m [\e[92m1\e[93m] $(msg -verm2 "➛ ")$(msg -verd "  INICIAR APP ONLINE  ")"
	echo -e " \e[1;93m [\e[92m2\e[93m] $(msg -verm2 "➛ ")$(msg -verm2 " DETENER APP ONLINE   ")"
	echo -e " \e[1;93m [\e[92m0\e[93m] $(msg -verm2 "➛ ")$(msg -bra "  VOLVER   ")"
	msg -bar
	echo -ne " ►\e[1;37m Selecione Una Opcion: \e[33m " && read select
	case $select in
	0) menu3 ;;
	1)
		onlineapp && msg -ne "Enter Para Continuar" && read enter
		menu3
		;;
	2)
		killapp && msg -ne "Enter Para Continuar" && read enter
		menu3
		;;
	esac
}

ultrahost() {
	subdom() {
		SUBDOM="$1"
		[[ "$SUBDOM" = "" ]] && return
		randomize="$RANDOM"
		for sites in $(cat $log); do
			[[ $(echo ${DNS[@]} | grep $sites) = "" ]] && DNS+=($sites)
			[[ $(echo ${DNS[@]} | grep $sites) != "" ]] && cat $log | grep -v "$sites" >$log
		done
		while true; do
			[[ "$(pidof lynx | wc -w)" -lt "20" ]] && break
		done
		(
			HOST[$randomize]="$SUBDOM"
			curl -sSL "${HOST[$randomize]}" | grep -Eoi '<a [^>]+>' | grep -Eo 'href="[^\"]+"' | grep -Eo '(http|https)://[a-zA-Z0-9./*]+' | sort -u | awk -F "://" '{print $2}' >>$log
		) >/dev/null 2>&1 &
	}

	iniciar() {
		while [[ -z $SUB_DOM ]]; do
			echo -ne "\033[1;33m$(fun_trans "Introduzca el Dominio para realizar la prueba"): " && read SUB_DOM
		done
		[[ -z $limite ]] && echo -ne "\033[1;33m$(fun_trans "Escriba el Limite de Resultados"): " && read limite
		[[ -z ${limite} ]] && limite="300"
		msg -bar
		#CRIA LOG
		log="./loog" && touch $log
		#INICIA PRIMEIRA BUSCA
		_DOM=$(curl -sSL "$SUB_DOM" | grep -Eoi '<a [^>]+>' | grep -Eo 'href="[^\"]+"' | grep -Eo '(http|https)://[a-zA-Z0-9./*]+' | sort -u | awk -F "://" '{print $2}')
		for _DOMS in $(echo $_DOM); do
			[[ $(echo ${DNS[@]} | grep ${_DOMS}) = "" ]] && DNS+=(${_DOMS})
		done
		#INICIA THREADS
		i=0
		while true; do
			DOMAIN=$(echo "${DNS[$i]}")
			[[ $DOMAIN = "" ]] && break
			if [[ $(echo -e "${PESQ[@]}" | grep "$DOMAIN") = "" ]]; then
				subdom "$DOMAIN"
				echo -e "\033[1;31m(Scan\033[1;32m $((${#PESQ[@]} + 1))\033[1;31m de \033[1;32m${#DNS[@]}\033[1;31m) - $(fun_trans "Escaneando") ---> \033[1;36mhttp://$DOMAIN\033[1;37m"
				PESQ+=($DOMAIN)
			fi
			[[ "$(echo ${#DNS[@]})" -gt "$limite" ]] && break
			i=$(($i + 1))
			sleep 1s
		done
		rm $log
		msg -bar
		echo -e "\033[1;32m$(fun_trans "Scan Finalizado Inicio de la colección de IPs")\033[1;31m\033[0m"
		[[ -e $HOME/subresult ]] && rm $HOME/subresult
		[[ ! -e $HOME/subresult ]] && touch $HOME/subresult
		for result in $(echo "${DNS[@]}"); do
			(
				rand="$RANDOM"
				dns[rand]="$result"
				scan[rand]=$(echo ${result} | cut -d'/' -f1)
				IP[rand]=$(nslookup "${scan[rand]}" | grep -Eo 'Address: [0-9.]+' | grep -Eo '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}' | tail -1) >/dev/null 2>&1
				echo -e "====================================\nDNS: ${dns[rand]}\nIP: ${IP[rand]}\n====================================" >>$HOME/subresult
				unset IP
			) &
		done
		while true; do
			[[ $(pidof nslookup | wc -w) -lt "1" ]] && break
		done
		msg -bar
		RSLT=$(($(cat $HOME/subresult | wc -l) / 4)) && echo -e "\033[1;32m$RSLT $(fun_trans "Hosts Capturados")\033[0m"
		msg -bar
		echo -ne "$(fun_trans "Desea Imprimir Resultados")? [S/N]: "
		read yn
		[[ $yn = @(s|S|y|Y) ]] && {
			echo -ne "\033[1;32m"
			cat $HOME/subresult | grep -v =
			echo -e "$barra\033[0m"
		}
		return 0
	}
	#INICIA SCRIPT
	msg -bar
	msg -tit
	echo -e "\033[1;33m $(fun_trans "                  SCAN DE SUBDOMINIOS")"
	msg -bar
	iniciar
	[[ $? = "0" ]] &&
		echo -e "\033[1;32m$(fun_trans "Registro generado en el archivo") $HOME/subresult\033[0m" &&
		msg -bar
}

systen_info() {
	clear
	clear
	#msg -bar
	msg -tit
	msg -ama "$(fun_trans "                DETALLES DEL SISTEMA")"
	null="\033[1;31m"
	msg -bar
	if [ ! /proc/cpuinfo ]; then
		msg -verm "$(fun_trans "Sistema No Soportado")" && msg -bar
		return 1
	fi
	if [ ! /etc/issue.net ]; then
		msg -verm "$(fun_trans "Sistema No Soportado")" && msg -bar
		return 1
	fi
	if [ ! /proc/meminfo ]; then
		msg -verm "$(fun_trans "Sistema No Soportado")" && msg -bar
		return 1
	fi
	totalram=$(free | grep Mem | awk '{print $2}')
	usedram=$(free | grep Mem | awk '{print $3}')
	freeram=$(free | grep Mem | awk '{print $4}')
	swapram=$(cat /proc/meminfo | grep SwapTotal | awk '{print $2}')
	system=$(cat /etc/issue.net)
	clock=$(lscpu | grep "CPU MHz" | awk '{print $3}')
	based=$(cat /etc/*release | grep ID_LIKE | awk -F "=" '{print $2}')
	processor=$(cat /proc/cpuinfo | grep "model name" | uniq | awk -F ":" '{print $2}')
	cpus=$(cat /proc/cpuinfo | grep processor | wc -l)
	[[ "$system" ]] && msg -ama "$(fun_trans "Sistema"): ${null}$system" || msg -ama "$(fun_trans "Sistema"): ${null}???"
	[[ "$based" ]] && msg -ama "$(fun_trans "Base"): ${null}$based" || msg -ama "$(fun_trans "Base"): ${null}???"
	[[ "$processor" ]] && msg -ama "$(fun_trans "Procesador"): ${null}$processor x$cpus" || msg -ama "$(fun_trans "Procesador"): ${null}???"
	[[ "$clock" ]] && msg -ama "$(fun_trans "Frecuencia de Operacion"): ${null}$clock MHz" || msg -ama "$(fun_trans "Frecuencia de Operacion"): ${null}???"
	msg -ama "$(fun_trans "Uso del Procesador"): ${null}$(ps aux | awk 'BEGIN { sum = 0 }  { sum += sprintf("%f",$3) }; END { printf " " "%.2f" "%%", sum}')"
	msg -ama "$(fun_trans "Memoria Virtual Total"): ${null}$(($totalram / 1024))"
	msg -ama "$(fun_trans "Memoria Virtual En Uso"): ${null}$(($usedram / 1024))"
	msg -ama "$(fun_trans "Memoria Virtual Libre"): ${null}$(($freeram / 1024))"
	msg -ama "$(fun_trans "Memoria Virtual Swap"): ${null}$(($swapram / 1024))MB"
	msg -ama "$(fun_trans "Tempo Online"): ${null}$(uptime)"
	msg -ama "$(fun_trans "Nombre De La Maquina"): ${null}$(hostname)"
	msg -ama "$(fun_trans "IP De La  Maquina"): ${null}$(ip addr | grep inet | grep -v inet6 | grep -v "host lo" | awk '{print $2}' | awk -F "/" '{print $1}')"
	msg -ama "$(fun_trans "Version de Kernel"): ${null}$(uname -r)"
	msg -ama "$(fun_trans "Arquitectura"): ${null}$(uname -m)"
	msg -bar
	return 0
}
[[ "$(crontab -l | grep 'autolim' | wc -l)" != '0' ]] &>/dev/null && {
	autram="\e[1;32m[ON]"
} || {
	autram="\e[1;31m[OFF]"
}

menu3() {
	echo 3 >/proc/sys/vm/drop_caches 1>/dev/null 2>/dev/null
	sysctl -w vm.drop_caches=3 1>/dev/null 2>/dev/null
	swapoff -a && swapon -a 1>/dev/null 2>/dev/null
	declare -A inst
	pidr_inst
	clear
	valuest=$(ps ax | grep /etc/shadowsocks-r | grep -v grep)
	[[ $valuest != "" ]] && valuest="\033[1;32m[ON] " || valuest="\033[1;31m[OFF]"
	pidproxy=$(ps x | grep -w "lacasitamx.py" | grep -v "grep" | awk -F "pts" '{print $1}') && [[ ! -z $pidproxy ]] && plox="\e[1;32m[ON] " || plox="\e[1;31m[OFF]"
	[[ $(ps x | grep DIOS | grep -v grep) ]] && P9="\033[1;32m[ON] " || P9="\e[1;31m[OFF]"
	Bot=$(ps x | grep -v grep | grep "ADMbot.sh")
	[[ ! $Bot ]] && AD="\033[1;31m[OFF]" || AD="\033[1;32m[ON] "
	#[[ $(ps x | grep stunnel5 | grep -v grep | awk '{print $1}') ]] && stunel5="\e[1;32m[ON]" || stunel5="\e[1;31m[OFF]"
	#msg -bar
	msg -tit
	export -f fun_eth
	export -f fun_bar
	#echo -e "\e[1;37mTotal Ram: ${null}$(($totalram / 1024)) \e[1;37mUSO: ${null}$(($usedram / 1024)) \e[1;37mLIBRE: ${null}$(($freeram / 1024)) \e[37mSwap:${null}$(($swapram / 1024))MB"
	export -f lacasita
	lacasita
	msg -bar
	echo -e "  	\e[97m\e[1;100mPROTOCOLOS\e[0m  		  \e[97m\e[41mHERRAMIENTAS\e[0m"
	msg -bar
	if [[ ! -e /etc/noty ]]; then
		noty="\e[1;91m[OFF]"
	else
		noty="\e[1;92m[ON] "
	fi
	onap=$(ps x | grep -v grep | grep ".onapp")
	[[ ! $onap ]] && app="\033[1;31m[OFF]" || app="\033[1;32m[ON] "
	[[ $(ps x | grep udpServer | grep -v grep) ]] && uds="\033[1;32m[ON] " || uds="\033[1;31m[OFF]"
	[[ $(ps x | grep udp-custom | grep -v grep) ]] && udpc="\033[1;32m[ON] " || udpc="\033[1;31m[OFF]"
	[[ $(ps x | grep psiphond | grep -v grep) ]] && psh="\033[1;32m[ON] " || psh="\033[1;31m[OFF]"
	[[ $(ps x | grep zivpn | grep -v grep) ]] && ziv="\033[1;32m[ON] " || ziv="\033[1;31m[OFF]"
	[[ $(ps x | grep hysteria | grep -v grep) ]] && hy="\033[1;32m[ON]" || hy="\033[1;31m[OFF]"
	if [[ $(systemctl is-active chekuser) = "active" ]]; then
		chek="\e[1;92m[ON] "
	else
		chek="\e[1;91m[OFF]"
	fi
	#menu de protocolos
	echo -e "\e[1;93m[\e[92m1\e[93m]$(msg -verm2 "➛ ")$(msg -azu "BADVPN        ${inst[badvpn]}")  \e[1;93m[\e[92m19\e[93m]$(msg -verm2 "➛ ")$(msg -azu "ARCHIVO ONLINE")"
	echo -e "\e[1;93m[\e[92m2\e[93m]$(msg -verm2 "➛ ")$(msg -azu "SOCKS LIBEV   ${inst[ss - server]}")  \e[1;93m[\e[92m20\e[93m]$(msg -verm2 "➛ ")$(msg -azu "FIREWALL")"
	echo -e "\e[1;93m[\e[92m3\e[93m]$(msg -verm2 "➛ ")$(msg -azu "SOCKS PYTHON  ${inst[python]}")  \e[1;93m[\e[92m21\e[93m]$(msg -verm2 "➛ ")$(msg -azu "FAIL2BAN PROTECION")"
	echo -e "\e[1;93m[\e[92m4\e[93m]$(msg -verm2 "➛ ")$(msg -azu "V2RAY         ${inst[v2ray]}")  \e[1;93m[\e[92m22\e[93m]$(msg -verm2 "➛ ")$(msg -azu "DETALLES DE SISTEMA")"
	echo -e "\e[1;93m[\e[92m5\e[93m]$(msg -verm2 "➛ ")$(msg -azu "SSL/TLS       ${inst[stunnel4]}")  \e[1;93m[\e[92m23\e[93m]$(msg -verm2 "➛ ")$(msg -azu "TCP (BBR|BBR-Plus)")"
	echo -e "\e[1;93m[\e[92m6\e[93m]$(msg -verm2 "➛ ")$(msg -azu "DROPBEAR      ${inst[dropbear]}")  \e[1;93m[\e[92m24\e[93m]$(msg -verm2 "➛ ")$(msg -azu "DNS NETFLIX")"
	echo -e "\e[1;93m[\e[92m7\e[93m]$(msg -verm2 "➛ ")$(msg -azu "SQUID         ${inst[squid]}")  \e[1;93m[\e[92m25\e[93m]$(msg -verm2 "➛ ")$(msg -azu "LIBERAR RAM")"
	echo -e "\e[1;93m[\e[92m8\e[93m]$(msg -verm2 "➛ ")$(msg -azu "OPENVPN       ${inst[openvpn]}")  \e[1;93m[\e[92m26\e[93m]$(msg -verm2 "➛ ")$(msg -azu "SCANNER SUBDOMINIO")"
	echo -e "\e[1;93m[\e[92m9\e[93m]$(msg -verm2 "➛ ")$(msg -azu "SLOWDNS       ${inst[dns - serve]}")  \e[1;93m[\e[92m27\e[93m]$(msg -verm2 "➛ ")$(msg -azu "PRUEBA DE VELOCIDAD")"
	echo -e "\e[1;93m[\e[92m10\e[93m]$(msg -verm2 "➛ ")$(msg -azu "MONITOR APP  $app")  \e[1;93m[\e[92m28\e[93m]$(msg -verm2 "➛ ")$(msg -azu "FIX ORACLE/AWS/AZR")"
	echo -e "\e[1;93m[\e[92m11\e[93m]$(msg -verm2 "➛ ")$(msg -azu "BOT TELEGRAM $AD")  \e[1;93m[\e[92m29\e[93m]$(msg -verm2 "➛ ")$(msg -azu "\e[91m\e[43mHERRAMIENTAS BASICOS\e[0m")"
	echo -e "\e[1;93m[\e[92m12\e[93m]$(msg -verm2 "➛ ")$(msg -azu "WIREGUARD    ${inst[wg]}")  $(msg -verd "[0] ")$(msg -verm2 "➛ ")$(msg -azu "⇚ VOLVER  ")"
	msg -bar
	echo -e "\e[1;93m[\e[92m13\e[93m]$(msg -verm2 "➛ ")$(msg -azu "NOTI-BOT     $noty")  \e[1;93m[\e[92m16\e[93m]$(msg -verm2 "➛ ")$(msg -azu "UDP-ZIVPN    $ziv")"
	echo -e "\e[1;93m[\e[92m14\e[93m]$(msg -verm2 "➛ ")$(msg -azu "CHECK-USER   $chek")  \e[1;93m[\e[92m17\e[93m]$(msg -verm2 "➛ ")$(msg -azu "UDPs Request $uds")"
	echo -e "\e[1;93m[\e[92m15\e[93m]$(msg -verm2 "➛ ")$(msg -azu "PSIPHON      $psh")  \e[1;93m[\e[92m18\e[93m]$(msg -verm2 "➛ ")$(msg -azu "UDP-CUSTOM   $udpc")"
	echo -e "\e[1;93m[\e[92mE\e[93m] $(msg -verm2 "➛ ")$(msg -azu "WS~PRO       $P9")  \e[1;93m[\e[92mL\e[93m] $(msg -verm2 "➛ ")$(msg -azu "HYSTERIA-UDP $hy")"
	echo -e "\e[1;93m[\e[92mT\e[93m] $(msg -verm2 "➛ ")$(msg -azu "TROJAN-GO    ${inst[trojan]}")  "
	msg -bar
	echo -ne " ►\e[1;37m Selecione Una Opcion: \e[33m " && read select
	case $select in
	0) return 0 ;;
	T | t)
		if [[ ! -e /usr/bin/trjan.sh ]]; then
			fun_bar 'cargando'
			wget --no-check-certificate -O /usr/bin/trjan.sh 'https://www.dropbox.com/scl/fi/7buzr9nkn4alasv1wuia4/trojann.sh?rlkey=sgh9jbrl0h26x3um6gxjdyocb&dl=0' &>/dev/null && chmod 777 /usr/bin/trjan.sh
			trjan.sh
			msg -ne "Enter Para Continuar" && read enter
			menu3
		else
			trjan.sh
			msg -ne "Enter Para Continuar" && read enter
			menu3
		fi
		;;
	1)
		funbadvpn && msg -ne "Enter Para Continuar" && read enter
		menu3
		;;
	2)
		funshadow && msg -ne "Enter Para Continuar" && read enter
		menu3
		;;
	3)
		funpython && msg -ne "Enter Para Continuar" && read enter
		menu3
		;;
	4)
		v2ra && msg -ne "Enter Para Continuar" && read enter
		menu3
		;;
	5)
		funssl && msg -ne "Enter Para Continuar" && read enter
		menu3
		;;
	6)
		fundrop && msg -ne "Enter Para Continuar" && read enter
		menu3
		;;
	7)
		${SCPinst}/squid.sh && msg -ne "Enter Para Continuar" && read enter
		menu3
		;;
	8)
		${SCPinst}/openvpn.sh && msg -ne "Enter Para Continuar" && read enter
		menu3
		;;
	9)
		${SCPinst}/slowdns.sh && msg -ne "Enter Para Continuar" && read enter
		menu3
		;;
	#
	#herramientas
	10)
		menuapp && msg -ne "Enter Para Continuar" && read enter
		menu3
		;;
	11) adminbot ;;
	12)
		${SCPinst}/wireguard.sh && msg -ne "Enter Para Continuar" && read enter
		menu3
		;;
	13) noti ;;
	14)
		${SCPinst}/chekuser.sh && msg -ne "Enter Para Continuar" && read enter
		menu3
		;;
	15)
		clear
		instalador_psiphon1() {
			clear
			if ps aux | grep 'psiphond' | grep -v grep >/dev/null; then echo -e "El proceso psiphond ya está activo." exit 1; fi

			msg -bar
			msg -tit

			msg -ama "            INSTALADOR PSIPHON SERVER"
			msg -bar
			echo -e "\033[1;97m Ingrese los puertos segun su necesidad\033[1;97m\n"

			rm -rf /root/psi
			kill $(ps aux | grep 'psiphond' | awk '{print $2}') 1>/dev/null 2>/dev/null
			killall psiphond 1>/dev/null 2>/dev/null
			cd /root
			mkdir psi
			cd /root/psi
			myip=$IP
			curl -o /root/psi/psiphond https://raw.githubusercontent.com/Psiphon-Labs/psiphon-tunnel-core-binaries/master/psiphond/psiphond 1>/dev/null 2>/dev/null
			chmod 777 psiphond
			echo -ne "\033[1;97m Escribe el puerto para Psiphon SSH:\033[32m " && read -p " " -e -i "23" sh
			echo -ne "\033[1;97m Escribe el puerto para Psiphon OSSH:\033[32m " && read osh
			echo -ne "\033[1;97m Escribe el puerto para Psiphon FRONTED-MEEK-OSSH:\033[32m " && read fm
			echo -ne "\033[1;97m Escribe el puerto para Psiphon UNFRONTED-MEEK-OSSH:\033[32m " && read umo
			echo -e "$sh\n$osh\n$fm\n$umo" >/root/psi/ports.txt
			./psiphond --ipaddress $myip --protocol SSH:$sh --protocol OSSH:$osh --protocol FRONTED-MEEK-OSSH:$fm --protocol UNFRONTED-MEEK-OSSH:$umo generate
			chmod 666 psiphond.config
			chmod 666 psiphond-traffic-rules.config
			chmod 666 psiphond-osl.config
			chmod 666 psiphond-tactics.config
			chmod 666 server-entry.dat

			cat server-entry.dat >/root/psi/psi.txt
			#screen -dmS psiserver ./psiphond run
			cat <<EOF >/etc/systemd/system/psiserver.service
[Unit]
Description=psiserver by lacasitamx

[Service]
User=root
Type=simple
ExecStart=/root/psi/psiphond run
WorkingDirectory=/root/psi/
Restart=always
RestartSec=2s

[Install]
WantedBy=default.target
EOF

			systemctl enable psiserver &>/dev/null
			systemctl start psiserver &>/dev/null

			cd /root
			psi=$(cat /root/psi/psi.txt)
			echo -e "\033[1;33m LA CONFIGURACION DE TU SERVIDOR ES:\033[0m"
			msg -bar
			echo -e "\033[1;32m $psi \033[0m"
			msg -bar
			echo -e "\033[1;97m PROTOCOLOS HABILITADOS:\033[0m"
			msg -bar
			echo -e "\033[1;33m → SSH:\033[1;32m $sh \033[0m"
			echo -e "\033[1;33m → OSSH:\033[1;32m $osh \033[0m"
			echo -e "\033[1;33m → FRONTED-MEEK-OSSH:\033[1;32m $fm \033[0m"
			echo -e "\033[1;33m → UNFRONTED-MEEK-OSSH:\033[1;32m $umo \033[0m"
			msg -bar
			echo -e "\033[93m DIRECTORIO DE ARCHIVOS:\033[1;32m /root/psi \033[0m"
			msg -bar
			[[ "$(ps aux | grep psiphond | grep -v grep)" ]] && msg -verd "    >> SERVIDOR-PSIPHON INSTALADO CON EXITO <<" || msg -ama "                  ERROR VERIFIQUE"
			msg -bar
			msg -ne "Enter Para Continuar" && read enter
			menu3
		}
		instalador_psiphon() {
			clear
			#   if ps aux | grep 'psiphond' | grep -v grep >/dev/null; then echo -e "El proceso psiphond ya está activo." exit 1; fi
			if [[ -e /root/psi/psi.txt ]]; then
				echo -e "El proceso psiphond ya está activo."
				return 0
			else
				msg -bar
				msg -tit

				msg -ama "         BINARIO OFICIAL DE Epro Dev Team"
				msg -bar
				echo -e "\033[1;33m SE RECOMIENDA : HTTP-OSSH 80 y OSSH 443\033[0m"
				msg -bar

				[[ ! -d /root/psi ]] && mkdir /root/psi
				cd /root/psi
				myip=$IP
				wget 'https://docs.google.com/uc?export=download&id=1Cg_YsTDt_aqK_EXbnzP9tRFSyFe_7N-m' -O 'psiphond' 2>/dev/null
				chmod 775 psiphond
				#1
				while true; do
					#echo -e "\033[1;33m Escribe el puerto para FRONTED-MEEK-HTTP-OSSH\033[33m "
					read -p " FRONTED-MEEK-HTTP-OSSH: " httposh
					#tput cuu1 >&2 && tput dl1 >&2
					PortSSL=$(netstat -tlpn | awk -F '[: ]+' '$1=="tcp"{print $5}' | grep -w $httposh)
					[[ -n "$PortSSL" ]] || break
					prococup=$(netstat -tlpn | awk -F '[: ]+' '$5=="$httposh"{print $9}')
					echo -e "\033[1;33m  EL PUERTO SE ENCUENTRA OCUPADO POR $prococup"
					msg -bar
					return
				done
				#FIN 1
				#2
				while true; do
					#echo -e "\033[1;33m Escribe el puerto para FRONTED-MEEK-OSSH:\033[33m"
					read -p " FRONTED-MEEK-OSSH: " osh
					#tput cuu1 >&2 && tput dl1 >&2
					PortSSL=$(netstat -tlpn | awk -F '[: ]+' '$1=="tcp"{print $5}' | grep -w $osh)
					[[ -n "$PortSSL" ]] || break
					prococup=$(netstat -tlpn | awk -F '[: ]+' '$5=="$osh"{print $9}')
					echo -e "\033[1;33m  EL PUERTO SE ENCUENTRA OCUPADO POR $prococup"
					msg -bar
					return
				done
				#FIN 2

				cd /root/psi
				./psiphond --ipaddress 0.0.0.0 --protocol FRONTED-MEEK-HTTP-OSSH:$httposh --protocol FRONTED-MEEK-OSSH:$osh generate
				chmod 666 psiphond.config
				chmod 666 psiphond-traffic-rules.config
				chmod 666 psiphond-osl.config
				chmod 666 psiphond-tactics.config
				chmod 666 server-entry.dat

				cat server-entry.dat >/root/psi/psi.txt
				cat <<EOF >/etc/systemd/system/psiserver.service
[Unit]
Description=psiserver by lacasitamx

[Service]
User=root
Type=simple
ExecStart=/root/psi/psiphond run
WorkingDirectory=/root/psi/
Restart=always
RestartSec=2s

[Install]
WantedBy=default.target
EOF

				systemctl enable psiserver &>/dev/null
				systemctl start psiserver &>/dev/null
				#screen -dmS psiserver ./psiphond run

				cd /root
				_SFTP="$(lsof -V -i tcp -P -n | grep -v "ESTABLISHED" | grep -v "COMMAND" | grep "LISTEN" | grep apache2)"

				portFTP=$(echo -e "$_SFTP" | cut -d: -f2 | cut -d' ' -f1 | uniq)
				portFTP=$(echo ${portFTP} | sed 's/\s\+/,/g' | cut -d , -f1)

				psi=$(cat /root/psi/psi.txt)
				echo -e "\033[1;33m SERVER CONFIG:\033[0m"
				msg -bar
				echo -e "\033[1;32m $psi \033[0m"
				msg -bar
				echo -e "\033[1;97m PROTOCOLOS HABILITADOS:\033[0m"
				echo -e "\033[1;33m FRONTED-MEEK-HTTP-OSSH:\033[1;32m $httposh \033[0m"
				echo -e "\033[1;33m FRONTED-MEEK-OSSH:\033[1;32m $osh \033[0m"
				msg -bar
				echo -e "\033[1;33m DIRECTORIO DE ARCHIVOS:\033[1;32m /root/psi \033[0m"
				[[ -z $portFTP ]] && echo -e "SERVICIO FTP NO ACTIVO " || {
					#IP="$(wget -qO- ifconfig.me)"
					cp /root/psi/psi.txt /var/www/html/psi.txt
					echo -e "\033[1;33m RUTA PUBLICA DE CONFIG GENERADA:\033[1;32m http://$IP:${portFTP}//psi.txt \033[0m"

					msg -bar
					[[ "$(ps aux | grep psiphond | grep -v grep)" ]] && msg -verd "    >> SERVIDOR-PSIPHON INSTALADO CON EXITO <<" || msg -ama "                  ERROR VERIFIQUE"
					msg -bar
					msg -ne "Enter Para Continuar" && read enter
					menu3
				}
			fi
		}

		desactivar_psiphon() {
			clear
			msg -bar
			echo -e "\033[1;31m            DESISNTALANDO PUERTOS PSIPHON-SERVER "
			msg -bar
			systemctl stop psiserver &>/dev/null
			systemctl disable psiserver &>/dev/null
			rm -rf /etc/systemd/system/psiserver.service
			rm -rf /root/psi
			rm -rf /root/psi/psi.txt
			rm /bin/psiphond &>/dev/null
			rm /var/www/html/psi.txt &>/dev/null
			[[ "$(ps aux | grep psiphond | grep -v grep)" ]] && echo -e "\033[1;32m        >> PSIPHON-SERVER DESINSTALADO CON EXITO << "
			msg -ne "Enter Para Continuar" && read enter
			menu3
		}

		clear
		[[ $(ps x | grep psiphond | grep -v grep) ]] && psh="\033[1;32m[ACTIVO]" || psh="\033[1;31m[OFF]"

		msg -tit

		msg -ama "            INSTALADOR DE PSIPHON-CUSTOM"
		msg -bar
		if [[ ! -e /bin/psiphond ]]; then
			curl -o /bin/psiphond https://raw.githubusercontent.com/Psiphon-Labs/psiphon-tunnel-core-binaries/master/psiphond/psiphond &>/dev/null
			chmod 777 /bin/psiphond
		fi

		echo -ne " \e[1;93m [\e[1;32m1\e[1;93m]\033[1;31m > \e[1;97m INSTALAR PSIPHON OFICIAL\n"
		echo -ne " \e[1;93m [\e[1;32m2\e[1;93m]\033[1;31m > \e[1;97m INSTALAR PSIPHON HTTP-CUSTOM \n"
		echo -ne " \e[1;93m [\e[1;32m3\e[1;93m]\033[1;31m > \033[1;91m DETENER SERVICIO PSIPHON \n"
		echo -ne " \e[1;93m [\e[1;32m4\e[1;93m]\033[1;31m > \033[1;92m CONFIG SERVER-ENTRY.DAT \n"
		echo -ne " \e[1;93m [\e[1;32m5\e[1;93m]\033[1;31m > \033[1;93m EDITAR CLIENTE PSIPHON\n"
		msg -bar
		echo -ne " \e[1;93m [\e[1;32m0\e[1;93m]\033[1;31m > \033[1;97m" && msg -bra "  \e[97m\033[1;41m VOLVER \033[1;37m"
		msg -bar
		echo -ne "\033[1;97mDigite Una Opcion:\e[32m "
		read opcao
		case $opcao in

		1)
			msg -bar
			instalador_psiphon1
			;;
		2)
			msg -bar
			instalador_psiphon
			;;
		3)
			msg -bar
			desactivar_psiphon
			;;
		4)
			clear
			echo -e "\e[97m $(cat /root/psi/psi.txt)"
			msg -bar
			#echo -e "\033[1;97m PROTOCOLOS HABILITADOS:\033[0m"
			#  msg -bar
			;;
		5)
			clear
			cd /root/psi

			rm -rf encode.dat
			rm -rf server.json
			data=$1
			if [[ -z $data ]]; then
				data='/root/psi/server-entry.dat'
			fi
			cat $data | xxd -r -p | sed 's/0 0 0 0 //' | jq . >server.json
			nano server.json
			init='0 0 0 0 '
			body=$(jq -c . server.json)
			echo "$init$body" | xxd -ps | tr -d '\n' >server-entry.dat
			clear

			cat server-entry.dat >/root/psi/psi.txt
			clear
			msg -bar
			echo -e "\e[97m $(cat /root/psi/psi.txt)"
			msg -bar
			rm server.json
			cd /root
			;;
		0)
			return 0
			;;
		*)
			echo -e "Porfavor use numeros del [0-3]"
			msg -bar
			return 0
			;;
		esac
		;;
	e | E)
		dios() {
			mportas() {
				unset portas
				portas_var=$(lsof -V -i tcp -P -n | grep -v "ESTABLISHED" | grep -v "COMMAND" | grep "LISTEN")
				while read port; do
					var1=$(echo $port | awk '{print $1}') && var2=$(echo $port | awk '{print $9}' | awk -F ":" '{print $2}')
					[[ "$(echo -e $portas | grep "$var1 $var2")" ]] || portas+="$var1 $var2\n"
				done <<<"$portas_var"
				i=1
				echo -e "$portas"
			}
			clear
			echo ""
			msg -tit
			msg -bar
			echo -e "\033[1;31m  WS-LACASITAMX | CUSTOM\033[0m"
			while true; do
				msg -bar
				echo -ne "\033[1;37m"
				read -p " ESCRIBE SU PUERTO: " porta_socket
				echo -e ""
				[[ $(mportas | grep -w "$porta_socket") ]] || break
				echo -e " ESTE PUERTO YA ESTÁ EN USO"
				unset porta_socket
			done
			msg -bar
			echo -e "\033[1;97m Digite Un Puerto Local 22|443|80\033[1;37m"
			msg -bar
			while true; do
				echo -ne "\033[1;36m"
				read -p " Digite Un Puerto SSH/DROPBEAR activo: " PORTLOC
				echo -e ""
				if [[ ! -z $PORTLOC ]]; then
					if [[ $(echo $PORTLOC | grep [0-9]) ]]; then
						[[ $(mportas | grep $PORTLOC | head -1) ]] && break || echo -e "ESTE PUERTO NO EXISTE"
					fi
				fi
			done
			#
			puertoantla="$(mportas | grep $PORTLOC | awk '{print $2}' | head -1)"
			msg -bar

			wget -O /bin/DIOS https://github.com/lacasitamx/SCRIPTMOD-LACASITA/raw/master/jesus &>/dev/null

			chmod 777 /bin/DIOS
			echo -e "[Unit]
Description=ws-lacasitamx  Service
After=network.target
StartLimitIntervalSec=0

[Service]
Type=simple
User=root
WorkingDirectory=/root
ExecStart=/bin/DIOS 0.0.0.0:${porta_socket} 127.0.0.1:${puertoantla}
Restart=always
RestartSec=3s

[Install]
WantedBy=multi-user.target" >/etc/systemd/system/ws-lacasitamx.service

			systemctl enable ws-lacasitamx &>/dev/null
			systemctl start ws-lacasitamx &>/dev/null
			systemctl restart ws-lacasitamx &>/dev/null
			msg -verd "    >> SERVICIO-WS~PRO INSTALADO CON EXITO <<"
		}
		unla() {
			#pkill -f ws-lacasitamx
			rm /bin/DIOS &>/dev/null
			systemctl stop ws-lacasitamx &>/dev/null
			systemctl disable ws-lacasitamx &>/dev/null
			rm /etc/systemd/system/ws-lacasitamx.service &>/dev/null
			msg -ama "    >> SERVICIO-WS~PRO DETENIDO CON EXITO <<"
		}

		clear
		[[ $(ps x | grep DIOS | grep -v grep) ]] && P9="\033[1;32m[ON]" || P9="\e[37m[\033[1;31mOFF\e[37m]"
		msg -tit
		msg -bar
		echo -e "   	\e[91m\e[43mINSTALADOR WS-PRO BY @LACASITAMX\e[0m "
		msg -bar

		echo -e " \e[1;93m[\e[92m1\e[93m] \e[97m$(msg -verm2 "➛ ")\033[1;97mINSTALAR SERVICIO WS-PRO $P9"
		echo -e " \e[1;93m[\e[92m2\e[93m] \e[97m$(msg -verm2 "➛ ")\033[1;97mDESINSTALAR WS-PRO"
		echo -e " \e[1;93m[\e[92m0\e[93m] \e[97m$(msg -verm2 "➛ ")\033[1;97mVOLVER"
		msg -bar
		echo -ne " Digite Una Opcion :\033[1;37m "
		read portproxy
		case $portproxy in
		1)
			dios && msg -ne "Enter Para Continuar" && read enter
			menu3
			;;
		2)
			unla && msg -ne "Enter Para Continuar" && read enter
			menu3
			;;
		0) menu3 ;;
		esac

		;;
	16)
		clear
		instalaziv() {
			if [[ ! -e /usr/local/bin/zivpn ]]; then

				#echo -e "Updating server"
				#sudo apt-get update && apt-get upgrade -y
				echo -e "Downloading Service"

				mkdir -p /etc/zivpn 1>/dev/null 2>/dev/null
				local _config='/etc/zivpn/config.json'
				echo "Generando certificados:"
				openssl req -new -newkey rsa:4096 -days 365 -nodes -x509 -subj "/C=US/ST=California/L=Los Angeles/O=Example Corp/OU=IT Department/CN=zivpn" -keyout "/etc/zivpn/zivpn.key" -out "/etc/zivpn/zivpn.crt" &>/dev/null
				sysctl -w net.core.rmem_max=16777216 1>/dev/null 2>/dev/null
				sysctl -w net.core.wmem_max=16777216 1>/dev/null 2>/dev/null
				local _enviorement="ExecStart=/bin/ZipVPN -config ${_config} server"
				local _enviorementPATCH='Environment="PATH=/etc/zivpn:/usr/bin:/bin"'
				#  local _linkC='https://raw.githubusercontent.com/lacasitamx/BIN/main/BINARIOS/UDP/ZipVPN/config/configv1.json'
				local _linkB='https://raw.githubusercontent.com/lacasitamx/BIN/main/BINARIOS/UDP/ZipVPN/udp-x64_v1.bin'
				msg -nama '     COMPILANDO BINARIO DE AUTENTIFICACION SSH V2'
				if wget -O /bin/authSSH https://github.com/lacasitamx/UDP/raw/main/autSSH &>/dev/null; then
					chmod +x /bin/authSSH

					msg -verd ' OK'
				else
					msg -verm ' FAIL '
					rm -rf /bin/authSSH
				fi

				msg -nama "	DESCARGANDO BIN V2.0"
				if wget -O /bin/ZipVPN ${_linkB} &>/dev/null; then
					chmod +x /bin/ZipVPN

					msg -verd ' OK'
				else
					msg -verm ' FAIL '
					rm -f /bin/ZipVPN
				fi
				msg -bar
				echo " IP : $IP" >/etc/zivpn/data
				echo " Usuarios SSH del sistema !!" >>/etc/zivpn/data
				echo " PUERTO : 5667" >>/etc/zivpn/data
				echo " RANGO DE PUERTO: 6000:19999" >>/etc/zivpn/data
				echo " OBFS: lacasita" >>/etc/zivpn/data
				echo " RECUERDA UTILIZAR USUARIO Y CLAVE SSH" >>/etc/zivpn/data
				echo " FORMATO SSH EN APP : miusuario" >>/etc/zivpn/data
				echo -e " \n 	Zipvpn" >>/etc/zivpn/data

				msg -nama "	DESCARGANDO CONFIG"
				cat <<EOF >/etc/zivpn/config.json
{
  "listen": ":5667",
   "cert": "/etc/zivpn/zivpn.crt",
   "key": "/etc/zivpn/zivpn.key",
   "obfs":"lacasita",
	"auth": {
    "mode": "external",
    "config": {
      "cmd": "/bin/authSSH" 
    }
  }
}
EOF
				chmod +x ${_config}
				msg -verd ' OK'

				cat <<EOF >/etc/systemd/system/zivpn.service
[Unit]
Description=ZipVPN Server
After=network.target

[Service]
Type=simple
User=root
WorkingDirectory=/etc/zivpn
${_enviorement}
Restart=always
RestartSec=3
${_enviorementPATCH}
CapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_BIND_SERVICE CAP_NET_RAW
AmbientCapabilities=CAP_NET_ADMIN CAP_NET_BIND_SERVICE CAP_NET_RAW
NoNewPrivileges=true

[Install]
WantedBy=multi-user.target
EOF

				systemctl daemon-reload &>/dev/null
				systemctl enable zivpn &>/dev/null
				systemctl start zivpn &>/dev/null
				rm -f zi.*

				iptables -t nat -A PREROUTING -i $(ip -4 route ls | grep default | grep -Po '(?<=dev )(\S+)' | head -1) -p udp --dport 6000:19999 -j DNAT --to-destination :5667
				ufw allow 6000:19999/udp &>/dev/null
				ufw allow 5667/udp &>/dev/null
				clear
				msg -bar
				msg -ama "	CONFIGURACION DE DATOS\n"

				cat /etc/zivpn/data
				msg -bar
				echo -e "$(msg -verd 'SERVICIO UDP-ZIPVPN INICIADO EXITOSAMENTE')"
				echo -e "\e[97mRECUERDA CREAR UN USUARIO SSH PARA TU CONEXION!!!\e[0m"
			else
				echo -e "\e[1;93m	EL SERVICIO UDP ZIPVPN YA ESTA ACTIVO\e[0m"

			fi
		}
		clear
		msg -tit
		[[ $(ps x | grep zivpn | grep -v grep) ]] && zi="\033[1;32m[ON] " || zi="\033[1;31m[OFF]"
		if [[ $(ps x | grep zivpn | grep -v grep) ]]; then

			o=$(sed -n '5 p' /etc/zivpn/data | cut -d':' -f2)
			por=$(sed -n '3 p' /etc/zivpn/data | cut -d':' -f2)
			msg -ama "  IP: \e[92m$IP"
			msg -ama "  OBFS: \e[92m$o"
			msg -ama "  RANGO DE PUERTO:\e[92m6000:19999"
			msg -ama "  PUERTO UDP: $por \e[0m"

		else
			msg -ama "\033[1;31m[No Instalado]"

		fi
		msg -bar
		echo -ne " \e[1;93m [\e[1;32m1\e[1;93m]\033[1;31m > \e[1;92m INSTALAR UDP-ZIVPN $ziv\n"
		echo -ne " \e[1;93m [\e[1;32m2\e[1;93m]\033[1;31m > \033[1;93m MODIFICAR PUERTO \n"
		echo -ne " \e[1;93m [\e[1;32m3\e[1;93m]\033[1;31m > \033[1;93m MODIFICAR OBFS \n"
		msg -bar
		echo -ne " \e[1;93m [\e[1;32m4\e[1;93m]\033[1;31m > \033[1;91m DETENER UDP-ZIVPN \n"
		echo -ne " \e[1;93m [\e[1;32m5\e[1;93m]\033[1;31m > \033[1;93m REINICIAR SERVICIO \n"
		echo -ne " \e[1;93m [\e[1;32m6\e[1;93m]\033[1;31m > \033[1;97m DATOS DEL SERVICIO \n"
		msg -bar
		echo -ne " \e[1;93m [\e[1;32m0\e[1;93m]\033[1;31m > \033[1;97m" && msg -bra "  \e[97m\033[1;41m VOLVER \033[1;37m"
		msg -bar
		echo -ne "\033[1;97mDigite Una Opcion:\e[32m "
		read opcao
		case $opcao in
		0) menu3 ;;
		1)
			clear
			msg -tit
			instalaziv
			;;
		2)
			clear && clear
			unset _col
			msg -bar
			msg -ama "INGRESE EL NUEVO PUERTO DE SERVICIO "
			read -p " PUERTO : " _col
			#
			_PA=$(cat /etc/zivpn/config.json | grep 'listen' | cut -d'"' -f4 | cut -d':' -f2)

			[[ ${_col} ]] && {
				sed -i "s/${_PA}/${_col}/" /etc/zivpn/config.json
				sed -i "s/${_PA}/${_col}/" /etc/zivpn/data
				systemctl restart zivpn &>/dev/null
				msg -ama "	PUERTO NUEVO: $_col"
			}
			;;
		3)
			clear && clear
			unset _col
			msg -bar
			msg -ama "INGRESE SU NUEVO OBFS "
			read -p " OBFS : " _col
			_obfs=$(cat /etc/zivpn/config.json | grep 'obfs' | cut -d'"' -f4)

			[[ ${_col} ]] && {
				sed -i "s/${_obfs}/${_col}/" /etc/zivpn/config.json
				sed -i "s/${_obfs}/${_col}/" /etc/zivpn/data
				systemctl restart zivpn &>/dev/null
				msg -ama "	OBFS MODIFICADO: $_col"
			}
			;;
		4)
			clear
			msg -tit

			systemctl stop zivpn &>/dev/null
			systemctl disable zivpn &>/dev/null
			rm -rf /etc/systemd/system/zivpn.service
			rm -rf /bin/ZipVPN
			rm -rf /etc/zivpn
			msg -ama "	SERVICIO DETENIDO"
			msg -bar
			;;
		5)
			clear
			msg -tit
			systemctl restart zivpn &>/dev/null
			msg -ama "	SERVICIO Reiniciado"
			msg -bar
			;;
		6)
			clear
			msg -tit
			msg -bra "$(cat /etc/zivpn/data)"
			;;
		esac
		;;
	17)
		installudp() {
			clear
			msg -nama " Descargando binario UDPserver ....."
			if wget -O /usr/bin/udpServer 'https://bitbucket.org/iopmx/udprequestserver/downloads/udpServer' &>/dev/null; then
				chmod +x /usr/bin/udpServer
				msg -verd 'Instalado'
			else
				msg -verm2 'Falla'
				rm -rf /usr/bin/udpServer*
				return
			fi

			ip_nat=$(ip -4 addr | grep inet | grep -vE '127(\.[0-9]{1,3}){3}' | cut -d '/' -f 1 | grep -oE '[0-9]{1,3}(\.[0-9]{1,3}){3}' | sed -n 1p)
			interfas=$(ip -4 addr | grep inet | grep -vE '127(\.[0-9]{1,3}){3}' | grep "$ip_nat" | awk {'print $NF'})
			ip_publica=$(grep -m 1 -oE '^[0-9]{1,3}(\.[0-9]{1,3}){3}$' <<<"$(wget -T 10 -t 1 -4qO- "http://ip1.dynupdate.no-ip.com/" || curl -m 10 -4Ls "http://ip1.dynupdate.no-ip.com/")")

			cat <<EOF >/etc/systemd/system/UDPserver.service
[Unit]
Description=UDPserver Service
After=network.target

[Service]
Type=simple
User=root
WorkingDirectory=/root
ExecStart=/usr/bin/udpServer -ip=$ip_publica -net=$interfas -mode=system 
Restart=always
RestartSec=3s

[Install]
WantedBy=multi-user.target6
EOF

			msg -nama " Ejecutando servicio UDPserver ....."
			if [[ $(systemctl is-active UDPserver) = 'active' ]]; then
				systemctl enable UDPserver &>/dev/null
				systemctl start UDPserver &>/dev/null

				msg -verd 'OK'
			else
				msg -verm "falla"
			fi

		}

		remove() {
			clear
			msg -ama "	DESINSTALADOR UDPserver"
			read -rp " $(msg -ama "QUIERE DESINSTALAR UDPserver? [S/N]:") " -e -i S UNINS
			[[ $UNINS != @(S|s) ]] && return
			systemctl stop UDPserver &>/dev/null
			systemctl disable UDPserver &>/dev/null
			rm -rf /etc/systemd/system/UDPserver.service
			rm -rf /usr/bin/udpServer
			tput cuu1 >&2 && tput dl1 >&2
			msg -ama "desinstalacion completa!"
		}

		reset() {
			if [[ $(systemctl is-active UDPserver) = 'active' ]]; then
				systemctl stop UDPserver &>/dev/null
				systemctl disable UDPserver &>/dev/null
				msg -ama 'UDPserver detenido!'
			else
				systemctl start UDPserver &>/dev/null
				if [[ $(systemctl is-active UDPserver) = 'active' ]]; then
					systemctl enable UDPserver &>/dev/null
					msg -verd 'UDPserver iniciado!'
				else
					msg -verm2 'falla al inciar UDPserver!'
				fi
			fi

		}
		clear
		if [[ $(systemctl is-active UDPserver) = 'active' ]]; then
			estado="\e[92m[ON] "
		else
			estado="\e[91m[OFF]"
		fi

		msg -tit
		msg -verd "         BINARIO OFICIAL DE NewToolWorks"

		msg -bar
		msg -ama "\e[93m         INSTALADOR UDP-SERVER"
		echo -e "         \e[97mSolo Funciona en Ubuntu 20+"
		msg -bar
		echo -e "\e[1;93m	SERVICIO: $estado\e[0m"
		msg -bar
		echo -e "  $(msg -verd "[1]")$(msg -verm2 "➛ ")$(msg -azu " Instalar UDPserver")  "
		echo -e "  $(msg -verd "[2]")$(msg -verm2 "➛ ")$(msg -verm " \e[93mREINICIAR | DETENER")  "
		echo -e "  $(msg -verd "[3]")$(msg -verm2 "➛ ")$(msg -verm2 " Desinstalar servicio")  "
		echo -e "  $(msg -verd "[0]")$(msg -verm2 "➛ ")$(msg -azu " VOLVER")  "
		msg -bar
		echo -ne "  \033[1;37mSelecione Una Opcion : "
		read opc
		case $opc in
		1) installudp ;;
		2) reset ;;
		3) remove ;;
		0) menu3 ;;
		esac

		;;
	18)
		instalar_udp() {
			mkdir -p /etc/udpc
			if [[ -e /bin/udp-custom ]]; then
				clear
				msg -bar
				msg -verd "	SERVICIO UDP CUSTOM YA ACTIVO"
				msg -bar
			else
				msg -bar
				msg -nverd "	Descargando binario UDP-CUSTOM ----"
				#
				# install udp-custom
				#msg -verd "descargando binario udp-custom"
				#wget -O /root/udp/udp-custom raw.github.com/lacasitamx/UDPcustom/master/udp-custom &>/dev/null
				#chmod +x /root/udp/udp-custom
				#
				[[ $(uname -m 2>/dev/null) != x86_64 ]] && {
					if wget -O /bin/udp-custom 'https://github.com/lacasitamx/BIN/raw/main/BINARIOS/udp-arm64.bin' &>/dev/null; then
						chmod +x /bin/udp-custom
						msg -verd ' ARM64 - OK'
					else
						msg -verm2 'Falla'
						rm -rf /bin/udp-custom*
					fi
				} || {
					if wget -O /bin/udp-custom 'https://github.com/lacasitamx/BIN/raw/main/BINARIOS/udp-amd64.bin' &>/dev/null; then
						chmod +x /bin/udp-custom
						msg -verd ' AMD64 OK'
					else
						msg -verm2 'Falla'
						rm -rf /bin/udp-custom*
					fi
				}
				msg -verd "descargando configuracion"
				#wget -O /root/udp/config.json raw.github.com/lacasitamx/UDPcustom/master/config.json &>/dev/null
				cat <<ud >/etc/udpc/config.json
{
"listen": ":36712",
"auth": {
"mode": "passwords"
}
}
ud
				chmod 644 /etc/udpc/config.json
				add_fire() {
					msg -verd "	CONFIGURANDO FIREWALL"
					msg -bar
					sudo apt install firewalld -y &>/dev/null

					sudo firewall-cmd --zone=public --permanent --add-port=36712/udp &>/dev/null

					sudo firewall-cmd --reload &>/dev/null
					sudo firewall-cmd --zone=public --list-ports &>/dev/null
				}
				#echo -e "\e[1;93m	DESEA AGREGAR FIREWALLD CMD AL SISTEMA UDP\e[0m\n	OJO EN ALGUNAS VPS ES NECESARIO AGREGAR LOS PERMISOS FIREWALLD POR EJEMPLO,AZURE,AWS,ETC.."
				#read -p "Responde [ s | n ]: " -e s -i add_fire
				# [[ "$add_fire" = "s" || "$add_fire" = "S" ]] &&
				add_fire
				clear
				msg -tit

				msg -ama "        \e[1;33mEjecutando servicio UDP-CUSTOM ....."
				if [ -z "$1" ]; then
					cat <<EOF >/etc/systemd/system/UDPcustom.service
[Unit]
Description=UDPcustom by ePro Dev. Team

[Service]
User=root
Type=simple
ExecStart=/bin/udp-custom server --config /etc/udpc/config.json
WorkingDirectory=/etc/udpc/
Restart=always
RestartSec=2s

[Install]
WantedBy=default.target
EOF
				else
					cat <<EOF >/etc/systemd/system/UDPcustom.service
[Unit]
Description=UDPcustom by ePro Dev. Team

[Service]
User=root
Type=simple
ExecStart=/bin/udp-custom server --exclude $1 --config /etc/udpc/config.json
WorkingDirectory=/etc/udpc/
Restart=always
RestartSec=2s

[Install]
WantedBy=default.target
EOF
				fi
				systemctl enable UDPcustom &>/dev/null
				systemctl start UDPcustom &>/dev/null
				msg -verd "	SERVICIO INSTALADO: 36712"
				msg -ama "	PUEDES USAR LOS USUARIOS SSH"
				msg -bar

			fi
		}
		clear
		reset() {
			clear
			msg -ama "        Servicio UDPcustom Reiniciando...."
			systemctl restart UDPcustom &>/dev/null
			clear
			msg -ama "        Servicio UDPcustom Reiniciado...."
		}
		editport() {
			clear
			while true; do
				msg -ama "EDITAR PUERTO"

				read -p " UDP-Custom: " udpPORT
				tput cuu1 >&2 && tput dl1 >&2
				checkPORT=$(netstat -tlpn | awk -F '[: ]+' '$1=="tcp"{print $5}' | grep -w $udpPORT)
				[[ -n "$checkPORT" ]] || break
				prococup=$(netstat -tlpn | awk -F '[: ]+' '$5=="$udpPORT"{print $9}')
				echo -e "\033[1;33m  EL PUERTO SE ENCUENTRA OCUPADO POR $prococup"
				msg -bar
				return
			done
			tput cuu1 >&2 && tput dl1 >&2
			tput cuu1 >&2 && tput dl1 >&2
			tput cuu1 >&2 && tput dl1 >&2
			[[ -z ${udpPORT} ]] && udpPORT='36712'
			msg -ama "	Reiniciando servicio UDPcustom -------"
			ptr=$(cat /etc/udpc/config.json | grep 'listen' | cut -d'"' -f4 | cut -d':' -f2)
			if sed -i "s/$ptr/${udpPORT}/" /etc/udpc/config.json; then
				msg -verd 'OK'
				systemctl restart UDPcustom &>/dev/null
			else
				msg -verm 'fail'
			fi

		}
		addfi() {
			clear
			msg -tit
			msg -verd "	AGREGAR PUERTO AL FIREWALL (default: 36712)"

			sudo apt install firewalld -y &>/dev/null
			read -p "$(echo -e "\e[97m DIGITE UN PUERTO NUEVO\n PARA SER AGREGADO ALA REGLA:\e[93m ")" PORT
			read -p "$(echo -e "\e[97m DIGITE EL TIPO DE CONEXION\n ESCRIBA, ( udp | tcp ):\e[93m ")" ud
			#sudo firewall-cmd --zone=public --permanent --add-port=65535/udp  &>/dev/null
			#sudo firewall-cmd --zone=public --permanent --add-port=36712/udp  &>/dev/null
			sudo firewall-cmd --zone=public --permanent --add-port=$PORT/$ud &>/dev/null
			sudo firewall-cmd --reload &>/dev/null
			sudo firewall-cmd --zone=public --list-ports &>/dev/null
			msg -ama " SERVICIO AGREGADO"
			msg -ama " PUERTO: $PUERTO | CONEXION: $ud"
		}
		remove() {

			rm -rf /etc/udpc &>/dev/null

			rm /bin/udp-custom &>/dev/null
			systemctl disable UDPcustom &>/dev/null
			systemctl stop UDPcustom &>/dev/null
			iptables -t nat -F &>/dev/null
			iptables -t mangle -F &>/dev/null
			iptables -X &>/dev/null
			iptables -P INPUT ACCEPT &>/dev/null
			iptables -P FORWARD ACCEPT &>/dev/null
			iptables -P OUTPUT ACCEPT &>/dev/null
			iptables -t nat -F PREROUTING 2>/dev/null
			ip6tables -t nat -F PREROUTING 2>/dev/null
			if systemctl status netfilter-persistent 2>/dev/null | grep -q "active (exited)"; then
				netfilter-persistent save 2>/dev/null
			fi
			msg -ama "        Servicio UDPcustom Detenido...."
		}
		clear
		#ptr=$(cat /etc/udpc/config.json |grep 'listen'|cut -d'"' -f4|cut -d':' -f2)
		#[[ $(ps x | grep udp-custom| grep -v grep) ]] && ud="\033[1;32m$ptr" || ud="\033[1;31m[SERVICIO DESACTIVADO]"

		[[ $(ps x | grep udp-custom | grep -v grep) ]] && uds="\033[1;32m[ON]" || uds="\033[1;31m[OFF]"
		msg -tit

		msg -verd "         BINARIO OFICIAL DE e-Pro Dev"

		msg -bar
		msg -ama "\e[93m         INSTALADOR UDP-CUSTOM"
		echo -e "         \e[97mSolo Funciona en Ubuntu 20+"
		msg -bar
		#echo -e "\e[1;93m	PUERTO UDP: $ud\e[0m"
		msg -bar
		echo -e "  $(msg -verd "[1]")$(msg -verm2 "➛ ")$(msg -azu " Instalar UDPcustom")  $uds"
		echo -e "  $(msg -verd "[2]")$(msg -verm2 "➛ ")$(msg -verm2 " \e[91mRemover UDPcustom")  "
		echo -e "  $(msg -verd "[3]")$(msg -verm2 "➛ ")$(msg -verm " \e[92mReiniciar servicio")  "
		echo -e "  $(msg -verd "[4]")$(msg -verm2 "➛ ")$(msg -verm " \e[93mModificar puerto")  "
		echo -e "  $(msg -verd "[5]")$(msg -verm2 "➛ ")$(msg -verm " \e[93mAgregar Reglas Firewalld")  "
		echo -e "  $(msg -verd "[0]")$(msg -verm2 "➛ ")$(msg -azu " VOLVER")  "
		msg -bar
		echo -ne "  \033[1;37mSelecione Una Opcion : "
		read opc
		case $opc in
		0) menu3 ;;
		1) instalar_udp ;;
		2) remove ;;
		3) reset ;;
		4) editport ;;
		5) addfi ;;
		esac
		;;
	L | l)
		iniciar() {
			clear
			[[ ! -d /root/UDPMOD ]] && mkdir /root/UDPMOD
			NAME=hysteria
			#
			VERSION=$(curl -fsSL https://api.github.com/repos/HyNetwork/hysteria/releases/latest | grep -w tag_name | sed -e 's/[^v.0-9 -]//ig' | tr -d '[:space:]')
			[[ $(uname -m 2>/dev/null) != x86_64 ]] && TARBALL="$NAME-linux-arm64" || TARBALL="$NAME-linux-amd64"
			interfas="$(ip -4 route ls | grep default | grep -Po '(?<=dev )(\S+)' | head -1)"

			sys="$(which sysctl)"

			ip4t=$(which iptables)
			ip6t=$(which ip6tables)

			msg -nama '   ESCRIBE SU OBFS (default: lacasita)  \n'

			read -p "               OBFS : " OBFS
			[[ -z ${OBFS} ]] && OBFS='lacasita'
			msg -verd " $OBFS : OK"

			msg -nama '   INGRESA TU SUBDOMINIO/DOMINIO  \n'

			read -p "               DOMAIN : " domain
			[[ -z ${domain} ]] && domain='lacasita'
			msg -verd " $domain : OK "

			clear
			msg -nama "     GENERANDO CERTIFICADO SSL (UDP). . . . "
			[[ -e /root/UDPMOD/udpmod.ca.key && -e /root/UDPMOD/udpmod.server.crt ]] && {
				msg -verd ' OK'
			} || {

				(
					openssl genpkey -algorithm RSA -out /root/UDPMOD/udpmod.ca.key
					openssl req -x509 -new -nodes -key /root/UDPMOD/udpmod.ca.key -days 3650 -out /root/UDPMOD/udpmod.ca.crt -subj "/C=CN/ST=GD/L=SZ/O=lacasita, Inc./CN=lacasita Root CA"
					openssl req -newkey rsa:2048 -nodes -keyout /root/UDPMOD/udp.server.key -subj "/C=CN/ST=GD/L=SZ/O=lacasita, Inc./CN=${domain}" -out /root/UDPMOD/udpmod.server.csr
					openssl x509 -req -extfile <(printf "subjectAltName=DNS:${domain}") -days 3650 -in /root/UDPMOD/udpmod.server.csr -CA /root/UDPMOD/udpmod.ca.crt -CAkey /root/UDPMOD/udpmod.ca.key -CAcreateserial -out /root/UDPMOD/udp.server.crt
				) &>/dev/null && msg -verd ' OK'

			}

			[[ -e /root/UDPMOD/udp.server.crt ]] && chmod +x /root/UDPMOD/udp.server.crt
			[[ -e /root/UDPMOD/udp.server.key ]] && chmod +x /root/UDPMOD/udp.server.key
			msg -nama "     Descargando BINARIO  "
			#
			if wget -O /bin/hysteria https://github.com/apernet/hysteria/releases/download/v1.3.5/${TARBALL} &>/dev/null; then

				chmod +x /bin/hysteria
				msg -verd ' OK'
			else
				msg -verm2 ' FAIL '
				rm -f /bin/hysteria
			fi

			msg -nama '     Descargando Motor JSON . . . . '
			if wget -O /root/UDPMOD/config.json https://github.com/lacasitamx/evozi/raw/main/config.json &>/dev/null; then

				chmod +x /root/UDPMOD/config.json
				sed -i "s/setobfs/${OBFS}/" /root/UDPMOD/config.json
				msg -verd ' OK'
			else
				msg -ama "No descargado"

			fi

			msg -nama '     COMPILANDO GoLang AUTSSH '
			#
			if wget -O /root/UDPMOD/autSSH https://github.com/lacasitamx/UDP/raw/main/autSSH &>/dev/null; then
				chmod +x /root/UDPMOD/autSSH

				msg -verd ' OK'
			else
				msg -verm2 ' FAIL '
				rm -rf /root/UDPMOD/autSSH
			fi

			msg -nama '     COMPILANDO BINARIO DE SYSTEMA . . . . '
			echo "
[Unit]
Description=HysteriaUDP MOD Service 
After=network.target

[Service]
User=root
Group=root
ExecStartPost=sysb net.ipv4.ip_forward=1
ExecStartPost=sysb net.ipv4.conf.all.rp_filter=0
ExecStartPost=sysb net.ipv4.conf.iptb.rp_filter=0
ExecStartPost=ip4tbin -t nat -A PREROUTING -i iptb -p udp --dport 10000:65000 -j DNAT --to-destination :36712
ExecStartPost=ip6tbin -t nat -A PREROUTING -i iptb -p udp --dport 10000:65000 -j DNAT --to-destination :36712
ExecStopPost=ip4tbin -t nat -D PREROUTING -i iptb -p udp --dport 10000:65000 -j DNAT --to-destination :36712
ExecStopPost=ip6tbin -t nat -D PREROUTING -i iptb -p udp --dport 10000:65000 -j DNAT --to-destination :36712
WorkingDirectory=/root/UDPMOD
Environment="PATH=/root/UDPMOD:/usr/bin:/bin"
ExecStart=/bin/hysteria -config /root/UDPMOD/config.json server

[Install]
WantedBy=multi-user.target
" >/root/UDPMOD/hysteria.service
			chmod +x /root/UDPMOD/hysteria.service
			systemctl disable hysteria.service &>/dev/null

			msg -verd ' OK'
			sleep 1s
			clear
			sed -i "s%sysb%${sys}%g" /root/UDPMOD/hysteria.service
			sed -i "s%ip4tbin%${ip4t}%g" /root/UDPMOD/hysteria.service
			sed -i "s%ip6tbin%${ip6t}%g" /root/UDPMOD/hysteria.service
			sed -i "s%iptb%${interfas}%g" /root/UDPMOD/hysteria.service

			install -Dm644 /root/UDPMOD/hysteria.service /etc/systemd/system

			systemctl start hysteria &>/dev/null
			systemctl enable hysteria &>/dev/null
			rm -f /root/UDPMOD/hysteria.service /root/UDPMOD/udpmod*
			echo "${domain}" >/etc/VPS-MX/.hysdomi
			echo " IP : $IP" >/root/UDPMOD/data
			echo " DOMINIO : ${domain}" >>/root/UDPMOD/data
			echo " OBFS : ${OBFS}" >>/root/UDPMOD/data
			echo " PUERTO : 36712" >>/root/UDPMOD/data
			echo " ALPN : h3" >>/root/UDPMOD/data
			echo " RANGO DE PUERTOS : 10000:65000" >>/root/UDPMOD/data
			echo -e " \n 	BY HYSTERIA" >>/root/UDPMOD/data
			msg -bar

			msg -ama "	DATOS DEL SERVICIO UDP "
			msg -bar
			cat /root/UDPMOD/data
			msg -bar

			[[ $(ps x | grep hysteria | grep -v grep) ]] && echo -e "$(msg -verd 'SERVICIO HYSTERIA INICIADO EXITOSAMENTE')" || echo -e "$(msg -verm2 'SERVICIO HYSTERIA NO INICIADO')"

		}

		clear
		_hysteria() {
			clear && clear
			msg -tit
			msg -ama " [1] > INSTALAR HISTERIA"
			msg -ama " [0] > VOLVER"
			msg -bar
			msg -ne " SELECIONE UNA OPCIÓN: "
			read selec
			case $selec in
			0) menu3 ;;
			1) iniciar ;;
			esac

		}
		_menuH() {
			clear && clear
			msg -tit
			[[ $(ps x | grep hysteria | grep -v grep) ]] && hy="\033[1;32m[ON]" || hy="\033[1;31m[OFF]"
			if [[ $(ps x | grep hysteria | grep -v grep) ]]; then

				d=$(sed -n '1 p' /etc/VPS-MX/.hysdomi | cut -d' ' -f1)
				o=$(sed -n '3 p' /root/UDPMOD/data | cut -d':' -f2)
				por=$(sed -n '4 p' /root/UDPMOD/data | cut -d':' -f2)
				msg -ama "  IP: \e[92m$IP"
				msg -ama "  DOMINIO: \e[92m$d"
				msg -ama "  OBFS: \e[92m$o"
				msg -ama "  RANGO DE PUERTO:\e[92m10000:65000"
				msg -ama "  PUERTO UDP: $por \e[0m"

			else
				msg -ama "\033[1;31m[No Instalado]"

			fi
			msg -bar
			unset op
			[[ $(cat /root/UDPMOD/config.json | grep -w '//"alpn"') ]] && _ap='\033[1;91mOFF' || _ap='\033[1;32mON'
			menu_func "MODIFICAR PUERTO" "MODIFICAR OBFS" "ALPN (http injector) \033[0;32m[ ${_ap}\033[0;32m ]" "REINICIAR SERVICIO" "\033[1;31mREMOVER SERVICIO"
			msg -bar
			selecy=$(selection_fun 5)
			case $selecy in
			0) menu3 ;;
			1)
				clear && clear
				unset _col
				msg -bar
				msg -ama "INGRESE EL NUEVO PUERTO DE SERVICIO "
				read -p " PUERTO : " _col
				#
				_PA=$(cat /root/UDPMOD/config.json | grep 'listen' | cut -d'"' -f4 | cut -d':' -f2)

				[[ ${_col} ]] && {
					sed -i "s/${_PA}/${_col}/" /root/UDPMOD/config.json
					sed -i "s/${_PA}/${_col}/" /root/UDPMOD/data
					systemctl restart hysteria &>/dev/null
					msg -ama "	PUERTO NUEVO: $_col"
				}
				;;
			2)
				clear && clear
				unset _col
				msg -bar
				msg -ama "INGRESE SU NUEVO OBFS "
				read -p " OBFS : " _col
				_obfs=$(cat /root/UDPMOD/config.json | grep 'obfs' | cut -d'"' -f4)

				[[ ${_col} ]] && {
					sed -i "s/${_obfs}/${_col}/" /root/UDPMOD/config.json
					sed -i "s/${_obfs}/${_col}/" /root/UDPMOD/data
					systemctl restart hysteria &>/dev/null
					msg -ama "	OBFS MODIFICADO: $_col"
				}
				;;
			3)
				clear && clear
				[[ $(cat /root/UDPMOD/config.json | grep -w '//"alpn"') ]] && {
					sed -i '12d' /root/UDPMOD/config.json
					sed -i '12i\        "alpn": "h3",' /root/UDPMOD/config.json
					msg -verd "	ALPN ACTIVADO"
				} || {
					sed -i '12d' /root/UDPMOD/config.json
					sed -i '12i\        //"alpn": "h3",' /root/UDPMOD/config.json
					msg -verm2 "	ALPN DESACTIVADO"
				}
				systemctl restart hysteria &>/dev/null
				;;
			4)
				clear && clear

				msg -bar
				systemctl restart hysteria &>/dev/null
				msg -verd "	REINICIADO"
				;;
			5)
				clear && clear
				rm -f /root/UDPMOD/*

				iptables -t nat -F PREROUTING 2>/dev/null
				ip6tables -t nat -F PREROUTING 2>/dev/null
				if systemctl status netfilter-persistent 2>/dev/null | grep -q "active (exited)"; then
					netfilter-persistent save 2>/dev/null
				fi
				systemctl stop hysteria &>/dev/null
				systemctl disable hysteria &>/dev/null
				systemctl remove hysteria &>/dev/null
				rm -f /etc/systemd/system/hysteria.service

				msg -ama "	SERVICIO DESINSTALADO"
				;;
			esac
		}
		[[ $(ps x | grep -w "/bin/hysteria" | grep -v grep) ]] && _menuH || _hysteria
		;;
	19) ftpup ;;
	20) menufirewall ;;
	21) ${SCPfrm}/fai2ban.sh ;;
	22) systen_info ;;
	23) funbbr ;;
	24) net ;;
	25) cache ;;
	26) ultrahost ;;
	27) ${SCPfrm}/speed.py ;;
	28) oracl ;;
	29) extra ;;

	*)
		msg -verm2 " Por Favor Selecione El Número Correcto"
		sleep 1.s
		menu3
		;;
	esac
}
NOTIFY() {
	clear
	clear
	msg -tit

	msg -ama " Notify-BOT (Notificacion Remota)|@LaCasitaMx_Noty_Bot "
	msg -bar
	echo -e "\033[1;94m Notify-BOT es un simple notificador de:"
	echo -e "\033[1;94m >> Usuario Expirado"
	echo -e "\033[1;94m >> Usuario Eliminado"
	echo -e "\033[1;94m >> Avisos de VPS Reiniciada"
	echo -e "\033[1;94m >> Avisos de Monitor de Protocolos"
	echo -e "\033[1;97m Inicie El BOT de Telegram"
	echo -e "\033[1;92m ¡¡ Para sacar su ID entre al BOT @conectedmx_bot"
	echo -e "\033[1;92m Aparesera algo parecido 👤 → Tu ID es: 45145564   "
	msg -bar
	echo -e "\033[1;93mIgrese un nombre para la VPS:\033[0;37m"
	read -p " " nombr
	echo "${nombr}" >/etc/VPS-MX/controlador/nombre.log
	echo -e "\033[1;93mIgrese su ID 👤:\033[0;37m"
	read -p " " idbot
	echo "${idbot}" >/etc/VPS-MX/controlador/IDT.log
	msg -bar
	echo -e "\033[1;32m              ID AGREGADO CON EXITO"
	msg -bar
	wget -qO- ifconfig.me >/etc/VPS-MX/IP.log
	ipt=$(less /etc/VPS-MX/IP.log) >/dev/null 2>&1
	Nip="$(echo $ipt)"
	NOM="$(less /etc/VPS-MX/controlador/nombre.log)"
	NOM1="$(echo $NOM)"
	IDB1=$(less /etc/VPS-MX/controlador/IDT.log) >/dev/null 2>&1
	IDB2=$(echo $IDB1) >/dev/null 2>&1
	KEY="xxxxxx"
	URL="https://api.telegram.org/bot$KEY/sendMessage"
	MSG="⚠️ ►► AVISO DE VPS: $NOM1 ⚠ 👉 ►► IP: $Nip 👉 ►► Usuario: $(cat /etc/VPS-MX/message.txt) 👉 ►► MENSAJE DE PRUEBA 🔰 ►► NOTI-BOT ACTIVADO CORRECTAMENTE"
	# curl -s --max-time 10 -d "chat_id=$IDB2&disable_web_page_preview=1&text=$MSG" $URL &>/dev/null
	echo -e "\033[1;34m            SE ENVIO MENSAJE DE PRUEBA "
	touch /etc/noty
}

noti() {
	clear
	msg -tit
	echo -e "	\e[97m\e[1;100mACTIVADOR NOTI-BOT\e[0m"
	msg -bar
	echo -e "\e[1;93m[\e[92m1\e[93m]$(msg -verm2 "➛ ")$(msg -azu "ACTIVAR NOTI-BOT $nt")  \e[1;93m[\e[92m2\e[93m]$(msg -verm2 "➛ ")$(msg -azu "DESACTIVAR NOTI-BOT")"
	msg -bar
	echo -e "	     	\e[1;93m[\e[92m0\e[93m]$(msg -verm2 "➛ ")$(msg -azu "VOLVER")"
	msg -bar
	echo -ne " ►\e[1;37m Selecione Una Opcion: \e[33m " && read selectos
	case $selectos in
	0) menu3 ;;
	1)
		NOTIFY && msg -ne "Enter Para Continuar" && read enter
		menu3
		;;
	2)
		echo " " >/etc/VPS-MX/controlador/IDT.log &>/dev/null
		rm /etc/noty &>/dev/null
		msg -verm2 "	NOTI-BOT DESACTIVADO"
		;;
	esac
}

adminbot() {
	clear
	#msg -bar
	#msg -tit
	echo ""
	echo -e "\e[1;90m╔─━━━━━━━━━━━━━━░★░━━━━━━━━━━━━━━─╗                \e[0m"
	msg -ama " ░ ADMINISTRADOR BOT | TELEGRAM  ░                   \033[1;31m"
	echo -e "\e[1;90m╚─━━━━━━━━━━━━━━░★░━━━━━━━━━━━━━━─╝                \e[0m"
	activar() {
		msg -bar
		echo -ne "\033[1;96m #Digite el Token del BOT\033[0;92m\nTOKEN: \033[0;97m" && read TOKEN
		msg -bar
		echo -ne "\033[1;96m #Digite un nombre para su Usuario\033[0;92m \nUSUARIO: \033[0;97m" && read USERLIB
		msg -bar
		echo -ne "\033[1;96m #Digite una contraseña para su Usuario\033[0;92m \nCONTRASEÑA: \033[0;97m" && read PASSLIB
		#msg -bar
		echo -e "[Unit]
Description=ADMbot.sh Service by @lacasitamx
After=network.target
StartLimitIntervalSec=0

[Service]
Type=simple
User=root
WorkingDirectory=/root
ExecStart=/bin/bash /etc/VPS-MX/herramientas/ADMbot.sh id "$TOKEN" "$USERLIB" "$PASSLIB"
Restart=always
RestartSec=3s

[Install]
WantedBy=multi-user.target" >/etc/systemd/system/Botca.service

		systemctl enable Botca &>/dev/null
		systemctl start Botca &>/dev/null
		msg -bar
		echo -e "\033[1;92m                BOT INICIADO CON EXITO"
		echo -e "\033[1;97m MODO DE INICIO DEL BOT: /ADMIN $USERLIB $PASSLIB"
		msg -bar
	}

	killbot() {
		systemctl stop Botca &>/dev/null
		systemctl disable Botca &>/dev/null
		rm /etc/systemd/system/Botca.service &>/dev/null
		msg -bar
		echo -e "\033[1;91m                BOT DETENIDO"
		msg -bar

	}
	echo -e " \e[1;93m[\e[92m1\e[93m] $(msg -verm2 "➛ ")$(msg -verd "  INICIAR BOT MANAGER   ")"
	echo -e " \e[1;93m[\e[92m2\e[93m] $(msg -verm2 "➛ ")$(msg -verm2 " DETENER BOT MANAGER   ")"
	echo -e " \e[1;93m[\e[92m0\e[93m] $(msg -verm2 "➛ ")$(msg -bra "  VOLVER   ")"
	msg -bar
	echo -ne " ►\e[1;37m Selecione Una Opcion: \e[33m " && read select
	case $select in
	0) menu3 ;;
	1)
		activar && msg -ne "Enter Para Continuar" && read enter
		menu3
		;;
	2)
		killbot && msg -ne "Enter Para Continuar" && read enter
		menu3
		;;
	esac
}

extra() {
	clear
	clear
	#msg -bar
	msg -tit
	on="\033[1;32m[ON]" && off="\033[1;31m[OFF]"
	[[ $(grep -c "^#ADM" /etc/sysctl.conf) -eq 0 ]] && tcp=$off || tcp=$on
	if [ -e /etc/squid/squid.conf ]; then
		[[ $(grep -c "^#CACHE_DO_SQUID" /etc/squid/squid.conf) -gt 0 ]] && squi=$off || squi=$on
	elif [ -e /etc/squid3/squid.conf ]; then
		[[ $(grep -c "^#CACHE_DO_SQUID" /etc/squid3/squid.conf) -gt 0 ]] && squi=$off || squi=$on
	fi
	echo -e "		\e[91m\e[43mHERRAMIENTAS BASICOS\e[0m"
	msg -bar
	echo -e " \e[1;93m[\e[92m1\e[93m]$(msg -verm2 " ➛ ")$(msg -azu "ACTUALIZAR HORA LOCAL")"
	echo -e " \e[1;93m[\e[92m2\e[93m]$(msg -verm2 " ➛ ")$(msg -azu "HTOP")"
	echo -e " \e[1;93m[\e[92m3\e[93m]$(msg -verm2 " ➛ ")$(msg -azu "MODIFICAR PUERTOS ACTIVOS")"
	echo -e " \e[1;93m[\e[92m4\e[93m]$(msg -verm2 " ➛ ")$(msg -azu "PAYLOAD FUERZA BRUTA")"
	echo -e " \e[1;93m[\e[92m5\e[93m]$(msg -verm2 " ➛ ")$(msg -azu "TCP SPEED") $tcp"
	echo -e " \e[1;93m[\e[92m6\e[93m]$(msg -verm2 " ➛ ")$(msg -azu "CACHÉ PARA SQUID") $squi"
	echo -e " \e[1;93m[\e[92m7\e[93m]$(msg -verm2 " ➛ ")$(msg -azu "LIMPIAR PAQUETES OBSOLETOS")"
	echo -e " \e[1;93m[\e[92m8\e[93m]$(msg -verm2 " ➛ ")$(msg -azu "RESET IPTABLES")"
	echo -e " \e[1;93m[\e[92m9\e[93m]$(msg -verm2 " ➛ ")$(msg -azu "REINICIAR VPS")"
	echo -e " \e[1;93m[\e[92m10\e[93m]$(msg -verm2 "➛ ")$(msg -azu "CAMBIAR HOSTNAME VPS")"
	echo -e " \e[1;93m[\e[92m11\e[93m]$(msg -verm2 "➛ ")$(msg -azu "CAMBIAR CONTRASEÑA ROOT")"
	echo -e " \e[1;93m[\e[92m12\e[93m]$(msg -verm2 "➛ ")$(msg -azu "AGREGAR ROOT a GoogleCloud y Amazon")"
	echo -e " \e[1;93m[\e[92m13\e[93m]$(msg -verm2 "➛ ")$(msg -azu "AUTENTIFICAR SQUID")"
	echo -e " \e[1;93m[\e[92m0\e[93m]$(msg -verm2 " ➛ ")$(msg -azu "VOLVER")"
	msg -bar
	echo -ne " ►\e[1;37m Selecione Una Opcion: \e[33m " && read select
	case $select in
	0) menu3 ;;
	1) horas ;;
	2) monhtop ;;
	3)
		${SCPfrm}/ports.sh && msg -ne "Enter Para Continuar" && read enter
		menu3
		;;
	4) ${SCPfrm}/paysnd.sh ;;
	5) TCPspeed ;;
	6) SquidCACHE ;;
	7) packobs ;;
	8) resetiptables ;;
	9) reiniciar_vps ;;
	10) host_name ;;
	11) cambiopass ;;
	12) rootpass ;;
	13) ${SCPfrm}/squidpass.sh ;;
	*) ;;
	esac
}

reiniciar_vps() {
	echo -ne " \033[1;31m[ ! ] Sudo Reboot"
	sleep 3s
	echo -e "\033[1;32m [OK]"
	(
		sudo reboot
	) >/dev/null 2>&1
	msg -bar
	return
}

host_name() {
	unset name
	while [[ ${name} = "" ]]; do
		echo -ne "\033[1;37m $(fun_trans "Nuevo nombre del host"): " && read name
		tput cuu1 && tput dl1
	done
	hostnamectl set-hostname $name
	if [ $(hostnamectl status | head -1 | awk '{print $3}') = "${name}" ]; then
		echo -e "\033[1;33m $(fun_trans "Host alterado corretamente")!, $(fun_trans "reiniciar VPS")"
	else
		echo -e "\033[1;33m $(fun_trans "Host no modificado")!"
	fi
	msg -bar
	return
}

cambiopass() {
	echo -e "${cor[3]} $(fun_trans "Esta herramienta cambia la contraseña de su servidor vps")"
	echo -e "${cor[3]} $(fun_trans "Esta contraseña es utilizada como usuario") root"
	msg -bar
	echo -ne " $(fun_trans "Desea Seguir?") [S/N]: "
	read x
	[[ $x = @(n|N) ]] && msg -bar && return
	msg -bar
	#Inicia Procedimentos
	echo -e "${cor[0]} $(fun_trans "Escriba su nueva contraseña")"
	msg -bar
	read -p " Nuevo passwd: " pass
	(
		echo $pass
		echo $pass
	) | passwd 2>/dev/null
	sleep 1s
	msg -bar
	echo -e "${cor[3]} $(fun_trans "Contraseña cambiada con exito!")"
	echo -e "${cor[2]} $(fun_trans "Su contraseña ahora es"): ${cor[4]}$pass"
	msg -bar
	return
}
dnsnetflix() {
	#by kalix1
	echo "nameserver $dns1" >>/etc/resolv.conf
	#echo "nameserver $dns2" >> /etc/resolv.conf
	/etc/init.d/ssrmu stop &>/dev/null
	/etc/init.d/ssrmu start &>/dev/null
	/etc/init.d/shadowsocks-r stop &>/dev/null
	/etc/init.d/shadowsocks-r start &>/dev/null
	msg -bar2
	echo -e "${cor[4]}  DNS AGREGADOS CON EXITO"
}
net() {
	#by kalix1
	clear
	#msg -bar2
	msg -tit
	echo -e "\033[1;93m     AGREGADOR DE DNS PERSONALES"
	msg -bar2
	echo -e "\033[1;39m Esta funcion ara que puedas ver Netflix con tu VPS"
	msg -bar2
	#echo -e "\033[1;91m ¡ Solo seran utiles si registraste tu IP en el BOT !"
	echo -e "\033[1;39m En APPS como HTTP Inyector,KPN Rev,APKCUSTOM, etc."
	echo -e "\033[1;39m Se deveran agregar en la aplicasion a usar estos DNS."
	echo -e "\033[1;39m En APPS como SS,SSR,V2RAY no es necesario agregarlos."
	msg -bar2
	echo -e "\033[1;93m Recuerde escojer entre 1 DNS ya sea el de USA,BR,MX,CL \n segun le aya entregado el BOT."
	echo ""
	echo -e "\033[1;97m Ingrese su DNS Primario: \033[0;91m"
	read -p " Primary Dns: " dns1
	echo -e "\033[1;97m Ingrese su DNS Secundario: \033[0;91m"
	read -p " Secondary Dns: " dns2
	echo ""
	msg -bar2
	read -p " Estas seguro de continuar?  [ s | n ]: " dnsnetflix
	[[ "$dnsnetflix" = "s" || "$dnsnetflix" = "S" ]] && dnsnetflix
	msg -bar2
}
rootpass() {
	clear
	msg -bar
	echo -e "${cor[3]}  Esta herramienta cambia a usuario root las VPS de "
	echo -e "${cor[3]}             GoogleCloud y Amazon"
	msg -bar
	echo -ne " Desea Seguir? [S/N]: "
	read x
	[[ $x = @(n|N) ]] && msg -bar && return
	msg -bar
	#Inicia Procedimentos
	echo -e "                 Aplicando Configuraciones"
	fun_bar "service ssh restart"
	#Parametros Aplicados
	sed -i "s;PermitRootLogin prohibit-password;PermitRootLogin yes;g" /etc/ssh/sshd_config
	sed -i "s;PermitRootLogin without-password;PermitRootLogin yes;g" /etc/ssh/sshd_config
	sed -i "s;PasswordAuthentication no;PasswordAuthentication yes;g" /etc/ssh/sshd_config
	msg -bar
	echo -e "Escriba su contraseña root actual o cambiela"
	msg -bar
	read -p " Nuevo passwd: " pass
	(
		echo $pass
		echo $pass
	) | passwd 2>/dev/null
	sleep 1s
	msg -bar
	echo -e "${cor[3]} Configuraciones aplicadas con exito!"
	echo -e "${cor[2]} Su contraseña ahora es: ${cor[4]}$pass"
	service ssh restart >/dev/null 2>&1
	msg -bar
	return
}

resetiptables() {
	echo -e "Reiniciando Ipetables espere"
	iptables -F && iptables -X && iptables -t nat -F && iptables -t nat -X && iptables -t mangle -F && iptables -t mangle -X && iptables -t raw -F && iptables -t raw -X && iptables -t security -F && iptables -t security -X && iptables -P INPUT ACCEPT && iptables -P FORWARD ACCEPT && iptables -P OUTPUT ACCEPT
	echo -e "iptables reiniciadas con exito"
}
packobs() {
	msg -ama "Buscando Paquetes Obsoletos"
	dpkg -l | grep -i ^rc
	msg -ama "Limpiando Paquetes Obsoloteos"
	dpkg -l | grep -i ^rc | cut -d " " -f 3 | xargs dpkg --purge
	msg -ama "Limpieza Completa"
}

TCPspeed() {
	if [[ $(grep -c "^#ADM" /etc/sysctl.conf) -eq 0 ]]; then
		#INSTALA
		msg -ama "$(fun_trans "TCP Speed No Activado, Desea Activar Ahora")?"
		msg -bar
		while [[ ${resposta} != @(s|S|n|N|y|Y) ]]; do
			read -p " [S/N]: " -e -i s resposta
			tput cuu1 && tput dl1
		done
		[[ "$resposta" = @(s|S|y|Y) ]] && {
			echo "#ADM" >>/etc/sysctl.conf
			echo "net.ipv4.tcp_window_scaling = 1
net.core.rmem_max = 16777216
net.core.wmem_max = 16777216
net.ipv4.tcp_rmem = 4096 87380 16777216
net.ipv4.tcp_wmem = 4096 16384 16777216
net.ipv4.tcp_low_latency = 1
net.ipv4.tcp_slow_start_after_idle = 0" >>/etc/sysctl.conf
			sysctl -p /etc/sysctl.conf >/dev/null 2>&1
			msg -ama "$(fun_trans "TCP Activo Con Exito")!"
		} || msg -ama "$(fun_trans "Cancelado")!"
	else
		#REMOVE
		msg -ama "$(fun_trans "TCP Speed ya esta activado, desea detener ahora")?"
		msg -bar
		while [[ ${resposta} != @(s|S|n|N|y|Y) ]]; do
			read -p " [S/N]: " -e -i s resposta
			tput cuu1 && tput dl1
		done
		[[ "$resposta" = @(s|S|y|Y) ]] && {
			grep -v "^#ADM
net.ipv4.tcp_window_scaling = 1
net.core.rmem_max = 16777216
net.core.wmem_max = 16777216
net.ipv4.tcp_rmem = 4096 87380 16777216
net.ipv4.tcp_wmem = 4096 16384 16777216
net.ipv4.tcp_low_latency = 1
net.ipv4.tcp_slow_start_after_idle = 0" /etc/sysctl.conf >/tmp/syscl && mv -f /tmp/syscl /etc/sysctl.conf
			sysctl -p /etc/sysctl.conf >/dev/null 2>&1
			msg -ama "$(fun_trans "TCP Parado Con Exito")!"
		} || msg -ama "$(fun_trans "Cancelado")!"
	fi
}
SquidCACHE() {
	msg -ama "$(fun_trans "Squid Cache, Aplica cache en Squid")"
	msg -ama "$(fun_trans "Mejora la velocidad del squid")"
	msg -bar
	if [ -e /etc/squid/squid.conf ]; then
		squid_var="/etc/squid/squid.conf"
	elif [ -e /etc/squid3/squid.conf ]; then
		squid_var="/etc/squid3/squid.conf"
	else
		msg -ama "$(fun_trans "Su sistema no tiene un squid")!" && return 1
	fi
	teste_cache="#CACHE_DO_SQUID"
	if [[ $(grep -c "^$teste_cache" $squid_var) -gt 0 ]]; then
		[[ -e ${squid_var}.bakk ]] && {
			msg -ama "$(fun_trans "Cache squid identificado, eliminando")!"
			mv -f ${squid_var}.bakk $squid_var
			msg -ama "$(fun_trans "Cache squid Removido")!"
			service squid restart >/dev/null 2>&1 &
			service squid3 restart >/dev/null 2>&1 &
			return 0
		}
	fi
	msg -ama "$(fun_trans "Aplicando Cache Squid")!"
	msg -bar
	_tmp="#CACHE_DO_SQUID\ncache_mem 200 MB\nmaximum_object_size_in_memory 32 KB\nmaximum_object_size 1024 MB\nminimum_object_size 0 KB\ncache_swap_low 90\ncache_swap_high 95"
	[[ "$squid_var" = "/etc/squid/squid.conf" ]] && _tmp+="\ncache_dir ufs /var/spool/squid 100 16 256\naccess_log /var/log/squid/access.log squid" || _tmp+="\ncache_dir ufs /var/spool/squid3 100 16 256\naccess_log /var/log/squid3/access.log squid"
	while read s_squid; do
		[[ "$s_squid" != "cache deny all" ]] && _tmp+="\n${s_squid}"
	done <$squid_var
	cp ${squid_var} ${squid_var}.bakk
	echo -e "${_tmp}" >$squid_var
	msg -ama "$(fun_trans "Cache Aplicado con Exito")!"
	service squid restart >/dev/null 2>&1 &
	service squid3 restart >/dev/null 2>&1 &
}

oracl() {
	clear
	#msg -bar
	msg -tit
	msg -verm "		FIREWALLD"
	msg -ama " ESTA HERRAMIENTA ES PARA LAS VPS ORACLE/AWS/AZR"
	msg -ama " TAMBIEN PARA OTRAS VPS QUE SON NECESARIO A UTILIZAR ESTA OPCION"
	echo -ne " Desea Continuar? [S/N]: "
	read x
	[[ $x = @(n|N) ]] && msg -bar && return
	msg -bar
	sudo apt update -y &>/dev/null
	sudo apt install firewalld -y &>/dev/null
	sudo apt install apache2 &>/dev/null
	#sudo firewall-cmd --permanent --add-service={http,https} --permanent
	sudo firewall-cmd --zone=public --permanent --add-port=80/tcp
	sudo firewall-cmd --zone=public --permanent --add-port=81/tcp
	sudo firewall-cmd --zone=public --permanent --add-port=90/tcp
	sudo firewall-cmd --zone=public --permanent --add-port=110/tcp
	sudo firewall-cmd --zone=public --permanent --add-port=143/tcp
	sudo firewall-cmd --zone=public --permanent --add-port=442/tcp
	sudo firewall-cmd --zone=public --permanent --add-port=443/tcp
	sudo firewall-cmd --zone=public --permanent --add-port=444/tcp
	sudo firewall-cmd --zone=public --permanent --add-port=8080/tcp
	sudo firewall-cmd --zone=public --permanent --add-port=8081/tcp
	sudo firewall-cmd --zone=public --permanent --add-port=5300/udp
	sudo firewall-cmd --zone=public --permanent --add-port=7200/udp
	sudo firewall-cmd --zone=public --permanent --add-port=7300/udp
	sudo firewall-cmd --reload
	sudo firewall-cmd --zone=public --list-ports &>/dev/null
	msg -azu "	FIX AGREGADO"

}
cache() {
	clear
	msg -bar
	msg -verm "	LIBERANDO CACHÉ/RAM DEL SISTEMA"
	msg -bar

	sysctl -w vm.drop_caches=3 &>/dev/null
	apt-get autoclean -y &>/dev/null
	apt-get clean -y &>/dev/null && msg -ama " REFRESCANDO RAM,SISTEMA" | pv -qL20

	msg -azu " Ram liberada:" && msg -bar && sleep 2

}

pidr_inst() {
	proto="dropbear python stunnel4 stunnel5 v2ray node badvpn squid openvpn dns-serve ssserver ss-server trojan"
	portas=$(lsof -V -i -P -n | grep -v "ESTABLISHED" | grep -v "COMMAND")
	for list in $proto; do
		case $list in
		dropbear | python | stunnel4 | stunnel5 | v2ray | node | badvpn | squid | openvpn | ssserver | ss-server | trojan)
			portas2=$(echo $portas | grep -w "LISTEN" | grep -w "$list")
			[[ $(echo "${portas2}" | grep "$list") ]] && inst[$list]="\033[1;32m[ON] " || inst[$list]="\033[1;31m[OFF]"
			;;
		dns-serve)
			portas2=$(echo $portas | grep -w "$list")
			[[ $(echo "${portas2}" | grep "$list") ]] && inst[$list]="\033[1;32m[ON] " || inst[$list]="\033[1;31m[OFF]"
			;;
		esac
	done
	[[ $(dpkg --get-selections | grep -w 'wireguard' | head -1) ]] && {
		if [[ $(wg | grep -w 'interface') = "" ]]; then inst[wg]="\033[1;31m[OFF]"; else inst[wg]="\033[1;32m[ON] "; fi
	} || {
		inst[wg]="\033[1;31m[OFF]"
	}
}
# Menu Instalaciones

#check_IP&
# MENU FLUTUANTE
menu_func() {
	local options=${#@}
	local array
	for ((num = 1; num <= $options; num++)); do
		echo -ne "  $(msg -verd "\e[1;93m[\e[92m$num\e[93m]") $(msg -verm2 "➛ ") "
		array=(${!num})
		case ${array[0]} in
		"-vd") msg -verd "\033[1;33m[!]\033[1;32m $(fun_trans "${array[@]:1}")" | sed ':a;N;$!ba;s/\n/ /g' ;;
		"-vm") msg -verm2 "\033[1;33m[!]\033[1;31m $(fun_trans "${array[@]:1}")" | sed ':a;N;$!ba;s/\n/ /g' ;;
		"-fi") msg -azu "$(fun_trans "${array[@]:2}") ${array[1]}" | sed ':a;N;$!ba;s/\n/ /g' ;;
		*) msg -azu "$(fun_trans "${array[@]}")" | sed ':a;N;$!ba;s/\n/ /g' ;;
		esac
	done
}

VERY3=$(ps aux | grep -v grep | grep "monitor")
monservi_fun() {
	clear
	clear
	monssh() {
		sed -i "57d" /bin/monitor.sh
		sed -i '57i EstadoServicio ssh' /bin/monitor.sh
	}
	mondropbear() {
		sed -i "59d" /bin/monitor.sh
		sed -i '59i EstadoServicio dropbear' /bin/monitor.sh
	}
	monssl() {
		sed -i "61d" /bin/monitor.sh
		sed -i '61i EstadoServicio stunnel4' /bin/monitor.sh
	}
	monsquid() {
		sed -i "63d" /bin/monitor.sh
		sed -i '63i [[ $(EstadoServicio squid) ]] && EstadoServicio squid3' /bin/monitor.sh
	}
	monapache() {
		sed -i "65d" /bin/monitor.sh
		sed -i '65i EstadoServicio apache2' /bin/monitor.sh
	}
	monv2ray() {
		sed -i "55d" /bin/monitor.sh
		sed -i '55i EstadoServicio v2ray' /bin/monitor.sh
	}
	msg -bar
	msg -tit
	echo -e "\033[1;32m          MONITOR DE SERVICIONS PRINCIPALES"

	PIDVRF3=$(ps aux | grep -v grep | grep "monitor")

	#PIDVRF5=$(ps x|grep -v grep |grep "monit")

	if [[ -z $PIDVRF3 ]]; then
		#sed -i '5a\screen -dmS monitor /etc/VPS-MX/tmp/monitor' /bin/resetsshdrop
		msg -bar
		echo -e "\033[1;34m          ¿Monitorear Protocolo SSH/SSHD?"
		msg -bar
		read -p "                    [ s | n ]: " monssh
		sed -i "57d" /bin/monitor.sh
		sed -i '57i #EstadoServicio ssh' /bin/monitor.sh
		[[ "$monssh" = "s" || "$monssh" = "S" ]] && monssh
		msg -bar
		echo -e "\033[1;34m          ¿Monitorear Protocolo DROPBEAR?"
		msg -bar
		read -p "                    [ s | n ]: " mondropbear
		sed -i "59d" /bin/monitor.sh
		sed -i '59i #EstadoServicio dropbear' /bin/monitor.sh
		[[ "$mondropbear" = "s" || "$mondropbear" = "S" ]] && mondropbear
		msg -bar
		echo -e "\033[1;34m            ¿Monitorear Protocolo SSL?"
		msg -bar
		read -p "                    [ s | n ]: " monssl
		sed -i "61d" /bin/monitor.sh
		sed -i '61i #EstadoServicio stunnel4' /bin/monitor.sh
		[[ "$monssl" = "s" || "$monssl" = "S" ]] && monssl
		msg -bar
		echo -e "\033[1;34m            ¿Monitorear Protocolo SQUID?"
		msg -bar
		read -p "                    [ s | n ]: " monsquid
		sed -i "63d" /bin/monitor.sh
		sed -i '63i #[[ $(EstadoServicio squid) ]] && EstadoServicio squid3' /bin/monitor.sh
		[[ "$monsquid" = "s" || "$monsquid" = "S" ]] && monsquid
		msg -bar
		echo -e "\033[1;34m            ¿Monitorear Protocolo APACHE?"
		msg -bar
		read -p "                    [ s | n ]: " monapache
		sed -i "65d" /bin/monitor.sh
		sed -i '65i #EstadoServicio apache2' /bin/monitor.sh
		[[ "$monapache" = "s" || "$monapache" = "S" ]] && monapache
		msg -bar
		echo -e "\033[1;34m            ¿Monitorear Protocolo V2RAY?"
		msg -bar
		read -p "                    [ s | n ]: " monv2ray
		sed -i "55d" /bin/monitor.sh
		sed -i '55i #EstadoServicio v2ray' /bin/monitor.sh
		[[ "$monv2ray" = "s" || "$monv2ray" = "S" ]] && monv2ray
		#screen -dmS monitor /etc/VPS-MX/tmp/monitor
		#screen -dmS monit /etc/VPS-MX/tmp/monitor
		echo -e "[Unit]
Description=monitor Service
After=network.target\n
[Service]
Type=simple
User=root
WorkingDirectory=/root
ExecStart=/bin/bash /etc/VPS-MX/tmp/monitor
Restart=always
RestartSec=3s\n
[Install]
WantedBy=multi-user.target" >/etc/systemd/system/monit.service

		systemctl enable monit &>/dev/null
		systemctl start monit &>/dev/null
	else

		systemctl stop monit &>/dev/null
		systemctl disable monit &>/dev/null
		rm -rf /etc/systemd/system/monit .service
		sed -i "6d" /bin/resetsshdrop
	fi

	msg -bar
	echo -e "             Puedes Monitorear desde:\n       \033[1;32m http://$IP:81/monitor.html"
	msg -bar
	[[ -z ${VERY3} ]] && monitor="\033[1;32m ACTIVADO " || monitor="\033[1;31m DESACTIVADO "
	echo -e "            $monitor  --  CON EXITO"
	msg -bar

}
dropbear_pids() {
	local pids

	local portasVAR=$(lsof -V -i tcp -P -n | grep -v "ESTABLISHED" | grep -v "COMMAND" | grep "LISTEN")
	local NOREPEAT
	local reQ
	local Port
	while read port; do
		reQ=$(echo ${port} | awk '{print $1}')
		Port=$(echo {$port} | awk '{print $9}' | awk -F ":" '{print $2}')
		[[ $(echo -e $NOREPEAT | grep -w "$Port") ]] && continue
		NOREPEAT+="$Port\n"
		case ${reQ} in

		dropbear)
			[[ -z $DPB ]] && local DPB=""
			DPB+="$Port "
			;;

		esac
	done <<<"${portasVAR}"

	[[ ! -z $DPB ]] && echo -e $DPB

	local port_dropbear="$DPB"
	#cat /var/log/auth.log|grep "$(date|cut -d' ' -f2,3)" > /var/log/authday.log
	cat /var/log/auth.log | tail -1000 >/var/log/authday.log
	local log=/var/log/authday.log
	local loginsukses='Password auth succeeded'
	[[ -z $port_dropbear ]] && return 1
	for port in $(echo $port_dropbear); do
		for pidx in $(ps ax | grep dropbear | grep "$port" | awk -F" " '{print $1}'); do
			pids="${pids}$pidx\n"
		done
	done
	for pid in $(echo -e "$pids"); do
		pidlogs=$(grep $pid $log | grep "$loginsukses" | awk -F" " '{print $3}')
		i=0
		for pidend in $pidlogs; do
			let i++
		done
		if [[ $pidend ]]; then
			login=$(grep $pid $log | grep "$pidend" | grep "$loginsukses")
			PID=$pid
			user=$(echo $login | awk -F" " '{print $10}' | sed -r "s/'//g")
			waktu=$(echo $login | awk -F" " '{print $2"-"$1,$3}')
			[[ -z $user ]] && continue
			echo "$user|$PID|$waktu"
		fi
	done
}
droppids() {
	port_dropbear=$(ps aux | grep 'dropbear' | awk NR==1 | awk '{print $17;}')

	log=/var/log/auth.log &>/dev/null
	loginsukses='Password auth succeeded'

	pids=$(ps ax | grep 'dropbear' | grep " $port_dropbear" | awk -F " " '{print $1}')

	for pid in $pids; do
		pidlogs=$(grep $pid $log | grep "$loginsukses" | awk -F" " '{print $3}')

		i=0
		for pidend in $pidlogs; do
			let i=i+1
		done

		if [ $pidend ]; then
			login=$(grep $pid $log | grep "$pidend" | grep "$loginsukses")
			PID=$pid
			user=$(echo $login | awk -F" " '{print $10}' | sed -r "s/'/ /g")
			waktu=$(echo $login | awk -F" " '{print $2"-"$1,$3}')
			while [ ${#waktu} -lt 13 ]; do
				waktu=$waktu" "
			done
			while [ ${#user} -lt 16 ]; do
				user=$user" "
			done
			while [ ${#PID} -lt 8 ]; do
				PID=$PID" "
			done
			echo "$user $PID $waktu"
		fi
	done
}
openvpn_pids() {
	#nome|#loguin|#rcv|#snd|#time
	byte() {
		while read B dummy; do
			[[ "$B" -lt 1024 ]] && echo "${B} bytes" && break
			KB=$(((B + 512) / 1024))
			[[ "$KB" -lt 1024 ]] && echo "${KB} Kb" && break
			MB=$(((KB + 512) / 1024))
			[[ "$MB" -lt 1024 ]] && echo "${MB} Mb" && break
			GB=$(((MB + 512) / 1024))
			[[ "$GB" -lt 1024 ]] && echo "${GB} Gb" && break
			echo $(((GB + 512) / 1024)) terabytes
		done
	}
	for user in $(mostrar_usuarios); do
		user="$(echo $user | sed -e 's/[^a-z0-9 -]//ig')"
		[[ ! $(sed -n "/^${user},/p" /etc/openvpn/openvpn-status.log) ]] && continue
		i=0
		unset RECIVED
		unset SEND
		unset HOUR
		while read line; do
			IDLOCAL=$(echo ${line} | cut -d',' -f2)
			RECIVED+="$(echo ${line} | cut -d',' -f3)+"
			SEND+="$(echo ${line} | cut -d',' -f4)+"
			DATESEC=$(date +%s --date="$(echo ${line} | cut -d',' -f5 | cut -d' ' -f1,2,3,4)")
			TIMEON="$(($(date +%s) - ${DATESEC}))"
			MIN=$(($TIMEON / 60)) && SEC=$(($TIMEON - $MIN * 60)) && HOR=$(($MIN / 60)) && MIN=$(($MIN - $HOR * 60))
			HOUR+="${HOR}h:${MIN}m:${SEC}s\n"
			let i++
		done <<<"$(sed -n "/^${user},/p" /etc/openvpn/openvpn-status.log)"
		RECIVED=$(echo $(echo ${RECIVED}0 | bc) | byte)
		SEND=$(echo $(echo ${SEND}0 | bc) | byte)
		HOUR=$(echo -e $HOUR | sort -n | tail -1)
		echo -e "$user|$i|$RECIVED|$SEND|$HOUR"
	done
}
monitor-user() {
	users=$(cat /etc/passwd | grep 'home' | grep 'false' | grep -v 'syslog' | awk -F ':' '{print $1}')
	dpids=$(droppids)
	time=$(date +%s)
	[[ -e /etc/openvpn/openvpn-status.log ]] && ovpn_log=$(cat /etc/openvpn/openvpn-status.log)

	n='0'
	i='0'
	conect='0'
	for _user in $users; do
		[[ -z "$(ps -u $_user | grep sshd)" ]] && sqd=0 || sqd=1
		[[ -z "$(echo $ovpn_log | grep -E ,"$_user",)" ]] && ovp=0 || ovp=1
		[[ -z "$(echo $dpids | grep -w "$_user")" ]] && drop=0 || drop=1

		conex=$(($sqd + $ovp + $drop))
		#   conex="$(echo $PID|bc)"
		[[ $conex -ne 0 ]] && let conect++

		if [[ $(chage -l $_user | grep 'Account expires' | awk -F ': ' '{print $2}') != never ]]; then
			[[ $time -gt $(date '+%s' -d "$(chage -l $_user | grep "Account expires" | awk -F ': ' '{print $2}')") ]] && let n++
		fi
		[[ $(passwd --status $_user | cut -d ' ' -f2) = "L" ]] && let i++
	done

	_onlin=$(printf '%-7s' "$conect")
	_userexp=$(printf '%-7s' "$n")
	_lok=$(printf '%-7s' "$i")
	_tuser=$(echo "$users" | sed '/^$/d' | wc -l)

	echo -e " $(msg -verd "ONLINE:") $(msg -azu "$_onlin") $(msg -verm2 "EXPIRADOS:") $(msg -azu "$_userexp") $(msg -bra "\e[95mBLOQUEADO:") $(msg -azu "$_lok")" #$(msg -ama "TOTAL:") $(msg -azu "$_tuser")"
}
# SISTEMA DE SELECAO
selection_fun() {
	local selection="null"
	local range
	for ((i = 0; i <= $1; i++)); do range[$i]="$i "; done
	while [[ ! $(echo ${range[*]} | grep -w "$selection") ]]; do
		echo -ne "\033[1;37m► Selecione una Opcion: " >&2
		read selection
		tput cuu1 >&2 && tput dl1 >&2
	done
	echo $selection
}
export -f msg
export -f selection_fun
export -f fun_trans
export -f menu_func
export -f meu_ip
export -f fun_ip
export -f lacasita
clear
#echo 3 > /proc/sys/vm/drop_caches &>/dev/null
#sysctl -w vm.drop_caches=3 &>/dev/null
clear
msg -bar3
msg -tit
#
menu_info
msg -bar
# echo -e "\033[1;31m[\033[1;32m $vesaoSCT\033[1;97m"
# msg -bar
title=$(echo -e "\033[1;96m$(cat ${SCPdir}/message.txt)")
printf "%*s\n" $((($(echo -e "$title" | wc -c) + 55) / 2)) "$title"
msg -bar

SSHN="$(grep -c home /etc/passwd)"
#SSH2="$(echo ${SSHN}|bc)-2"
echo "${SSHN}" | bc >/etc/VPS-MX/controlador/SSH20.log
SSH3="$(less /etc/VPS-MX/controlador/SSH20.log)"
SSH4="$(echo $SSH3)"
user_info=$(cd /usr/local/shadowsocksr &>/dev/null && python mujson_mgr.py -l)
user_total=$(echo "${user_info}" | wc -l)
[[ ! -e /etc/VPS-MX/RegV2ray ]] && touch /etc/VPS-MX/RegV2ray
vray=$(cat /etc/VPS-MX/RegV2ray | wc -l)
on="\033[1;92m[ON]" && off="\033[1;31m[OFF]"
#[[ $(ps x | grep badvpn | grep -v grep | awk '{print $1}') ]] && badvpn=$on || badvpn=$off
echo -e "\033[1;97m   SSH REG:\033[1;92m $SSH4 \033[1;97m   SS-SSRR REG:\033[1;92m $user_total \033[1;97m   V2RAY REG:\e[32m $vray"
limseg="$(less /etc/VPS-MX/controlador/tiemlim.log)"
veri=$(ps x | grep -v grep | grep "verif")
[[ ! $veri ]] && verificar="\033[1;31m[OFF]" || verificar="\033[1;32m[ON] "
des=$(ps x | grep -v grep | grep "autode")
[[ ! $des ]] && desbloqueo="\033[1;31m[OFF]" || desbloqueo="\033[1;32m[ON] "
mon=$(ps x | grep -v grep | grep "monitor")
[[ ! $mon ]] && monitorserv="\033[1;31m[OFF]" || monitorserv="\033[1;32m[ON] "

if [[ ! -e ${SCPdir}/USRonlines ]]; then
	if [[ $(cat ${SCPdir}/tmp/style | grep -w "monitor-user" | awk '{print $2}') = "1" ]]; then
		monitor-user
	#  msg -bar
	fi

else
	[[ -e ${SCPdir}/USRonlines ]] && msg -bar && msg -ne "\033[1;97m LIMITADOR:\033[1;92m$verificar \033[1;97m AUTO-DESBLOQUEO:\033[1;92m$desbloqueo \e[1;97mMONITOR:\e[34m${limseg}s\n \033[1;32mCONECTADOS: " && echo -ne "\033[1;97m$(less ${SCPdir}/USRonlines) "
	[[ -e ${SCPdir}/USRexpired ]] && msg -ne "   EXPIRADOS: " && echo -ne "\033[1;97m$(less ${SCPdir}/USRexpired) " && msg -ne " \033[1;95m BLOQUEADOS: " && echo -e "\033[1;97m$(less ${SCPdir}/USRbloqueados)" #\n\033[1;97m        ACTULIZACION DE MONITOR CADA: \033[1;34m $limseg s"
fi

tcpBBR() {
	clear
	msg -tit
	echo ""
	echo -e "		\e[91m\e[43mTCP BBR ACELERADOR DE VPS\e[0m"
	msg -bar
	echo -e "\e[1;97m Este Script fue proyectado"
	echo -e " Para Mejorar La Latencia"
	echo -e " y velocidad del servidor!\e[0m"
	msg -bar
	if [[ $(grep -c "^#ADM" /etc/sysctl.conf) -eq 0 ]]; then
		#INSTALA
		echo -e "\e[1;93m configuraciones de red (BBR)"
		echo -e " del sistema para reducir"
		echo -e " la latencia y mejorar la velocidad\e[0m"
		msg -bar
		read -p " Continuar con la instalación? [s/n]: " -e -i s resp_osta
		echo -e "\033[1;37m"
		if [[ "$resp_osta" = 's' ]]; then
			unset resp_osta
			echo "#ADM" >>/etc/sysctl.conf
			echo "net.ipv4.tcp_window_scaling = 1
net.core.rmem_max = 16777216
net.core.wmem_max = 16777216
net.ipv4.tcp_rmem = 4096 87380 16777216
net.ipv4.tcp_wmem = 4096 16384 16777216
net.ipv4.tcp_low_latency = 1
net.ipv4.tcp_slow_start_after_idle = 0
net.core.default_qdisc=fq
net.ipv4.tcp_congestion_control=bbr" >>/etc/sysctl.conf
			sysctl -p /etc/sysctl.conf >/dev/null 2>&1
			msg -ama " Configuración de red TCP"
			msg -verd " TCP SPEED ACTIVADO"
			msg -bar
			return
		else
			msg -bar
			return
		fi
	else
		#REMOVE
		echo -e "\e[1;97m Configuración de red TCP"
		echo -e " ya se han agregado en el sistema!\e[0m"
		msg -bar
		read -p " Desea quitar la configuración TCP? [s/n]: " -e -i n res_posta
		if [[ "$res_posta" = 's' ]]; then
			unset res_posta
			grep -v "^#ADM
net.ipv4.tcp_window_scaling = 1
net.core.rmem_max = 16777216
net.core.wmem_max = 16777216
net.ipv4.tcp_rmem = 4096 87380 16777216
net.ipv4.tcp_wmem = 4096 16384 16777216
net.ipv4.tcp_low_latency = 1
net.ipv4.tcp_slow_start_after_idle = 0
net.core.default_qdisc=fq
net.ipv4.tcp_congestion_control=bbr" /etc/sysctl.conf >/tmp/syscl && mv -f /tmp/syscl /etc/sysctl.conf
			sysctl -p /etc/sysctl.conf >/dev/null 2>&1
			msg -ama " Configuración de red TCP"
			msg -verm " TCP SPEED DETENIDO"
			msg -bar
			return
		else
			msg -bar
			return
		fi
	fi
}

monhtop() {
	clear

	#msg -bar
	msg -tit
	echo -ne " \033[1;93m             MONITOR DE PROCESOS HTOP\n"
	msg -bar
	msg -bra "    RECUERDA SALIR CON : \033[1;96m CTRL + C o FIN + F10 "
	[[ $(dpkg --get-selections | grep -w "htop" | head -1) ]] || apt-get install htop -y &>/dev/null
	msg -bar
	read -t 10 -n 1 -rsp $'\033[1;39m Preciona Enter Para continuar\n'
	clear
	sudo htop
	msg -bar
	echo -e "\e[97m \033[1;41m| #-#-►  SCRIPT VPS•MX ◄-#-# | \033[1;49m\033[1;49m \033[1;31m[ \033[1;32m $vesaoSCT      "
	echo -ne " \033[1;93m             MONITOR DE PROCESOS HTOP\n"
	msg -bar
	echo -e "\e[97m                  FIN DEL MONITOR"
	msg -bar
}
oni="\033[1;32m[ON]" && offi="\033[1;31m[OFF]"
[[ $(grep -c "^#ADM" /etc/sysctl.conf) -eq 0 ]] && tcp=$offi || tcp=$oni
[[ $(ps x | grep v2ray | grep -v grep | awk '{print $1}') ]] && vra=$on || vra=$off
msg -bar
msg -bar3
on="\e[1;32m[ON]" && off="\e[1;31m[OFF]"
echo -e " \e[1;93m[\e[92m1\e[93m] $(msg -verm2 "➛ ") $(msg -azu "ADMINISTRAR CUENTAS | SSH/HWID/TOKEN")"
echo -e " \e[1;93m[\e[92m2\e[93m] $(msg -verm2 "➛ ") $(msg -azu "ADMINISTRAR CUENTAS | SS/SSRR")"
echo -e " \e[1;93m[\e[92m3\e[93m] $(msg -verm2 "➛ ") $(msg -azu "ADMINISTRAR CUENTAS | V2RAY --> $vra")"
echo -e " \e[1;93m[\e[92m4\e[93m] $(msg -verm2 "➛ ") \e[1;31m\033[47mPROTOCOLOS\e[0m  \e[93m||  \e[1;37m\e[41mHERRAMIENTAS\e[0m"
echo -e " \e[1;93m[\e[92m5\e[93m] $(msg -verm2 "➛ ") $(msg -azu "MONITOR DE PROTOCOLOS --------> ${monitorserv}")"
echo -e " \e[1;93m[\e[92m6\e[93m] $(msg -verm2 "➛ ") $(msg -azu "AUTO INICIAR SCRIPT ----------> $AutoRun ")"
echo -e " \e[1;93m[\e[92m7\e[93m] $(msg -verm2 "➛ ") $(msg -azu "TCP SPEED BBR        ---------> $tcp")"
msg -bar
echo -e " \e[1;93m[\e[92m8\e[93m] \e[97m$(msg -verm2 "➛ ") $(msg -verd "ACTUALIZAR") \e[1;93m [\e[92m9\e[93m]\e[97m$(msg -verm2 "➛ ")\033[1;31mDESINSTALAR  \e[1;93m[\e[92m0\e[93m]$(msg -verm2 "➛ ") $(msg -bra "\e[97m\033[1;41mSALIR")"
msg -bar

selection=$(selection_fun 13)
case ${selection} in
1) usercodes ;;
2) ${SCPinst}/C-SSR.sh ;;
3) v2ra ;;
4) menu3 ;;
5) monservi_fun ;;
6) fun_autorun ;;
7) tcpBBR ;;
8) atualiza_fun ;;
9) remove_script ;;
0) cd $HOME && exit 0 ;;
esac
msg -ne "Enter Para Continuar" && read enter
${SCPdir}/menu
